(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{"./node_modules/element-ui/lib/calendar.js":
/*!*************************************************!*\
  !*** ./node_modules/element-ui/lib/calendar.js ***!
  \*************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 66);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/utils/date-util */ \"./node_modules/element-ui/lib/utils/date-util.js\");\n\n/***/ }),\n\n/***/ 14:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/button */ \"./node_modules/element-ui/lib/button.js\");\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/utils/date */ \"./node_modules/element-ui/lib/utils/date.js\");\n\n/***/ }),\n\n/***/ 35:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/button-group */ \"./node_modules/element-ui/lib/button-group.js\");\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/mixins/locale */ \"./node_modules/element-ui/lib/mixins/locale.js\");\n\n/***/ }),\n\n/***/ 66:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/main.vue?vue&type=template&id=6d9756be&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"el-calendar\" }, [\n    _c(\"div\", { staticClass: \"el-calendar__header\" }, [\n      _c(\"div\", { staticClass: \"el-calendar__title\" }, [\n        _vm._v(\"\\n      \" + _vm._s(_vm.i18nDate) + \"\\n    \")\n      ]),\n      _vm.validatedRange.length === 0\n        ? _c(\n            \"div\",\n            { staticClass: \"el-calendar__button-group\" },\n            [\n              _c(\n                \"el-button-group\",\n                [\n                  _c(\n                    \"el-button\",\n                    {\n                      attrs: { type: \"plain\", size: \"mini\" },\n                      on: {\n                        click: function($event) {\n                          _vm.selectDate(\"prev-month\")\n                        }\n                      }\n                    },\n                    [\n                      _vm._v(\n                        \"\\n          \" +\n                          _vm._s(_vm.t(\"el.datepicker.prevMonth\")) +\n                          \"\\n        \"\n                      )\n                    ]\n                  ),\n                  _c(\n                    \"el-button\",\n                    {\n                      attrs: { type: \"plain\", size: \"mini\" },\n                      on: {\n                        click: function($event) {\n                          _vm.selectDate(\"today\")\n                        }\n                      }\n                    },\n                    [\n                      _vm._v(\n                        \"\\n          \" +\n                          _vm._s(_vm.t(\"el.datepicker.today\")) +\n                          \"\\n        \"\n                      )\n                    ]\n                  ),\n                  _c(\n                    \"el-button\",\n                    {\n                      attrs: { type: \"plain\", size: \"mini\" },\n                      on: {\n                        click: function($event) {\n                          _vm.selectDate(\"next-month\")\n                        }\n                      }\n                    },\n                    [\n                      _vm._v(\n                        \"\\n          \" +\n                          _vm._s(_vm.t(\"el.datepicker.nextMonth\")) +\n                          \"\\n        \"\n                      )\n                    ]\n                  )\n                ],\n                1\n              )\n            ],\n            1\n          )\n        : _vm._e()\n    ]),\n    _vm.validatedRange.length === 0\n      ? _c(\n          \"div\",\n          { key: \"no-range\", staticClass: \"el-calendar__body\" },\n          [\n            _c(\"date-table\", {\n              attrs: {\n                date: _vm.date,\n                \"selected-day\": _vm.realSelectedDay,\n                \"first-day-of-week\": _vm.realFirstDayOfWeek\n              },\n              on: { pick: _vm.pickDay }\n            })\n          ],\n          1\n        )\n      : _c(\n          \"div\",\n          { key: \"has-range\", staticClass: \"el-calendar__body\" },\n          _vm._l(_vm.validatedRange, function(range, index) {\n            return _c(\"date-table\", {\n              key: index,\n              attrs: {\n                date: range[0],\n                \"selected-day\": _vm.realSelectedDay,\n                range: range,\n                \"hide-header\": index !== 0,\n                \"first-day-of-week\": _vm.realFirstDayOfWeek\n              },\n              on: { pick: _vm.pickDay }\n            })\n          }),\n          1\n        )\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/calendar/src/main.vue?vue&type=template&id=6d9756be&\n\n// EXTERNAL MODULE: external \"element-ui/lib/mixins/locale\"\nvar locale_ = __webpack_require__(6);\nvar locale_default = /*#__PURE__*/__webpack_require__.n(locale_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/utils/date\"\nvar date_ = __webpack_require__(24);\nvar date_default = /*#__PURE__*/__webpack_require__.n(date_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/button\"\nvar button_ = __webpack_require__(14);\nvar button_default = /*#__PURE__*/__webpack_require__.n(button_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/button-group\"\nvar button_group_ = __webpack_require__(35);\nvar button_group_default = /*#__PURE__*/__webpack_require__.n(button_group_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/utils/date-util\"\nvar date_util_ = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/date-table.vue?vue&type=script&lang=js&\n\n\n\n\n/* harmony default export */ var date_tablevue_type_script_lang_js_ = ({\n  props: {\n    selectedDay: String, // formated date yyyy-MM-dd\n    range: {\n      type: Array,\n      validator: function validator(val) {\n        if (!(val && val.length)) return true;\n        var start = val[0],\n            end = val[1];\n\n        return Object(date_util_[\"validateRangeInOneMonth\"])(start, end);\n      }\n    },\n    date: Date,\n    hideHeader: Boolean,\n    firstDayOfWeek: Number\n  },\n\n  inject: ['elCalendar'],\n\n  methods: {\n    toNestedArr: function toNestedArr(days) {\n      return Object(date_util_[\"range\"])(days.length / 7).map(function (_, index) {\n        var start = index * 7;\n        return days.slice(start, start + 7);\n      });\n    },\n    getFormateDate: function getFormateDate(day, type) {\n      if (!day || ['prev', 'current', 'next'].indexOf(type) === -1) {\n        throw new Error('invalid day or type');\n      }\n      var prefix = this.curMonthDatePrefix;\n      if (type === 'prev') {\n        prefix = this.prevMonthDatePrefix;\n      } else if (type === 'next') {\n        prefix = this.nextMonthDatePrefix;\n      }\n      day = ('00' + day).slice(-2);\n      return prefix + '-' + day;\n    },\n    getCellClass: function getCellClass(_ref) {\n      var text = _ref.text,\n          type = _ref.type;\n\n      var classes = [type];\n      if (type === 'current') {\n        var date = this.getFormateDate(text, type);\n        if (date === this.selectedDay) {\n          classes.push('is-selected');\n        }\n        if (date === this.formatedToday) {\n          classes.push('is-today');\n        }\n      }\n      return classes;\n    },\n    pickDay: function pickDay(_ref2) {\n      var text = _ref2.text,\n          type = _ref2.type;\n\n      var date = this.getFormateDate(text, type);\n      this.$emit('pick', date);\n    },\n    cellRenderProxy: function cellRenderProxy(_ref3) {\n      var text = _ref3.text,\n          type = _ref3.type;\n      var h = this.$createElement;\n\n      var render = this.elCalendar.$scopedSlots.dateCell;\n      if (!render) return h('span', [text]);\n\n      var day = this.getFormateDate(text, type);\n      var date = new Date(day);\n      var data = {\n        isSelected: this.selectedDay === day,\n        type: type + '-month',\n        day: day\n      };\n      return render({ date: date, data: data });\n    }\n  },\n\n  computed: {\n    WEEK_DAYS: function WEEK_DAYS() {\n      return Object(date_util_[\"getI18nSettings\"])().dayNames;\n    },\n    prevMonthDatePrefix: function prevMonthDatePrefix() {\n      var temp = new Date(this.date.getTime());\n      temp.setDate(0);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    curMonthDatePrefix: function curMonthDatePrefix() {\n      return date_default.a.format(this.date, 'yyyy-MM');\n    },\n    nextMonthDatePrefix: function nextMonthDatePrefix() {\n      var temp = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 1);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    formatedToday: function formatedToday() {\n      return this.elCalendar.formatedToday;\n    },\n    isInRange: function isInRange() {\n      return this.range && this.range.length;\n    },\n    rows: function rows() {\n      var days = [];\n      // if range exists, should render days in range.\n      if (this.isInRange) {\n        var _range = this.range,\n            start = _range[0],\n            end = _range[1];\n\n        var currentMonthRange = Object(date_util_[\"range\"])(end.getDate() - start.getDate() + 1).map(function (_, index) {\n          return {\n            text: start.getDate() + index,\n            type: 'current'\n          };\n        });\n        var remaining = currentMonthRange.length % 7;\n        remaining = remaining === 0 ? 0 : 7 - remaining;\n        var nextMonthRange = Object(date_util_[\"range\"])(remaining).map(function (_, index) {\n          return {\n            text: index + 1,\n            type: 'next'\n          };\n        });\n        days = currentMonthRange.concat(nextMonthRange);\n      } else {\n        var date = this.date;\n        var firstDay = Object(date_util_[\"getFirstDayOfMonth\"])(date);\n        firstDay = firstDay === 0 ? 7 : firstDay;\n        var firstDayOfWeek = typeof this.firstDayOfWeek === 'number' ? this.firstDayOfWeek : 1;\n        var prevMonthDays = Object(date_util_[\"getPrevMonthLastDays\"])(date, firstDay - firstDayOfWeek).map(function (day) {\n          return {\n            text: day,\n            type: 'prev'\n          };\n        });\n        var currentMonthDays = Object(date_util_[\"getMonthDays\"])(date).map(function (day) {\n          return {\n            text: day,\n            type: 'current'\n          };\n        });\n        days = [].concat(prevMonthDays, currentMonthDays);\n        var nextMonthDays = Object(date_util_[\"range\"])(42 - days.length).map(function (_, index) {\n          return {\n            text: index + 1,\n            type: 'next'\n          };\n        });\n        days = days.concat(nextMonthDays);\n      }\n      return this.toNestedArr(days);\n    },\n    weekDays: function weekDays() {\n      var start = this.firstDayOfWeek;\n      var WEEK_DAYS = this.WEEK_DAYS;\n\n\n      if (typeof start !== 'number' || start === 0) {\n        return WEEK_DAYS.slice();\n      } else {\n        return WEEK_DAYS.slice(start).concat(WEEK_DAYS.slice(0, start));\n      }\n    }\n  },\n\n  render: function render() {\n    var _this = this;\n\n    var h = arguments[0];\n\n    var thead = this.hideHeader ? null : h('thead', [this.weekDays.map(function (day) {\n      return h(\n        'th',\n        { key: day },\n        [day]\n      );\n    })]);\n    return h(\n      'table',\n      {\n        'class': {\n          'el-calendar-table': true,\n          'is-range': this.isInRange\n        },\n        attrs: { cellspacing: '0',\n          cellpadding: '0' }\n      },\n      [thead, h('tbody', [this.rows.map(function (row, index) {\n        return h(\n          'tr',\n          {\n            'class': {\n              'el-calendar-table__row': true,\n              'el-calendar-table__row--hide-border': index === 0 && _this.hideHeader\n            },\n            key: index },\n          [row.map(function (cell, key) {\n            return h(\n              'td',\n              { key: key,\n                'class': _this.getCellClass(cell),\n                on: {\n                  'click': _this.pickDay.bind(_this, cell)\n                }\n              },\n              [h(\n                'div',\n                { 'class': 'el-calendar-day' },\n                [_this.cellRenderProxy(cell)]\n              )]\n            );\n          })]\n        );\n      })])]\n    );\n  }\n});\n// CONCATENATED MODULE: ./packages/calendar/src/date-table.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_date_tablevue_type_script_lang_js_ = (date_tablevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/calendar/src/date-table.vue\nvar date_table_render, date_table_staticRenderFns\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  src_date_tablevue_type_script_lang_js_,\n  date_table_render,\n  date_table_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"packages/calendar/src/date-table.vue\"\n/* harmony default export */ var date_table = (component.exports);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/main.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\nvar validTypes = ['prev-month', 'today', 'next-month'];\nvar weekDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nvar oneDay = 86400000;\n\n/* harmony default export */ var mainvue_type_script_lang_js_ = ({\n  name: 'ElCalendar',\n\n  mixins: [locale_default.a],\n\n  components: {\n    DateTable: date_table,\n    ElButton: button_default.a,\n    ElButtonGroup: button_group_default.a\n  },\n\n  props: {\n    value: [Date, String, Number],\n    range: {\n      type: Array,\n      validator: function validator(range) {\n        if (Array.isArray(range)) {\n          return range.length === 2 && range.every(function (item) {\n            return typeof item === 'string' || typeof item === 'number' || item instanceof Date;\n          });\n        } else {\n          return true;\n        }\n      }\n    },\n    firstDayOfWeek: {\n      type: Number,\n      default: 1\n    }\n  },\n\n  provide: function provide() {\n    return {\n      elCalendar: this\n    };\n  },\n\n\n  methods: {\n    pickDay: function pickDay(day) {\n      this.realSelectedDay = day;\n    },\n    selectDate: function selectDate(type) {\n      if (validTypes.indexOf(type) === -1) {\n        throw new Error('invalid type ' + type);\n      }\n      var day = '';\n      if (type === 'prev-month') {\n        day = this.prevMonthDatePrefix + '-01';\n      } else if (type === 'next-month') {\n        day = this.nextMonthDatePrefix + '-01';\n      } else {\n        day = this.formatedToday;\n      }\n\n      if (day === this.formatedDate) return;\n      this.pickDay(day);\n    },\n    toDate: function toDate(val) {\n      if (!val) {\n        throw new Error('invalid val');\n      }\n      return val instanceof Date ? val : new Date(val);\n    },\n    rangeValidator: function rangeValidator(date, isStart) {\n      var firstDayOfWeek = this.realFirstDayOfWeek;\n      var expected = isStart ? firstDayOfWeek : firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;\n      var message = (isStart ? 'start' : 'end') + ' of range should be ' + weekDays[expected] + '.';\n      if (date.getDay() !== expected) {\n        console.warn('[ElementCalendar]', message, 'Invalid range will be ignored.');\n        return false;\n      }\n      return true;\n    }\n  },\n\n  computed: {\n    prevMonthDatePrefix: function prevMonthDatePrefix() {\n      var temp = new Date(this.date.getTime());\n      temp.setDate(0);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    curMonthDatePrefix: function curMonthDatePrefix() {\n      return date_default.a.format(this.date, 'yyyy-MM');\n    },\n    nextMonthDatePrefix: function nextMonthDatePrefix() {\n      var temp = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 1);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    formatedDate: function formatedDate() {\n      return date_default.a.format(this.date, 'yyyy-MM-dd');\n    },\n    i18nDate: function i18nDate() {\n      var year = this.date.getFullYear();\n      var month = this.date.getMonth() + 1;\n      return year + ' ' + this.t('el.datepicker.year') + ' ' + this.t('el.datepicker.month' + month);\n    },\n    formatedToday: function formatedToday() {\n      return date_default.a.format(this.now, 'yyyy-MM-dd');\n    },\n\n\n    realSelectedDay: {\n      get: function get() {\n        if (!this.value) return this.selectedDay;\n        return this.formatedDate;\n      },\n      set: function set(val) {\n        this.selectedDay = val;\n        var date = new Date(val);\n        this.$emit('input', date);\n      }\n    },\n\n    date: function date() {\n      if (!this.value) {\n        if (this.realSelectedDay) {\n          var d = this.selectedDay.split('-');\n          return new Date(d[0], d[1] - 1, d[2]);\n        } else if (this.validatedRange.length) {\n          return this.validatedRange[0][0];\n        }\n        return this.now;\n      } else {\n        return this.toDate(this.value);\n      }\n    },\n\n\n    // if range is valid, we get a two-digit array\n    validatedRange: function validatedRange() {\n      var _this = this;\n\n      var range = this.range;\n      if (!range) return [];\n      range = range.reduce(function (prev, val, index) {\n        var date = _this.toDate(val);\n        if (_this.rangeValidator(date, index === 0)) {\n          prev = prev.concat(date);\n        }\n        return prev;\n      }, []);\n      if (range.length === 2) {\n        var _range = range,\n            start = _range[0],\n            end = _range[1];\n\n        if (start > end) {\n          console.warn('[ElementCalendar]end time should be greater than start time');\n          return [];\n        }\n        // start time and end time in one month\n        if (Object(date_util_[\"validateRangeInOneMonth\"])(start, end)) {\n          return [[start, end]];\n        }\n        var data = [];\n        var startDay = new Date(start.getFullYear(), start.getMonth() + 1, 1);\n        var lastDay = this.toDate(startDay.getTime() - oneDay);\n        if (!Object(date_util_[\"validateRangeInOneMonth\"])(startDay, end)) {\n          console.warn('[ElementCalendar]start time and end time interval must not exceed two months');\n          return [];\n        }\n        // 第一个月的时间范围\n        data.push([start, lastDay]);\n        // 下一月的时间范围，需要计算一下该月的第一个周起始日\n        var firstDayOfWeek = this.realFirstDayOfWeek;\n        var nextMontFirstDay = startDay.getDay();\n        var interval = 0;\n        if (nextMontFirstDay !== firstDayOfWeek) {\n          if (firstDayOfWeek === 0) {\n            interval = 7 - nextMontFirstDay;\n          } else {\n            interval = firstDayOfWeek - nextMontFirstDay;\n            interval = interval > 0 ? interval : 7 + interval;\n          }\n        }\n        startDay = this.toDate(startDay.getTime() + interval * oneDay);\n        if (startDay.getDate() < end.getDate()) {\n          data.push([startDay, end]);\n        }\n        return data;\n      }\n      return [];\n    },\n    realFirstDayOfWeek: function realFirstDayOfWeek() {\n      if (this.firstDayOfWeek < 1 || this.firstDayOfWeek > 6) {\n        return 0;\n      }\n      return Math.floor(this.firstDayOfWeek);\n    }\n  },\n\n  data: function data() {\n    return {\n      selectedDay: '',\n      now: new Date()\n    };\n  }\n});\n// CONCATENATED MODULE: ./packages/calendar/src/main.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_mainvue_type_script_lang_js_ = (mainvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/calendar/src/main.vue\n\n\n\n\n\n/* normalize component */\n\nvar main_component = Object(componentNormalizer[\"a\" /* default */])(\n  src_mainvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var main_api; }\nmain_component.options.__file = \"packages/calendar/src/main.vue\"\n/* harmony default export */ var main = (main_component.exports);\n// CONCATENATED MODULE: ./packages/calendar/index.js\n\n\n/* istanbul ignore next */\nmain.install = function (Vue) {\n  Vue.component(main.name, main);\n};\n\n/* harmony default export */ var calendar = __webpack_exports__[\"default\"] = (main);\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvY2FsZW5kYXIuanM/ZTM2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRiwyQkFBMkIsRUFBRTtBQUN4SDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9HO0FBQ0E7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVAsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi9jYWxlbmRhci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNjYpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyAwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbm9ybWFsaXplQ29tcG9uZW50OyB9KTtcbi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL3V0aWxzL2RhdGUtdXRpbFwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDE0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi9idXR0b25cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvdXRpbHMvZGF0ZVwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDM1OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi9idXR0b24tZ3JvdXBcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi9taXhpbnMvbG9jYWxlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjY6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2NhbGVuZGFyL3NyYy9tYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02ZDk3NTZiZSZcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJlbC1jYWxlbmRhclwiIH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImVsLWNhbGVuZGFyX19oZWFkZXJcIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImVsLWNhbGVuZGFyX190aXRsZVwiIH0sIFtcbiAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgXCIgKyBfdm0uX3MoX3ZtLmkxOG5EYXRlKSArIFwiXFxuICAgIFwiKVxuICAgICAgXSksXG4gICAgICBfdm0udmFsaWRhdGVkUmFuZ2UubGVuZ3RoID09PSAwXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1jYWxlbmRhcl9fYnV0dG9uLWdyb3VwXCIgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJlbC1idXR0b24tZ3JvdXBcIixcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJlbC1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwicGxhaW5cIiwgc2l6ZTogXCJtaW5pXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2VsZWN0RGF0ZShcInByZXYtbW9udGhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udChcImVsLmRhdGVwaWNrZXIucHJldk1vbnRoXCIpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICBcImVsLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJwbGFpblwiLCBzaXplOiBcIm1pbmlcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5zZWxlY3REYXRlKFwidG9kYXlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udChcImVsLmRhdGVwaWNrZXIudG9kYXlcIikpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwiZWwtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcInBsYWluXCIsIHNpemU6IFwibWluaVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnNlbGVjdERhdGUoXCJuZXh0LW1vbnRoXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLnQoXCJlbC5kYXRlcGlja2VyLm5leHRNb250aFwiKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApXG4gICAgICAgIDogX3ZtLl9lKClcbiAgICBdKSxcbiAgICBfdm0udmFsaWRhdGVkUmFuZ2UubGVuZ3RoID09PSAwXG4gICAgICA/IF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBrZXk6IFwibm8tcmFuZ2VcIiwgc3RhdGljQ2xhc3M6IFwiZWwtY2FsZW5kYXJfX2JvZHlcIiB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwiZGF0ZS10YWJsZVwiLCB7XG4gICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgZGF0ZTogX3ZtLmRhdGUsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZC1kYXlcIjogX3ZtLnJlYWxTZWxlY3RlZERheSxcbiAgICAgICAgICAgICAgICBcImZpcnN0LWRheS1vZi13ZWVrXCI6IF92bS5yZWFsRmlyc3REYXlPZldlZWtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb246IHsgcGljazogX3ZtLnBpY2tEYXkgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgOiBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHsga2V5OiBcImhhcy1yYW5nZVwiLCBzdGF0aWNDbGFzczogXCJlbC1jYWxlbmRhcl9fYm9keVwiIH0sXG4gICAgICAgICAgX3ZtLl9sKF92bS52YWxpZGF0ZWRSYW5nZSwgZnVuY3Rpb24ocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gX2MoXCJkYXRlLXRhYmxlXCIsIHtcbiAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBkYXRlOiByYW5nZVswXSxcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkLWRheVwiOiBfdm0ucmVhbFNlbGVjdGVkRGF5LFxuICAgICAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgICAgICBcImhpZGUtaGVhZGVyXCI6IGluZGV4ICE9PSAwLFxuICAgICAgICAgICAgICAgIFwiZmlyc3QtZGF5LW9mLXdlZWtcIjogX3ZtLnJlYWxGaXJzdERheU9mV2Vla1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjogeyBwaWNrOiBfdm0ucGlja0RheSB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2NhbGVuZGFyL3NyYy9tYWluLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02ZDk3NTZiZSZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL21peGlucy9sb2NhbGVcIlxudmFyIGxvY2FsZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGxvY2FsZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2NhbGVfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL3V0aWxzL2RhdGVcIlxudmFyIGRhdGVfID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG52YXIgZGF0ZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihkYXRlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi9idXR0b25cIlxudmFyIGJ1dHRvbl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbnZhciBidXR0b25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYnV0dG9uXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi9idXR0b24tZ3JvdXBcIlxudmFyIGJ1dHRvbl9ncm91cF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcbnZhciBidXR0b25fZ3JvdXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYnV0dG9uX2dyb3VwXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy9kYXRlLXV0aWxcIlxudmFyIGRhdGVfdXRpbF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9jYWxlbmRhci9zcmMvZGF0ZS10YWJsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBwcm9wczoge1xuICAgIHNlbGVjdGVkRGF5OiBTdHJpbmcsIC8vIGZvcm1hdGVkIGRhdGUgeXl5eS1NTS1kZFxuICAgIHJhbmdlOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbCkge1xuICAgICAgICBpZiAoISh2YWwgJiYgdmFsLmxlbmd0aCkpIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgc3RhcnQgPSB2YWxbMF0sXG4gICAgICAgICAgICBlbmQgPSB2YWxbMV07XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1widmFsaWRhdGVSYW5nZUluT25lTW9udGhcIl0pKHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0ZTogRGF0ZSxcbiAgICBoaWRlSGVhZGVyOiBCb29sZWFuLFxuICAgIGZpcnN0RGF5T2ZXZWVrOiBOdW1iZXJcbiAgfSxcblxuICBpbmplY3Q6IFsnZWxDYWxlbmRhciddLFxuXG4gIG1ldGhvZHM6IHtcbiAgICB0b05lc3RlZEFycjogZnVuY3Rpb24gdG9OZXN0ZWRBcnIoZGF5cykge1xuICAgICAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wicmFuZ2VcIl0pKGRheXMubGVuZ3RoIC8gNykubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBpbmRleCAqIDc7XG4gICAgICAgIHJldHVybiBkYXlzLnNsaWNlKHN0YXJ0LCBzdGFydCArIDcpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRGb3JtYXRlRGF0ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0ZURhdGUoZGF5LCB0eXBlKSB7XG4gICAgICBpZiAoIWRheSB8fCBbJ3ByZXYnLCAnY3VycmVudCcsICduZXh0J10uaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRheSBvciB0eXBlJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJlZml4ID0gdGhpcy5jdXJNb250aERhdGVQcmVmaXg7XG4gICAgICBpZiAodHlwZSA9PT0gJ3ByZXYnKSB7XG4gICAgICAgIHByZWZpeCA9IHRoaXMucHJldk1vbnRoRGF0ZVByZWZpeDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25leHQnKSB7XG4gICAgICAgIHByZWZpeCA9IHRoaXMubmV4dE1vbnRoRGF0ZVByZWZpeDtcbiAgICAgIH1cbiAgICAgIGRheSA9ICgnMDAnICsgZGF5KS5zbGljZSgtMik7XG4gICAgICByZXR1cm4gcHJlZml4ICsgJy0nICsgZGF5O1xuICAgIH0sXG4gICAgZ2V0Q2VsbENsYXNzOiBmdW5jdGlvbiBnZXRDZWxsQ2xhc3MoX3JlZikge1xuICAgICAgdmFyIHRleHQgPSBfcmVmLnRleHQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYudHlwZTtcblxuICAgICAgdmFyIGNsYXNzZXMgPSBbdHlwZV07XG4gICAgICBpZiAodHlwZSA9PT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5nZXRGb3JtYXRlRGF0ZSh0ZXh0LCB0eXBlKTtcbiAgICAgICAgaWYgKGRhdGUgPT09IHRoaXMuc2VsZWN0ZWREYXkpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2goJ2lzLXNlbGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGUgPT09IHRoaXMuZm9ybWF0ZWRUb2RheSkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaCgnaXMtdG9kYXknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfSxcbiAgICBwaWNrRGF5OiBmdW5jdGlvbiBwaWNrRGF5KF9yZWYyKSB7XG4gICAgICB2YXIgdGV4dCA9IF9yZWYyLnRleHQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYyLnR5cGU7XG5cbiAgICAgIHZhciBkYXRlID0gdGhpcy5nZXRGb3JtYXRlRGF0ZSh0ZXh0LCB0eXBlKTtcbiAgICAgIHRoaXMuJGVtaXQoJ3BpY2snLCBkYXRlKTtcbiAgICB9LFxuICAgIGNlbGxSZW5kZXJQcm94eTogZnVuY3Rpb24gY2VsbFJlbmRlclByb3h5KF9yZWYzKSB7XG4gICAgICB2YXIgdGV4dCA9IF9yZWYzLnRleHQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYzLnR5cGU7XG4gICAgICB2YXIgaCA9IHRoaXMuJGNyZWF0ZUVsZW1lbnQ7XG5cbiAgICAgIHZhciByZW5kZXIgPSB0aGlzLmVsQ2FsZW5kYXIuJHNjb3BlZFNsb3RzLmRhdGVDZWxsO1xuICAgICAgaWYgKCFyZW5kZXIpIHJldHVybiBoKCdzcGFuJywgW3RleHRdKTtcblxuICAgICAgdmFyIGRheSA9IHRoaXMuZ2V0Rm9ybWF0ZURhdGUodGV4dCwgdHlwZSk7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGRheSk7XG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgaXNTZWxlY3RlZDogdGhpcy5zZWxlY3RlZERheSA9PT0gZGF5LFxuICAgICAgICB0eXBlOiB0eXBlICsgJy1tb250aCcsXG4gICAgICAgIGRheTogZGF5XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlbmRlcih7IGRhdGU6IGRhdGUsIGRhdGE6IGRhdGEgfSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgV0VFS19EQVlTOiBmdW5jdGlvbiBXRUVLX0RBWVMoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJnZXRJMThuU2V0dGluZ3NcIl0pKCkuZGF5TmFtZXM7XG4gICAgfSxcbiAgICBwcmV2TW9udGhEYXRlUHJlZml4OiBmdW5jdGlvbiBwcmV2TW9udGhEYXRlUHJlZml4KCkge1xuICAgICAgdmFyIHRlbXAgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0VGltZSgpKTtcbiAgICAgIHRlbXAuc2V0RGF0ZSgwKTtcbiAgICAgIHJldHVybiBkYXRlX2RlZmF1bHQuYS5mb3JtYXQodGVtcCwgJ3l5eXktTU0nKTtcbiAgICB9LFxuICAgIGN1ck1vbnRoRGF0ZVByZWZpeDogZnVuY3Rpb24gY3VyTW9udGhEYXRlUHJlZml4KCkge1xuICAgICAgcmV0dXJuIGRhdGVfZGVmYXVsdC5hLmZvcm1hdCh0aGlzLmRhdGUsICd5eXl5LU1NJyk7XG4gICAgfSxcbiAgICBuZXh0TW9udGhEYXRlUHJlZml4OiBmdW5jdGlvbiBuZXh0TW9udGhEYXRlUHJlZml4KCkge1xuICAgICAgdmFyIHRlbXAgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKSwgdGhpcy5kYXRlLmdldE1vbnRoKCkgKyAxLCAxKTtcbiAgICAgIHJldHVybiBkYXRlX2RlZmF1bHQuYS5mb3JtYXQodGVtcCwgJ3l5eXktTU0nKTtcbiAgICB9LFxuICAgIGZvcm1hdGVkVG9kYXk6IGZ1bmN0aW9uIGZvcm1hdGVkVG9kYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbENhbGVuZGFyLmZvcm1hdGVkVG9kYXk7XG4gICAgfSxcbiAgICBpc0luUmFuZ2U6IGZ1bmN0aW9uIGlzSW5SYW5nZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlICYmIHRoaXMucmFuZ2UubGVuZ3RoO1xuICAgIH0sXG4gICAgcm93czogZnVuY3Rpb24gcm93cygpIHtcbiAgICAgIHZhciBkYXlzID0gW107XG4gICAgICAvLyBpZiByYW5nZSBleGlzdHMsIHNob3VsZCByZW5kZXIgZGF5cyBpbiByYW5nZS5cbiAgICAgIGlmICh0aGlzLmlzSW5SYW5nZSkge1xuICAgICAgICB2YXIgX3JhbmdlID0gdGhpcy5yYW5nZSxcbiAgICAgICAgICAgIHN0YXJ0ID0gX3JhbmdlWzBdLFxuICAgICAgICAgICAgZW5kID0gX3JhbmdlWzFdO1xuXG4gICAgICAgIHZhciBjdXJyZW50TW9udGhSYW5nZSA9IE9iamVjdChkYXRlX3V0aWxfW1wicmFuZ2VcIl0pKGVuZC5nZXREYXRlKCkgLSBzdGFydC5nZXREYXRlKCkgKyAxKS5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHN0YXJ0LmdldERhdGUoKSArIGluZGV4LFxuICAgICAgICAgICAgdHlwZTogJ2N1cnJlbnQnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZW1haW5pbmcgPSBjdXJyZW50TW9udGhSYW5nZS5sZW5ndGggJSA3O1xuICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcgPT09IDAgPyAwIDogNyAtIHJlbWFpbmluZztcbiAgICAgICAgdmFyIG5leHRNb250aFJhbmdlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJyYW5nZVwiXSkocmVtYWluaW5nKS5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGluZGV4ICsgMSxcbiAgICAgICAgICAgIHR5cGU6ICduZXh0J1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkYXlzID0gY3VycmVudE1vbnRoUmFuZ2UuY29uY2F0KG5leHRNb250aFJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5kYXRlO1xuICAgICAgICB2YXIgZmlyc3REYXkgPSBPYmplY3QoZGF0ZV91dGlsX1tcImdldEZpcnN0RGF5T2ZNb250aFwiXSkoZGF0ZSk7XG4gICAgICAgIGZpcnN0RGF5ID0gZmlyc3REYXkgPT09IDAgPyA3IDogZmlyc3REYXk7XG4gICAgICAgIHZhciBmaXJzdERheU9mV2VlayA9IHR5cGVvZiB0aGlzLmZpcnN0RGF5T2ZXZWVrID09PSAnbnVtYmVyJyA/IHRoaXMuZmlyc3REYXlPZldlZWsgOiAxO1xuICAgICAgICB2YXIgcHJldk1vbnRoRGF5cyA9IE9iamVjdChkYXRlX3V0aWxfW1wiZ2V0UHJldk1vbnRoTGFzdERheXNcIl0pKGRhdGUsIGZpcnN0RGF5IC0gZmlyc3REYXlPZldlZWspLm1hcChmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRheSxcbiAgICAgICAgICAgIHR5cGU6ICdwcmV2J1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3VycmVudE1vbnRoRGF5cyA9IE9iamVjdChkYXRlX3V0aWxfW1wiZ2V0TW9udGhEYXlzXCJdKShkYXRlKS5tYXAoZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXksXG4gICAgICAgICAgICB0eXBlOiAnY3VycmVudCdcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZGF5cyA9IFtdLmNvbmNhdChwcmV2TW9udGhEYXlzLCBjdXJyZW50TW9udGhEYXlzKTtcbiAgICAgICAgdmFyIG5leHRNb250aERheXMgPSBPYmplY3QoZGF0ZV91dGlsX1tcInJhbmdlXCJdKSg0MiAtIGRheXMubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGluZGV4ICsgMSxcbiAgICAgICAgICAgIHR5cGU6ICduZXh0J1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkYXlzID0gZGF5cy5jb25jYXQobmV4dE1vbnRoRGF5cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50b05lc3RlZEFycihkYXlzKTtcbiAgICB9LFxuICAgIHdlZWtEYXlzOiBmdW5jdGlvbiB3ZWVrRGF5cygpIHtcbiAgICAgIHZhciBzdGFydCA9IHRoaXMuZmlyc3REYXlPZldlZWs7XG4gICAgICB2YXIgV0VFS19EQVlTID0gdGhpcy5XRUVLX0RBWVM7XG5cblxuICAgICAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicgfHwgc3RhcnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFdFRUtfREFZUy5zbGljZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFdFRUtfREFZUy5zbGljZShzdGFydCkuY29uY2F0KFdFRUtfREFZUy5zbGljZSgwLCBzdGFydCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGggPSBhcmd1bWVudHNbMF07XG5cbiAgICB2YXIgdGhlYWQgPSB0aGlzLmhpZGVIZWFkZXIgPyBudWxsIDogaCgndGhlYWQnLCBbdGhpcy53ZWVrRGF5cy5tYXAoZnVuY3Rpb24gKGRheSkge1xuICAgICAgcmV0dXJuIGgoXG4gICAgICAgICd0aCcsXG4gICAgICAgIHsga2V5OiBkYXkgfSxcbiAgICAgICAgW2RheV1cbiAgICAgICk7XG4gICAgfSldKTtcbiAgICByZXR1cm4gaChcbiAgICAgICd0YWJsZScsXG4gICAgICB7XG4gICAgICAgICdjbGFzcyc6IHtcbiAgICAgICAgICAnZWwtY2FsZW5kYXItdGFibGUnOiB0cnVlLFxuICAgICAgICAgICdpcy1yYW5nZSc6IHRoaXMuaXNJblJhbmdlXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB7IGNlbGxzcGFjaW5nOiAnMCcsXG4gICAgICAgICAgY2VsbHBhZGRpbmc6ICcwJyB9XG4gICAgICB9LFxuICAgICAgW3RoZWFkLCBoKCd0Ym9keScsIFt0aGlzLnJvd3MubWFwKGZ1bmN0aW9uIChyb3csIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBoKFxuICAgICAgICAgICd0cicsXG4gICAgICAgICAge1xuICAgICAgICAgICAgJ2NsYXNzJzoge1xuICAgICAgICAgICAgICAnZWwtY2FsZW5kYXItdGFibGVfX3Jvdyc6IHRydWUsXG4gICAgICAgICAgICAgICdlbC1jYWxlbmRhci10YWJsZV9fcm93LS1oaWRlLWJvcmRlcic6IGluZGV4ID09PSAwICYmIF90aGlzLmhpZGVIZWFkZXJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXk6IGluZGV4IH0sXG4gICAgICAgICAgW3Jvdy5tYXAoZnVuY3Rpb24gKGNlbGwsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGgoXG4gICAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICAgIHsga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogX3RoaXMuZ2V0Q2VsbENsYXNzKGNlbGwpLFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAnY2xpY2snOiBfdGhpcy5waWNrRGF5LmJpbmQoX3RoaXMsIGNlbGwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbaChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7ICdjbGFzcyc6ICdlbC1jYWxlbmRhci1kYXknIH0sXG4gICAgICAgICAgICAgICAgW190aGlzLmNlbGxSZW5kZXJQcm94eShjZWxsKV1cbiAgICAgICAgICAgICAgKV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSldXG4gICAgICAgICk7XG4gICAgICB9KV0pXVxuICAgICk7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9jYWxlbmRhci9zcmMvZGF0ZS10YWJsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX2RhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbnZhciBjb21wb25lbnROb3JtYWxpemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9jYWxlbmRhci9zcmMvZGF0ZS10YWJsZS52dWVcbnZhciBkYXRlX3RhYmxlX3JlbmRlciwgZGF0ZV90YWJsZV9zdGF0aWNSZW5kZXJGbnNcblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBzcmNfZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgZGF0ZV90YWJsZV9yZW5kZXIsXG4gIGRhdGVfdGFibGVfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFja2FnZXMvY2FsZW5kYXIvc3JjL2RhdGUtdGFibGUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRhdGVfdGFibGUgPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvY2FsZW5kYXIvc3JjL21haW4udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuXG5cblxuXG52YXIgdmFsaWRUeXBlcyA9IFsncHJldi1tb250aCcsICd0b2RheScsICduZXh0LW1vbnRoJ107XG52YXIgd2Vla0RheXMgPSBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J107XG52YXIgb25lRGF5ID0gODY0MDAwMDA7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1haW52dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnRWxDYWxlbmRhcicsXG5cbiAgbWl4aW5zOiBbbG9jYWxlX2RlZmF1bHQuYV0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIERhdGVUYWJsZTogZGF0ZV90YWJsZSxcbiAgICBFbEJ1dHRvbjogYnV0dG9uX2RlZmF1bHQuYSxcbiAgICBFbEJ1dHRvbkdyb3VwOiBidXR0b25fZ3JvdXBfZGVmYXVsdC5hXG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogW0RhdGUsIFN0cmluZywgTnVtYmVyXSxcbiAgICByYW5nZToge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcihyYW5nZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYW5nZSkpIHtcbiAgICAgICAgICByZXR1cm4gcmFuZ2UubGVuZ3RoID09PSAyICYmIHJhbmdlLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyB8fCBpdGVtIGluc3RhbmNlb2YgRGF0ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmlyc3REYXlPZldlZWs6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9XG4gIH0sXG5cbiAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxDYWxlbmRhcjogdGhpc1xuICAgIH07XG4gIH0sXG5cblxuICBtZXRob2RzOiB7XG4gICAgcGlja0RheTogZnVuY3Rpb24gcGlja0RheShkYXkpIHtcbiAgICAgIHRoaXMucmVhbFNlbGVjdGVkRGF5ID0gZGF5O1xuICAgIH0sXG4gICAgc2VsZWN0RGF0ZTogZnVuY3Rpb24gc2VsZWN0RGF0ZSh0eXBlKSB7XG4gICAgICBpZiAodmFsaWRUeXBlcy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZSAnICsgdHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgZGF5ID0gJyc7XG4gICAgICBpZiAodHlwZSA9PT0gJ3ByZXYtbW9udGgnKSB7XG4gICAgICAgIGRheSA9IHRoaXMucHJldk1vbnRoRGF0ZVByZWZpeCArICctMDEnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmV4dC1tb250aCcpIHtcbiAgICAgICAgZGF5ID0gdGhpcy5uZXh0TW9udGhEYXRlUHJlZml4ICsgJy0wMSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXkgPSB0aGlzLmZvcm1hdGVkVG9kYXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXkgPT09IHRoaXMuZm9ybWF0ZWREYXRlKSByZXR1cm47XG4gICAgICB0aGlzLnBpY2tEYXkoZGF5KTtcbiAgICB9LFxuICAgIHRvRGF0ZTogZnVuY3Rpb24gdG9EYXRlKHZhbCkge1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhbCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIERhdGUgPyB2YWwgOiBuZXcgRGF0ZSh2YWwpO1xuICAgIH0sXG4gICAgcmFuZ2VWYWxpZGF0b3I6IGZ1bmN0aW9uIHJhbmdlVmFsaWRhdG9yKGRhdGUsIGlzU3RhcnQpIHtcbiAgICAgIHZhciBmaXJzdERheU9mV2VlayA9IHRoaXMucmVhbEZpcnN0RGF5T2ZXZWVrO1xuICAgICAgdmFyIGV4cGVjdGVkID0gaXNTdGFydCA/IGZpcnN0RGF5T2ZXZWVrIDogZmlyc3REYXlPZldlZWsgPT09IDAgPyA2IDogZmlyc3REYXlPZldlZWsgLSAxO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAoaXNTdGFydCA/ICdzdGFydCcgOiAnZW5kJykgKyAnIG9mIHJhbmdlIHNob3VsZCBiZSAnICsgd2Vla0RheXNbZXhwZWN0ZWRdICsgJy4nO1xuICAgICAgaWYgKGRhdGUuZ2V0RGF5KCkgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW0VsZW1lbnRDYWxlbmRhcl0nLCBtZXNzYWdlLCAnSW52YWxpZCByYW5nZSB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHByZXZNb250aERhdGVQcmVmaXg6IGZ1bmN0aW9uIHByZXZNb250aERhdGVQcmVmaXgoKSB7XG4gICAgICB2YXIgdGVtcCA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgdGVtcC5zZXREYXRlKDApO1xuICAgICAgcmV0dXJuIGRhdGVfZGVmYXVsdC5hLmZvcm1hdCh0ZW1wLCAneXl5eS1NTScpO1xuICAgIH0sXG4gICAgY3VyTW9udGhEYXRlUHJlZml4OiBmdW5jdGlvbiBjdXJNb250aERhdGVQcmVmaXgoKSB7XG4gICAgICByZXR1cm4gZGF0ZV9kZWZhdWx0LmEuZm9ybWF0KHRoaXMuZGF0ZSwgJ3l5eXktTU0nKTtcbiAgICB9LFxuICAgIG5leHRNb250aERhdGVQcmVmaXg6IGZ1bmN0aW9uIG5leHRNb250aERhdGVQcmVmaXgoKSB7XG4gICAgICB2YXIgdGVtcCA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSArIDEsIDEpO1xuICAgICAgcmV0dXJuIGRhdGVfZGVmYXVsdC5hLmZvcm1hdCh0ZW1wLCAneXl5eS1NTScpO1xuICAgIH0sXG4gICAgZm9ybWF0ZWREYXRlOiBmdW5jdGlvbiBmb3JtYXRlZERhdGUoKSB7XG4gICAgICByZXR1cm4gZGF0ZV9kZWZhdWx0LmEuZm9ybWF0KHRoaXMuZGF0ZSwgJ3l5eXktTU0tZGQnKTtcbiAgICB9LFxuICAgIGkxOG5EYXRlOiBmdW5jdGlvbiBpMThuRGF0ZSgpIHtcbiAgICAgIHZhciB5ZWFyID0gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbW9udGggPSB0aGlzLmRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICByZXR1cm4geWVhciArICcgJyArIHRoaXMudCgnZWwuZGF0ZXBpY2tlci55ZWFyJykgKyAnICcgKyB0aGlzLnQoJ2VsLmRhdGVwaWNrZXIubW9udGgnICsgbW9udGgpO1xuICAgIH0sXG4gICAgZm9ybWF0ZWRUb2RheTogZnVuY3Rpb24gZm9ybWF0ZWRUb2RheSgpIHtcbiAgICAgIHJldHVybiBkYXRlX2RlZmF1bHQuYS5mb3JtYXQodGhpcy5ub3csICd5eXl5LU1NLWRkJyk7XG4gICAgfSxcblxuXG4gICAgcmVhbFNlbGVjdGVkRGF5OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSByZXR1cm4gdGhpcy5zZWxlY3RlZERheTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0ZWREYXRlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF5ID0gdmFsO1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHZhbCk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgZGF0ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRhdGU6IGZ1bmN0aW9uIGRhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhbFNlbGVjdGVkRGF5KSB7XG4gICAgICAgICAgdmFyIGQgPSB0aGlzLnNlbGVjdGVkRGF5LnNwbGl0KCctJyk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRbMF0sIGRbMV0gLSAxLCBkWzJdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbGlkYXRlZFJhbmdlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlZFJhbmdlWzBdWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSh0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvLyBpZiByYW5nZSBpcyB2YWxpZCwgd2UgZ2V0IGEgdHdvLWRpZ2l0IGFycmF5XG4gICAgdmFsaWRhdGVkUmFuZ2U6IGZ1bmN0aW9uIHZhbGlkYXRlZFJhbmdlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHJhbmdlID0gdGhpcy5yYW5nZTtcbiAgICAgIGlmICghcmFuZ2UpIHJldHVybiBbXTtcbiAgICAgIHJhbmdlID0gcmFuZ2UucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCB2YWwsIGluZGV4KSB7XG4gICAgICAgIHZhciBkYXRlID0gX3RoaXMudG9EYXRlKHZhbCk7XG4gICAgICAgIGlmIChfdGhpcy5yYW5nZVZhbGlkYXRvcihkYXRlLCBpbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICBwcmV2ID0gcHJldi5jb25jYXQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9LCBbXSk7XG4gICAgICBpZiAocmFuZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhciBfcmFuZ2UgPSByYW5nZSxcbiAgICAgICAgICAgIHN0YXJ0ID0gX3JhbmdlWzBdLFxuICAgICAgICAgICAgZW5kID0gX3JhbmdlWzFdO1xuXG4gICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0VsZW1lbnRDYWxlbmRhcl1lbmQgdGltZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHN0YXJ0IHRpbWUnKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhcnQgdGltZSBhbmQgZW5kIHRpbWUgaW4gb25lIG1vbnRoXG4gICAgICAgIGlmIChPYmplY3QoZGF0ZV91dGlsX1tcInZhbGlkYXRlUmFuZ2VJbk9uZU1vbnRoXCJdKShzdGFydCwgZW5kKSkge1xuICAgICAgICAgIHJldHVybiBbW3N0YXJ0LCBlbmRdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICB2YXIgc3RhcnREYXkgPSBuZXcgRGF0ZShzdGFydC5nZXRGdWxsWWVhcigpLCBzdGFydC5nZXRNb250aCgpICsgMSwgMSk7XG4gICAgICAgIHZhciBsYXN0RGF5ID0gdGhpcy50b0RhdGUoc3RhcnREYXkuZ2V0VGltZSgpIC0gb25lRGF5KTtcbiAgICAgICAgaWYgKCFPYmplY3QoZGF0ZV91dGlsX1tcInZhbGlkYXRlUmFuZ2VJbk9uZU1vbnRoXCJdKShzdGFydERheSwgZW5kKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW0VsZW1lbnRDYWxlbmRhcl1zdGFydCB0aW1lIGFuZCBlbmQgdGltZSBpbnRlcnZhbCBtdXN0IG5vdCBleGNlZWQgdHdvIG1vbnRocycpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyDnrKzkuIDkuKrmnIjnmoTml7bpl7TojIPlm7RcbiAgICAgICAgZGF0YS5wdXNoKFtzdGFydCwgbGFzdERheV0pO1xuICAgICAgICAvLyDkuIvkuIDmnIjnmoTml7bpl7TojIPlm7TvvIzpnIDopoHorqHnrpfkuIDkuIvor6XmnIjnmoTnrKzkuIDkuKrlkajotbflp4vml6VcbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gdGhpcy5yZWFsRmlyc3REYXlPZldlZWs7XG4gICAgICAgIHZhciBuZXh0TW9udEZpcnN0RGF5ID0gc3RhcnREYXkuZ2V0RGF5KCk7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDA7XG4gICAgICAgIGlmIChuZXh0TW9udEZpcnN0RGF5ICE9PSBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICAgIGlmIChmaXJzdERheU9mV2VlayA9PT0gMCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSA3IC0gbmV4dE1vbnRGaXJzdERheTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSBmaXJzdERheU9mV2VlayAtIG5leHRNb250Rmlyc3REYXk7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IGludGVydmFsID4gMCA/IGludGVydmFsIDogNyArIGludGVydmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFydERheSA9IHRoaXMudG9EYXRlKHN0YXJ0RGF5LmdldFRpbWUoKSArIGludGVydmFsICogb25lRGF5KTtcbiAgICAgICAgaWYgKHN0YXJ0RGF5LmdldERhdGUoKSA8IGVuZC5nZXREYXRlKCkpIHtcbiAgICAgICAgICBkYXRhLnB1c2goW3N0YXJ0RGF5LCBlbmRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHJlYWxGaXJzdERheU9mV2VlazogZnVuY3Rpb24gcmVhbEZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgaWYgKHRoaXMuZmlyc3REYXlPZldlZWsgPCAxIHx8IHRoaXMuZmlyc3REYXlPZldlZWsgPiA2KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5maXJzdERheU9mV2Vlayk7XG4gICAgfVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNlbGVjdGVkRGF5OiAnJyxcbiAgICAgIG5vdzogbmV3IERhdGUoKVxuICAgIH07XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9jYWxlbmRhci9zcmMvbWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX21haW52dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAobWFpbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9jYWxlbmRhci9zcmMvbWFpbi52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBtYWluX2NvbXBvbmVudCA9IE9iamVjdChjb21wb25lbnROb3JtYWxpemVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShcbiAgc3JjX21haW52dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBtYWluX2FwaTsgfVxubWFpbl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInBhY2thZ2VzL2NhbGVuZGFyL3NyYy9tYWluLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtYWluID0gKG1haW5fY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9jYWxlbmRhci9pbmRleC5qc1xuXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5tYWluLmluc3RhbGwgPSBmdW5jdGlvbiAoVnVlKSB7XG4gIFZ1ZS5jb21wb25lbnQobWFpbi5uYW1lLCBtYWluKTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNhbGVuZGFyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAobWFpbik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/calendar.js\n")}}]);