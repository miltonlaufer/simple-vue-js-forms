(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{"./node_modules/element-ui/lib/tree.js":
/*!*********************************************!*\
  !*** ./node_modules/element-ui/lib/tree.js ***!
  \*********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 58);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n\n/***/ 18:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/checkbox */ \"./node_modules/element-ui/lib/checkbox.js\");\n\n/***/ }),\n\n/***/ 2:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/utils/dom */ \"./node_modules/element-ui/lib/utils/dom.js\");\n\n/***/ }),\n\n/***/ 20:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/locale */ \"./node_modules/element-ui/lib/locale/index.js\");\n\n/***/ }),\n\n/***/ 28:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/transitions/collapse-transition */ \"./node_modules/element-ui/lib/transitions/collapse-transition.js\");\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/utils/util */ \"./node_modules/element-ui/lib/utils/util.js\");\n\n/***/ }),\n\n/***/ 4:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/mixins/emitter */ \"./node_modules/element-ui/lib/mixins/emitter.js\");\n\n/***/ }),\n\n/***/ 58:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree.vue?vue&type=template&id=547575a6&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    {\n      staticClass: \"el-tree\",\n      class: {\n        \"el-tree--highlight-current\": _vm.highlightCurrent,\n        \"is-dragging\": !!_vm.dragState.draggingNode,\n        \"is-drop-not-allow\": !_vm.dragState.allowDrop,\n        \"is-drop-inner\": _vm.dragState.dropType === \"inner\"\n      },\n      attrs: { role: \"tree\" }\n    },\n    [\n      _vm._l(_vm.root.childNodes, function(child) {\n        return _c(\"el-tree-node\", {\n          key: _vm.getNodeKey(child),\n          attrs: {\n            node: child,\n            props: _vm.props,\n            \"render-after-expand\": _vm.renderAfterExpand,\n            \"show-checkbox\": _vm.showCheckbox,\n            \"render-content\": _vm.renderContent\n          },\n          on: { \"node-expand\": _vm.handleNodeExpand }\n        })\n      }),\n      _vm.isEmpty\n        ? _c(\"div\", { staticClass: \"el-tree__empty-block\" }, [\n            _c(\"span\", { staticClass: \"el-tree__empty-text\" }, [\n              _vm._v(_vm._s(_vm.emptyText))\n            ])\n          ])\n        : _vm._e(),\n      _c(\"div\", {\n        directives: [\n          {\n            name: \"show\",\n            rawName: \"v-show\",\n            value: _vm.dragState.showDropIndicator,\n            expression: \"dragState.showDropIndicator\"\n          }\n        ],\n        ref: \"dropIndicator\",\n        staticClass: \"el-tree__drop-indicator\"\n      })\n    ],\n    2\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/tree/src/tree.vue?vue&type=template&id=547575a6&\n\n// EXTERNAL MODULE: external \"element-ui/lib/utils/merge\"\nvar merge_ = __webpack_require__(9);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge_);\n\n// CONCATENATED MODULE: ./packages/tree/src/model/util.js\nvar NODE_KEY = '$treeNodeId';\n\nvar markNodeData = function markNodeData(node, data) {\n  if (!data || data[NODE_KEY]) return;\n  Object.defineProperty(data, NODE_KEY, {\n    value: node.id,\n    enumerable: false,\n    configurable: false,\n    writable: false\n  });\n};\n\nvar util_getNodeKey = function getNodeKey(key, data) {\n  if (!key) return data[NODE_KEY];\n  return data[key];\n};\n\nvar findNearestComponent = function findNearestComponent(element, componentName) {\n  var target = element;\n  while (target && target.tagName !== 'BODY') {\n    if (target.__vue__ && target.__vue__.$options.name === componentName) {\n      return target.__vue__;\n    }\n    target = target.parentNode;\n  }\n  return null;\n};\n// EXTERNAL MODULE: external \"element-ui/lib/utils/util\"\nvar util_ = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./packages/tree/src/model/node.js\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\n\nvar getChildState = function getChildState(node) {\n  var all = true;\n  var none = true;\n  var allWithoutDisable = true;\n  for (var i = 0, j = node.length; i < j; i++) {\n    var n = node[i];\n    if (n.checked !== true || n.indeterminate) {\n      all = false;\n      if (!n.disabled) {\n        allWithoutDisable = false;\n      }\n    }\n    if (n.checked !== false || n.indeterminate) {\n      none = false;\n    }\n  }\n\n  return { all: all, none: none, allWithoutDisable: allWithoutDisable, half: !all && !none };\n};\n\nvar reInitChecked = function reInitChecked(node) {\n  if (node.childNodes.length === 0) return;\n\n  var _getChildState = getChildState(node.childNodes),\n      all = _getChildState.all,\n      none = _getChildState.none,\n      half = _getChildState.half;\n\n  if (all) {\n    node.checked = true;\n    node.indeterminate = false;\n  } else if (half) {\n    node.checked = false;\n    node.indeterminate = true;\n  } else if (none) {\n    node.checked = false;\n    node.indeterminate = false;\n  }\n\n  var parent = node.parent;\n  if (!parent || parent.level === 0) return;\n\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent);\n  }\n};\n\nvar getPropertyFromData = function getPropertyFromData(node, prop) {\n  var props = node.store.props;\n  var data = node.data || {};\n  var config = props[prop];\n\n  if (typeof config === 'function') {\n    return config(data, node);\n  } else if (typeof config === 'string') {\n    return data[config];\n  } else if (typeof config === 'undefined') {\n    var dataProp = data[prop];\n    return dataProp === undefined ? '' : dataProp;\n  }\n};\n\nvar nodeIdSeed = 0;\n\nvar node_Node = function () {\n  function Node(options) {\n    _classCallCheck(this, Node);\n\n    this.id = nodeIdSeed++;\n    this.text = null;\n    this.checked = false;\n    this.indeterminate = false;\n    this.data = null;\n    this.expanded = false;\n    this.parent = null;\n    this.visible = true;\n    this.isCurrent = false;\n\n    for (var name in options) {\n      if (options.hasOwnProperty(name)) {\n        this[name] = options[name];\n      }\n    }\n\n    // internal\n    this.level = 0;\n    this.loaded = false;\n    this.childNodes = [];\n    this.loading = false;\n\n    if (this.parent) {\n      this.level = this.parent.level + 1;\n    }\n\n    var store = this.store;\n    if (!store) {\n      throw new Error('[Node]store is required!');\n    }\n    store.registerNode(this);\n\n    var props = store.props;\n    if (props && typeof props.isLeaf !== 'undefined') {\n      var isLeaf = getPropertyFromData(this, 'isLeaf');\n      if (typeof isLeaf === 'boolean') {\n        this.isLeafByUser = isLeaf;\n      }\n    }\n\n    if (store.lazy !== true && this.data) {\n      this.setData(this.data);\n\n      if (store.defaultExpandAll) {\n        this.expanded = true;\n      }\n    } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {\n      this.expand();\n    }\n    if (!Array.isArray(this.data)) {\n      markNodeData(this, this.data);\n    }\n    if (!this.data) return;\n    var defaultExpandedKeys = store.defaultExpandedKeys;\n    var key = store.key;\n    if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {\n      this.expand(null, store.autoExpandParent);\n    }\n\n    if (key && store.currentNodeKey !== undefined && this.key === store.currentNodeKey) {\n      store.currentNode = this;\n      store.currentNode.isCurrent = true;\n    }\n\n    if (store.lazy) {\n      store._initDefaultCheckedNode(this);\n    }\n\n    this.updateLeafState();\n  }\n\n  Node.prototype.setData = function setData(data) {\n    if (!Array.isArray(data)) {\n      markNodeData(this, data);\n    }\n\n    this.data = data;\n    this.childNodes = [];\n\n    var children = void 0;\n    if (this.level === 0 && this.data instanceof Array) {\n      children = this.data;\n    } else {\n      children = getPropertyFromData(this, 'children') || [];\n    }\n\n    for (var i = 0, j = children.length; i < j; i++) {\n      this.insertChild({ data: children[i] });\n    }\n  };\n\n  Node.prototype.contains = function contains(target) {\n    var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var walk = function walk(parent) {\n      var children = parent.childNodes || [];\n      var result = false;\n      for (var i = 0, j = children.length; i < j; i++) {\n        var child = children[i];\n        if (child === target || deep && walk(child)) {\n          result = true;\n          break;\n        }\n      }\n      return result;\n    };\n\n    return walk(this);\n  };\n\n  Node.prototype.remove = function remove() {\n    var parent = this.parent;\n    if (parent) {\n      parent.removeChild(this);\n    }\n  };\n\n  Node.prototype.insertChild = function insertChild(child, index, batch) {\n    if (!child) throw new Error('insertChild error: child is required.');\n\n    if (!(child instanceof Node)) {\n      if (!batch) {\n        var children = this.getChildren(true);\n        if (children.indexOf(child.data) === -1) {\n          if (typeof index === 'undefined' || index < 0) {\n            children.push(child.data);\n          } else {\n            children.splice(index, 0, child.data);\n          }\n        }\n      }\n      merge_default()(child, {\n        parent: this,\n        store: this.store\n      });\n      child = new Node(child);\n    }\n\n    child.level = this.level + 1;\n\n    if (typeof index === 'undefined' || index < 0) {\n      this.childNodes.push(child);\n    } else {\n      this.childNodes.splice(index, 0, child);\n    }\n\n    this.updateLeafState();\n  };\n\n  Node.prototype.insertBefore = function insertBefore(child, ref) {\n    var index = void 0;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n    }\n    this.insertChild(child, index);\n  };\n\n  Node.prototype.insertAfter = function insertAfter(child, ref) {\n    var index = void 0;\n    if (ref) {\n      index = this.childNodes.indexOf(ref);\n      if (index !== -1) index += 1;\n    }\n    this.insertChild(child, index);\n  };\n\n  Node.prototype.removeChild = function removeChild(child) {\n    var children = this.getChildren() || [];\n    var dataIndex = children.indexOf(child.data);\n    if (dataIndex > -1) {\n      children.splice(dataIndex, 1);\n    }\n\n    var index = this.childNodes.indexOf(child);\n\n    if (index > -1) {\n      this.store && this.store.deregisterNode(child);\n      child.parent = null;\n      this.childNodes.splice(index, 1);\n    }\n\n    this.updateLeafState();\n  };\n\n  Node.prototype.removeChildByData = function removeChildByData(data) {\n    var targetNode = null;\n\n    for (var i = 0; i < this.childNodes.length; i++) {\n      if (this.childNodes[i].data === data) {\n        targetNode = this.childNodes[i];\n        break;\n      }\n    }\n\n    if (targetNode) {\n      this.removeChild(targetNode);\n    }\n  };\n\n  Node.prototype.expand = function expand(callback, expandParent) {\n    var _this = this;\n\n    var done = function done() {\n      if (expandParent) {\n        var parent = _this.parent;\n        while (parent.level > 0) {\n          parent.expanded = true;\n          parent = parent.parent;\n        }\n      }\n      _this.expanded = true;\n      if (callback) callback();\n    };\n\n    if (this.shouldLoadData()) {\n      this.loadData(function (data) {\n        if (data instanceof Array) {\n          if (_this.checked) {\n            _this.setChecked(true, true);\n          } else if (!_this.store.checkStrictly) {\n            reInitChecked(_this);\n          }\n          done();\n        }\n      });\n    } else {\n      done();\n    }\n  };\n\n  Node.prototype.doCreateChildren = function doCreateChildren(array) {\n    var _this2 = this;\n\n    var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    array.forEach(function (item) {\n      _this2.insertChild(merge_default()({ data: item }, defaultProps), undefined, true);\n    });\n  };\n\n  Node.prototype.collapse = function collapse() {\n    this.expanded = false;\n  };\n\n  Node.prototype.shouldLoadData = function shouldLoadData() {\n    return this.store.lazy === true && this.store.load && !this.loaded;\n  };\n\n  Node.prototype.updateLeafState = function updateLeafState() {\n    if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== 'undefined') {\n      this.isLeaf = this.isLeafByUser;\n      return;\n    }\n    var childNodes = this.childNodes;\n    if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {\n      this.isLeaf = !childNodes || childNodes.length === 0;\n      return;\n    }\n    this.isLeaf = false;\n  };\n\n  Node.prototype.setChecked = function setChecked(value, deep, recursion, passValue) {\n    var _this3 = this;\n\n    this.indeterminate = value === 'half';\n    this.checked = value === true;\n\n    if (this.store.checkStrictly) return;\n\n    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n      var _getChildState2 = getChildState(this.childNodes),\n          all = _getChildState2.all,\n          allWithoutDisable = _getChildState2.allWithoutDisable;\n\n      if (!this.isLeaf && !all && allWithoutDisable) {\n        this.checked = false;\n        value = false;\n      }\n\n      var handleDescendants = function handleDescendants() {\n        if (deep) {\n          var childNodes = _this3.childNodes;\n          for (var i = 0, j = childNodes.length; i < j; i++) {\n            var child = childNodes[i];\n            passValue = passValue || value !== false;\n            var isCheck = child.disabled ? child.checked : passValue;\n            child.setChecked(isCheck, deep, true, passValue);\n          }\n\n          var _getChildState3 = getChildState(childNodes),\n              half = _getChildState3.half,\n              _all = _getChildState3.all;\n\n          if (!_all) {\n            _this3.checked = _all;\n            _this3.indeterminate = half;\n          }\n        }\n      };\n\n      if (this.shouldLoadData()) {\n        // Only work on lazy load data.\n        this.loadData(function () {\n          handleDescendants();\n          reInitChecked(_this3);\n        }, {\n          checked: value !== false\n        });\n        return;\n      } else {\n        handleDescendants();\n      }\n    }\n\n    var parent = this.parent;\n    if (!parent || parent.level === 0) return;\n\n    if (!recursion) {\n      reInitChecked(parent);\n    }\n  };\n\n  Node.prototype.getChildren = function getChildren() {\n    var forceInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    // this is data\n    if (this.level === 0) return this.data;\n    var data = this.data;\n    if (!data) return null;\n\n    var props = this.store.props;\n    var children = 'children';\n    if (props) {\n      children = props.children || 'children';\n    }\n\n    if (data[children] === undefined) {\n      data[children] = null;\n    }\n\n    if (forceInit && !data[children]) {\n      data[children] = [];\n    }\n\n    return data[children];\n  };\n\n  Node.prototype.updateChildren = function updateChildren() {\n    var _this4 = this;\n\n    var newData = this.getChildren() || [];\n    var oldData = this.childNodes.map(function (node) {\n      return node.data;\n    });\n\n    var newDataMap = {};\n    var newNodes = [];\n\n    newData.forEach(function (item, index) {\n      var key = item[NODE_KEY];\n      var isNodeExists = !!key && Object(util_[\"arrayFindIndex\"])(oldData, function (data) {\n        return data[NODE_KEY] === key;\n      }) >= 0;\n      if (isNodeExists) {\n        newDataMap[key] = { index: index, data: item };\n      } else {\n        newNodes.push({ index: index, data: item });\n      }\n    });\n\n    if (!this.store.lazy) {\n      oldData.forEach(function (item) {\n        if (!newDataMap[item[NODE_KEY]]) _this4.removeChildByData(item);\n      });\n    }\n\n    newNodes.forEach(function (_ref) {\n      var index = _ref.index,\n          data = _ref.data;\n\n      _this4.insertChild({ data: data }, index);\n    });\n\n    this.updateLeafState();\n  };\n\n  Node.prototype.loadData = function loadData(callback) {\n    var _this5 = this;\n\n    var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {\n      this.loading = true;\n\n      var resolve = function resolve(children) {\n        _this5.loaded = true;\n        _this5.loading = false;\n        _this5.childNodes = [];\n\n        _this5.doCreateChildren(children, defaultProps);\n\n        _this5.updateLeafState();\n        if (callback) {\n          callback.call(_this5, children);\n        }\n      };\n\n      this.store.load(this, resolve);\n    } else {\n      if (callback) {\n        callback.call(this);\n      }\n    }\n  };\n\n  _createClass(Node, [{\n    key: 'label',\n    get: function get() {\n      return getPropertyFromData(this, 'label');\n    }\n  }, {\n    key: 'key',\n    get: function get() {\n      var nodeKey = this.store.key;\n      if (this.data) return this.data[nodeKey];\n      return null;\n    }\n  }, {\n    key: 'disabled',\n    get: function get() {\n      return getPropertyFromData(this, 'disabled');\n    }\n  }, {\n    key: 'nextSibling',\n    get: function get() {\n      var parent = this.parent;\n      if (parent) {\n        var index = parent.childNodes.indexOf(this);\n        if (index > -1) {\n          return parent.childNodes[index + 1];\n        }\n      }\n      return null;\n    }\n  }, {\n    key: 'previousSibling',\n    get: function get() {\n      var parent = this.parent;\n      if (parent) {\n        var index = parent.childNodes.indexOf(this);\n        if (index > -1) {\n          return index > 0 ? parent.childNodes[index - 1] : null;\n        }\n      }\n      return null;\n    }\n  }]);\n\n  return Node;\n}();\n\n/* harmony default export */ var model_node = (node_Node);\n// CONCATENATED MODULE: ./packages/tree/src/model/tree-store.js\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction tree_store_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar tree_store_TreeStore = function () {\n  function TreeStore(options) {\n    var _this = this;\n\n    tree_store_classCallCheck(this, TreeStore);\n\n    this.currentNode = null;\n    this.currentNodeKey = null;\n\n    for (var option in options) {\n      if (options.hasOwnProperty(option)) {\n        this[option] = options[option];\n      }\n    }\n\n    this.nodesMap = {};\n\n    this.root = new model_node({\n      data: this.data,\n      store: this\n    });\n\n    if (this.lazy && this.load) {\n      var loadFn = this.load;\n      loadFn(this.root, function (data) {\n        _this.root.doCreateChildren(data);\n        _this._initDefaultCheckedNodes();\n      });\n    } else {\n      this._initDefaultCheckedNodes();\n    }\n  }\n\n  TreeStore.prototype.filter = function filter(value) {\n    var filterNodeMethod = this.filterNodeMethod;\n    var lazy = this.lazy;\n    var traverse = function traverse(node) {\n      var childNodes = node.root ? node.root.childNodes : node.childNodes;\n\n      childNodes.forEach(function (child) {\n        child.visible = filterNodeMethod.call(child, value, child.data, child);\n\n        traverse(child);\n      });\n\n      if (!node.visible && childNodes.length) {\n        var allHidden = true;\n        allHidden = !childNodes.some(function (child) {\n          return child.visible;\n        });\n\n        if (node.root) {\n          node.root.visible = allHidden === false;\n        } else {\n          node.visible = allHidden === false;\n        }\n      }\n      if (!value) return;\n\n      if (node.visible && !node.isLeaf && !lazy) node.expand();\n    };\n\n    traverse(this);\n  };\n\n  TreeStore.prototype.setData = function setData(newVal) {\n    var instanceChanged = newVal !== this.root.data;\n    if (instanceChanged) {\n      this.root.setData(newVal);\n      this._initDefaultCheckedNodes();\n    } else {\n      this.root.updateChildren();\n    }\n  };\n\n  TreeStore.prototype.getNode = function getNode(data) {\n    if (data instanceof model_node) return data;\n    var key = (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' ? data : util_getNodeKey(this.key, data);\n    return this.nodesMap[key] || null;\n  };\n\n  TreeStore.prototype.insertBefore = function insertBefore(data, refData) {\n    var refNode = this.getNode(refData);\n    refNode.parent.insertBefore({ data: data }, refNode);\n  };\n\n  TreeStore.prototype.insertAfter = function insertAfter(data, refData) {\n    var refNode = this.getNode(refData);\n    refNode.parent.insertAfter({ data: data }, refNode);\n  };\n\n  TreeStore.prototype.remove = function remove(data) {\n    var node = this.getNode(data);\n\n    if (node && node.parent) {\n      if (node === this.currentNode) {\n        this.currentNode = null;\n      }\n      node.parent.removeChild(node);\n    }\n  };\n\n  TreeStore.prototype.append = function append(data, parentData) {\n    var parentNode = parentData ? this.getNode(parentData) : this.root;\n\n    if (parentNode) {\n      parentNode.insertChild({ data: data });\n    }\n  };\n\n  TreeStore.prototype._initDefaultCheckedNodes = function _initDefaultCheckedNodes() {\n    var _this2 = this;\n\n    var defaultCheckedKeys = this.defaultCheckedKeys || [];\n    var nodesMap = this.nodesMap;\n\n    defaultCheckedKeys.forEach(function (checkedKey) {\n      var node = nodesMap[checkedKey];\n\n      if (node) {\n        node.setChecked(true, !_this2.checkStrictly);\n      }\n    });\n  };\n\n  TreeStore.prototype._initDefaultCheckedNode = function _initDefaultCheckedNode(node) {\n    var defaultCheckedKeys = this.defaultCheckedKeys || [];\n\n    if (defaultCheckedKeys.indexOf(node.key) !== -1) {\n      node.setChecked(true, !this.checkStrictly);\n    }\n  };\n\n  TreeStore.prototype.setDefaultCheckedKey = function setDefaultCheckedKey(newVal) {\n    if (newVal !== this.defaultCheckedKeys) {\n      this.defaultCheckedKeys = newVal;\n      this._initDefaultCheckedNodes();\n    }\n  };\n\n  TreeStore.prototype.registerNode = function registerNode(node) {\n    var key = this.key;\n    if (!key || !node || !node.data) return;\n\n    var nodeKey = node.key;\n    if (nodeKey !== undefined) this.nodesMap[node.key] = node;\n  };\n\n  TreeStore.prototype.deregisterNode = function deregisterNode(node) {\n    var _this3 = this;\n\n    var key = this.key;\n    if (!key || !node || !node.data) return;\n\n    node.childNodes.forEach(function (child) {\n      _this3.deregisterNode(child);\n    });\n\n    delete this.nodesMap[node.key];\n  };\n\n  TreeStore.prototype.getCheckedNodes = function getCheckedNodes() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var includeHalfChecked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var checkedNodes = [];\n    var traverse = function traverse(node) {\n      var childNodes = node.root ? node.root.childNodes : node.childNodes;\n\n      childNodes.forEach(function (child) {\n        if ((child.checked || includeHalfChecked && child.indeterminate) && (!leafOnly || leafOnly && child.isLeaf)) {\n          checkedNodes.push(child.data);\n        }\n\n        traverse(child);\n      });\n    };\n\n    traverse(this);\n\n    return checkedNodes;\n  };\n\n  TreeStore.prototype.getCheckedKeys = function getCheckedKeys() {\n    var _this4 = this;\n\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    return this.getCheckedNodes(leafOnly).map(function (data) {\n      return (data || {})[_this4.key];\n    });\n  };\n\n  TreeStore.prototype.getHalfCheckedNodes = function getHalfCheckedNodes() {\n    var nodes = [];\n    var traverse = function traverse(node) {\n      var childNodes = node.root ? node.root.childNodes : node.childNodes;\n\n      childNodes.forEach(function (child) {\n        if (child.indeterminate) {\n          nodes.push(child.data);\n        }\n\n        traverse(child);\n      });\n    };\n\n    traverse(this);\n\n    return nodes;\n  };\n\n  TreeStore.prototype.getHalfCheckedKeys = function getHalfCheckedKeys() {\n    var _this5 = this;\n\n    return this.getHalfCheckedNodes().map(function (data) {\n      return (data || {})[_this5.key];\n    });\n  };\n\n  TreeStore.prototype._getAllNodes = function _getAllNodes() {\n    var allNodes = [];\n    var nodesMap = this.nodesMap;\n    for (var nodeKey in nodesMap) {\n      if (nodesMap.hasOwnProperty(nodeKey)) {\n        allNodes.push(nodesMap[nodeKey]);\n      }\n    }\n\n    return allNodes;\n  };\n\n  TreeStore.prototype.updateChildren = function updateChildren(key, data) {\n    var node = this.nodesMap[key];\n    if (!node) return;\n    var childNodes = node.childNodes;\n    for (var i = childNodes.length - 1; i >= 0; i--) {\n      var child = childNodes[i];\n      this.remove(child.data);\n    }\n    for (var _i = 0, j = data.length; _i < j; _i++) {\n      var _child = data[_i];\n      this.append(_child, node.data);\n    }\n  };\n\n  TreeStore.prototype._setCheckedKeys = function _setCheckedKeys(key) {\n    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var checkedKeys = arguments[2];\n\n    var allNodes = this._getAllNodes().sort(function (a, b) {\n      return b.level - a.level;\n    });\n    var cache = Object.create(null);\n    var keys = Object.keys(checkedKeys);\n    allNodes.forEach(function (node) {\n      return node.setChecked(false, false);\n    });\n    for (var i = 0, j = allNodes.length; i < j; i++) {\n      var node = allNodes[i];\n      var nodeKey = node.data[key].toString();\n      var checked = keys.indexOf(nodeKey) > -1;\n      if (!checked) {\n        if (node.checked && !cache[nodeKey]) {\n          node.setChecked(false, false);\n        }\n        continue;\n      }\n\n      var parent = node.parent;\n      while (parent && parent.level > 0) {\n        cache[parent.data[key]] = true;\n        parent = parent.parent;\n      }\n\n      if (node.isLeaf || this.checkStrictly) {\n        node.setChecked(true, false);\n        continue;\n      }\n      node.setChecked(true, true);\n\n      if (leafOnly) {\n        (function () {\n          node.setChecked(false, false);\n          var traverse = function traverse(node) {\n            var childNodes = node.childNodes;\n            childNodes.forEach(function (child) {\n              if (!child.isLeaf) {\n                child.setChecked(false, false);\n              }\n              traverse(child);\n            });\n          };\n          traverse(node);\n        })();\n      }\n    }\n  };\n\n  TreeStore.prototype.setCheckedNodes = function setCheckedNodes(array) {\n    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var key = this.key;\n    var checkedKeys = {};\n    array.forEach(function (item) {\n      checkedKeys[(item || {})[key]] = true;\n    });\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  };\n\n  TreeStore.prototype.setCheckedKeys = function setCheckedKeys(keys) {\n    var leafOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    this.defaultCheckedKeys = keys;\n    var key = this.key;\n    var checkedKeys = {};\n    keys.forEach(function (key) {\n      checkedKeys[key] = true;\n    });\n\n    this._setCheckedKeys(key, leafOnly, checkedKeys);\n  };\n\n  TreeStore.prototype.setDefaultExpandedKeys = function setDefaultExpandedKeys(keys) {\n    var _this6 = this;\n\n    keys = keys || [];\n    this.defaultExpandedKeys = keys;\n\n    keys.forEach(function (key) {\n      var node = _this6.getNode(key);\n      if (node) node.expand(null, _this6.autoExpandParent);\n    });\n  };\n\n  TreeStore.prototype.setChecked = function setChecked(data, checked, deep) {\n    var node = this.getNode(data);\n\n    if (node) {\n      node.setChecked(!!checked, deep);\n    }\n  };\n\n  TreeStore.prototype.getCurrentNode = function getCurrentNode() {\n    return this.currentNode;\n  };\n\n  TreeStore.prototype.setCurrentNode = function setCurrentNode(currentNode) {\n    var prevCurrentNode = this.currentNode;\n    if (prevCurrentNode) {\n      prevCurrentNode.isCurrent = false;\n    }\n    this.currentNode = currentNode;\n    this.currentNode.isCurrent = true;\n  };\n\n  TreeStore.prototype.setUserCurrentNode = function setUserCurrentNode(node) {\n    var key = node[this.key];\n    var currNode = this.nodesMap[key];\n    this.setCurrentNode(currNode);\n  };\n\n  TreeStore.prototype.setCurrentNodeKey = function setCurrentNodeKey(key) {\n    if (key === null || key === undefined) {\n      this.currentNode && (this.currentNode.isCurrent = false);\n      this.currentNode = null;\n      return;\n    }\n    var node = this.getNode(key);\n    if (node) {\n      this.setCurrentNode(node);\n    }\n  };\n\n  return TreeStore;\n}();\n\n/* harmony default export */ var tree_store = (tree_store_TreeStore);\n;\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree-node.vue?vue&type=template&id=3ba3ef0e&\nvar tree_nodevue_type_template_id_3ba3ef0e_render = function() {\n  var this$1 = this\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    {\n      directives: [\n        {\n          name: \"show\",\n          rawName: \"v-show\",\n          value: _vm.node.visible,\n          expression: \"node.visible\"\n        }\n      ],\n      ref: \"node\",\n      staticClass: \"el-tree-node\",\n      class: {\n        \"is-expanded\": _vm.expanded,\n        \"is-current\": _vm.node.isCurrent,\n        \"is-hidden\": !_vm.node.visible,\n        \"is-focusable\": !_vm.node.disabled,\n        \"is-checked\": !_vm.node.disabled && _vm.node.checked\n      },\n      attrs: {\n        role: \"treeitem\",\n        tabindex: \"-1\",\n        \"aria-expanded\": _vm.expanded,\n        \"aria-disabled\": _vm.node.disabled,\n        \"aria-checked\": _vm.node.checked,\n        draggable: _vm.tree.draggable\n      },\n      on: {\n        click: function($event) {\n          $event.stopPropagation()\n          return _vm.handleClick($event)\n        },\n        contextmenu: function($event) {\n          return this$1.handleContextMenu($event)\n        },\n        dragstart: function($event) {\n          $event.stopPropagation()\n          return _vm.handleDragStart($event)\n        },\n        dragover: function($event) {\n          $event.stopPropagation()\n          return _vm.handleDragOver($event)\n        },\n        dragend: function($event) {\n          $event.stopPropagation()\n          return _vm.handleDragEnd($event)\n        },\n        drop: function($event) {\n          $event.stopPropagation()\n          return _vm.handleDrop($event)\n        }\n      }\n    },\n    [\n      _c(\n        \"div\",\n        {\n          staticClass: \"el-tree-node__content\",\n          style: {\n            \"padding-left\": (_vm.node.level - 1) * _vm.tree.indent + \"px\"\n          }\n        },\n        [\n          _c(\"span\", {\n            class: [\n              {\n                \"is-leaf\": _vm.node.isLeaf,\n                expanded: !_vm.node.isLeaf && _vm.expanded\n              },\n              \"el-tree-node__expand-icon\",\n              _vm.tree.iconClass ? _vm.tree.iconClass : \"el-icon-caret-right\"\n            ],\n            on: {\n              click: function($event) {\n                $event.stopPropagation()\n                return _vm.handleExpandIconClick($event)\n              }\n            }\n          }),\n          _vm.showCheckbox\n            ? _c(\"el-checkbox\", {\n                attrs: {\n                  indeterminate: _vm.node.indeterminate,\n                  disabled: !!_vm.node.disabled\n                },\n                on: { change: _vm.handleCheckChange },\n                nativeOn: {\n                  click: function($event) {\n                    $event.stopPropagation()\n                  }\n                },\n                model: {\n                  value: _vm.node.checked,\n                  callback: function($$v) {\n                    _vm.$set(_vm.node, \"checked\", $$v)\n                  },\n                  expression: \"node.checked\"\n                }\n              })\n            : _vm._e(),\n          _vm.node.loading\n            ? _c(\"span\", {\n                staticClass: \"el-tree-node__loading-icon el-icon-loading\"\n              })\n            : _vm._e(),\n          _c(\"node-content\", { attrs: { node: _vm.node } })\n        ],\n        1\n      ),\n      _c(\"el-collapse-transition\", [\n        !_vm.renderAfterExpand || _vm.childNodeRendered\n          ? _c(\n              \"div\",\n              {\n                directives: [\n                  {\n                    name: \"show\",\n                    rawName: \"v-show\",\n                    value: _vm.expanded,\n                    expression: \"expanded\"\n                  }\n                ],\n                staticClass: \"el-tree-node__children\",\n                attrs: { role: \"group\", \"aria-expanded\": _vm.expanded }\n              },\n              _vm._l(_vm.node.childNodes, function(child) {\n                return _c(\"el-tree-node\", {\n                  key: _vm.getNodeKey(child),\n                  attrs: {\n                    \"render-content\": _vm.renderContent,\n                    \"render-after-expand\": _vm.renderAfterExpand,\n                    \"show-checkbox\": _vm.showCheckbox,\n                    node: child\n                  },\n                  on: { \"node-expand\": _vm.handleChildNodeExpand }\n                })\n              }),\n              1\n            )\n          : _vm._e()\n      ])\n    ],\n    1\n  )\n}\nvar tree_nodevue_type_template_id_3ba3ef0e_staticRenderFns = []\ntree_nodevue_type_template_id_3ba3ef0e_render._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/tree/src/tree-node.vue?vue&type=template&id=3ba3ef0e&\n\n// EXTERNAL MODULE: external \"element-ui/lib/transitions/collapse-transition\"\nvar collapse_transition_ = __webpack_require__(28);\nvar collapse_transition_default = /*#__PURE__*/__webpack_require__.n(collapse_transition_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/checkbox\"\nvar checkbox_ = __webpack_require__(18);\nvar checkbox_default = /*#__PURE__*/__webpack_require__.n(checkbox_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/mixins/emitter\"\nvar emitter_ = __webpack_require__(4);\nvar emitter_default = /*#__PURE__*/__webpack_require__.n(emitter_);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree-node.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n/* harmony default export */ var tree_nodevue_type_script_lang_js_ = ({\n  name: 'ElTreeNode',\n\n  componentName: 'ElTreeNode',\n\n  mixins: [emitter_default.a],\n\n  props: {\n    node: {\n      default: function _default() {\n        return {};\n      }\n    },\n    props: {},\n    renderContent: Function,\n    renderAfterExpand: {\n      type: Boolean,\n      default: true\n    },\n    showCheckbox: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  components: {\n    ElCollapseTransition: collapse_transition_default.a,\n    ElCheckbox: checkbox_default.a,\n    NodeContent: {\n      props: {\n        node: {\n          required: true\n        }\n      },\n      render: function render(h) {\n        var parent = this.$parent;\n        var tree = parent.tree;\n        var node = this.node;\n        var data = node.data,\n            store = node.store;\n\n        return parent.renderContent ? parent.renderContent.call(parent._renderProxy, h, { _self: tree.$vnode.context, node: node, data: data, store: store }) : tree.$scopedSlots.default ? tree.$scopedSlots.default({ node: node, data: data }) : h(\n          'span',\n          { 'class': 'el-tree-node__label' },\n          [node.label]\n        );\n      }\n    }\n  },\n\n  data: function data() {\n    return {\n      tree: null,\n      expanded: false,\n      childNodeRendered: false,\n      oldChecked: null,\n      oldIndeterminate: null\n    };\n  },\n\n\n  watch: {\n    'node.indeterminate': function nodeIndeterminate(val) {\n      this.handleSelectChange(this.node.checked, val);\n    },\n    'node.checked': function nodeChecked(val) {\n      this.handleSelectChange(val, this.node.indeterminate);\n    },\n    'node.expanded': function nodeExpanded(val) {\n      var _this = this;\n\n      this.$nextTick(function () {\n        return _this.expanded = val;\n      });\n      if (val) {\n        this.childNodeRendered = true;\n      }\n    }\n  },\n\n  methods: {\n    getNodeKey: function getNodeKey(node) {\n      return util_getNodeKey(this.tree.nodeKey, node.data);\n    },\n    handleSelectChange: function handleSelectChange(checked, indeterminate) {\n      if (this.oldChecked !== checked && this.oldIndeterminate !== indeterminate) {\n        this.tree.$emit('check-change', this.node.data, checked, indeterminate);\n      }\n      this.oldChecked = checked;\n      this.indeterminate = indeterminate;\n    },\n    handleClick: function handleClick() {\n      var store = this.tree.store;\n      store.setCurrentNode(this.node);\n      this.tree.$emit('current-change', store.currentNode ? store.currentNode.data : null, store.currentNode);\n      this.tree.currentNode = this;\n      if (this.tree.expandOnClickNode) {\n        this.handleExpandIconClick();\n      }\n      if (this.tree.checkOnClickNode && !this.node.disabled) {\n        this.handleCheckChange(null, {\n          target: { checked: !this.node.checked }\n        });\n      }\n      this.tree.$emit('node-click', this.node.data, this.node, this);\n    },\n    handleContextMenu: function handleContextMenu(event) {\n      if (this.tree._events['node-contextmenu'] && this.tree._events['node-contextmenu'].length > 0) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n      this.tree.$emit('node-contextmenu', event, this.node.data, this.node, this);\n    },\n    handleExpandIconClick: function handleExpandIconClick() {\n      if (this.node.isLeaf) return;\n      if (this.expanded) {\n        this.tree.$emit('node-collapse', this.node.data, this.node, this);\n        this.node.collapse();\n      } else {\n        this.node.expand();\n        this.$emit('node-expand', this.node.data, this.node, this);\n      }\n    },\n    handleCheckChange: function handleCheckChange(value, ev) {\n      var _this2 = this;\n\n      this.node.setChecked(ev.target.checked, !this.tree.checkStrictly);\n      this.$nextTick(function () {\n        var store = _this2.tree.store;\n        _this2.tree.$emit('check', _this2.node.data, {\n          checkedNodes: store.getCheckedNodes(),\n          checkedKeys: store.getCheckedKeys(),\n          halfCheckedNodes: store.getHalfCheckedNodes(),\n          halfCheckedKeys: store.getHalfCheckedKeys()\n        });\n      });\n    },\n    handleChildNodeExpand: function handleChildNodeExpand(nodeData, node, instance) {\n      this.broadcast('ElTreeNode', 'tree-node-expand', node);\n      this.tree.$emit('node-expand', nodeData, node, instance);\n    },\n    handleDragStart: function handleDragStart(event) {\n      if (!this.tree.draggable) return;\n      this.tree.$emit('tree-node-drag-start', event, this);\n    },\n    handleDragOver: function handleDragOver(event) {\n      if (!this.tree.draggable) return;\n      this.tree.$emit('tree-node-drag-over', event, this);\n      event.preventDefault();\n    },\n    handleDrop: function handleDrop(event) {\n      event.preventDefault();\n    },\n    handleDragEnd: function handleDragEnd(event) {\n      if (!this.tree.draggable) return;\n      this.tree.$emit('tree-node-drag-end', event, this);\n    }\n  },\n\n  created: function created() {\n    var _this3 = this;\n\n    var parent = this.$parent;\n\n    if (parent.isTree) {\n      this.tree = parent;\n    } else {\n      this.tree = parent.tree;\n    }\n\n    var tree = this.tree;\n    if (!tree) {\n      console.warn('Can not find node\\'s tree.');\n    }\n\n    var props = tree.props || {};\n    var childrenKey = props['children'] || 'children';\n\n    this.$watch('node.data.' + childrenKey, function () {\n      _this3.node.updateChildren();\n    });\n\n    if (this.node.expanded) {\n      this.expanded = true;\n      this.childNodeRendered = true;\n    }\n\n    if (this.tree.accordion) {\n      this.$on('tree-node-expand', function (node) {\n        if (_this3.node !== node) {\n          _this3.node.collapse();\n        }\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/tree/src/tree-node.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_tree_nodevue_type_script_lang_js_ = (tree_nodevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/tree/src/tree-node.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  src_tree_nodevue_type_script_lang_js_,\n  tree_nodevue_type_template_id_3ba3ef0e_render,\n  tree_nodevue_type_template_id_3ba3ef0e_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"packages/tree/src/tree-node.vue\"\n/* harmony default export */ var tree_node = (component.exports);\n// EXTERNAL MODULE: external \"element-ui/lib/locale\"\nvar locale_ = __webpack_require__(20);\n\n// EXTERNAL MODULE: external \"element-ui/lib/utils/dom\"\nvar dom_ = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tree/src/tree.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n/* harmony default export */ var treevue_type_script_lang_js_ = ({\n  name: 'ElTree',\n\n  mixins: [emitter_default.a],\n\n  components: {\n    ElTreeNode: tree_node\n  },\n\n  data: function data() {\n    return {\n      store: null,\n      root: null,\n      currentNode: null,\n      treeItems: null,\n      checkboxItems: [],\n      dragState: {\n        showDropIndicator: false,\n        draggingNode: null,\n        dropNode: null,\n        allowDrop: true\n      }\n    };\n  },\n\n\n  props: {\n    data: {\n      type: Array\n    },\n    emptyText: {\n      type: String,\n      default: function _default() {\n        return Object(locale_[\"t\"])('el.tree.emptyText');\n      }\n    },\n    renderAfterExpand: {\n      type: Boolean,\n      default: true\n    },\n    nodeKey: String,\n    checkStrictly: Boolean,\n    defaultExpandAll: Boolean,\n    expandOnClickNode: {\n      type: Boolean,\n      default: true\n    },\n    checkOnClickNode: Boolean,\n    checkDescendants: {\n      type: Boolean,\n      default: false\n    },\n    autoExpandParent: {\n      type: Boolean,\n      default: true\n    },\n    defaultCheckedKeys: Array,\n    defaultExpandedKeys: Array,\n    currentNodeKey: [String, Number],\n    renderContent: Function,\n    showCheckbox: {\n      type: Boolean,\n      default: false\n    },\n    draggable: {\n      type: Boolean,\n      default: false\n    },\n    allowDrag: Function,\n    allowDrop: Function,\n    props: {\n      default: function _default() {\n        return {\n          children: 'children',\n          label: 'label',\n          disabled: 'disabled'\n        };\n      }\n    },\n    lazy: {\n      type: Boolean,\n      default: false\n    },\n    highlightCurrent: Boolean,\n    load: Function,\n    filterNodeMethod: Function,\n    accordion: Boolean,\n    indent: {\n      type: Number,\n      default: 18\n    },\n    iconClass: String\n  },\n\n  computed: {\n    children: {\n      set: function set(value) {\n        this.data = value;\n      },\n      get: function get() {\n        return this.data;\n      }\n    },\n\n    treeItemArray: function treeItemArray() {\n      return Array.prototype.slice.call(this.treeItems);\n    },\n    isEmpty: function isEmpty() {\n      var childNodes = this.root.childNodes;\n\n      return !childNodes || childNodes.length === 0 || childNodes.every(function (_ref) {\n        var visible = _ref.visible;\n        return !visible;\n      });\n    }\n  },\n\n  watch: {\n    defaultCheckedKeys: function defaultCheckedKeys(newVal) {\n      this.store.setDefaultCheckedKey(newVal);\n    },\n    defaultExpandedKeys: function defaultExpandedKeys(newVal) {\n      this.store.defaultExpandedKeys = newVal;\n      this.store.setDefaultExpandedKeys(newVal);\n    },\n    data: function data(newVal) {\n      this.store.setData(newVal);\n    },\n    checkboxItems: function checkboxItems(val) {\n      Array.prototype.forEach.call(val, function (checkbox) {\n        checkbox.setAttribute('tabindex', -1);\n      });\n    },\n    checkStrictly: function checkStrictly(newVal) {\n      this.store.checkStrictly = newVal;\n    }\n  },\n\n  methods: {\n    filter: function filter(value) {\n      if (!this.filterNodeMethod) throw new Error('[Tree] filterNodeMethod is required when filter');\n      this.store.filter(value);\n    },\n    getNodeKey: function getNodeKey(node) {\n      return util_getNodeKey(this.nodeKey, node.data);\n    },\n    getNodePath: function getNodePath(data) {\n      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getNodePath');\n      var node = this.store.getNode(data);\n      if (!node) return [];\n      var path = [node.data];\n      var parent = node.parent;\n      while (parent && parent !== this.root) {\n        path.push(parent.data);\n        parent = parent.parent;\n      }\n      return path.reverse();\n    },\n    getCheckedNodes: function getCheckedNodes(leafOnly, includeHalfChecked) {\n      return this.store.getCheckedNodes(leafOnly, includeHalfChecked);\n    },\n    getCheckedKeys: function getCheckedKeys(leafOnly) {\n      return this.store.getCheckedKeys(leafOnly);\n    },\n    getCurrentNode: function getCurrentNode() {\n      var currentNode = this.store.getCurrentNode();\n      return currentNode ? currentNode.data : null;\n    },\n    getCurrentKey: function getCurrentKey() {\n      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in getCurrentKey');\n      var currentNode = this.getCurrentNode();\n      return currentNode ? currentNode[this.nodeKey] : null;\n    },\n    setCheckedNodes: function setCheckedNodes(nodes, leafOnly) {\n      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedNodes');\n      this.store.setCheckedNodes(nodes, leafOnly);\n    },\n    setCheckedKeys: function setCheckedKeys(keys, leafOnly) {\n      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCheckedKeys');\n      this.store.setCheckedKeys(keys, leafOnly);\n    },\n    setChecked: function setChecked(data, checked, deep) {\n      this.store.setChecked(data, checked, deep);\n    },\n    getHalfCheckedNodes: function getHalfCheckedNodes() {\n      return this.store.getHalfCheckedNodes();\n    },\n    getHalfCheckedKeys: function getHalfCheckedKeys() {\n      return this.store.getHalfCheckedKeys();\n    },\n    setCurrentNode: function setCurrentNode(node) {\n      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentNode');\n      this.store.setUserCurrentNode(node);\n    },\n    setCurrentKey: function setCurrentKey(key) {\n      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in setCurrentKey');\n      this.store.setCurrentNodeKey(key);\n    },\n    getNode: function getNode(data) {\n      return this.store.getNode(data);\n    },\n    remove: function remove(data) {\n      this.store.remove(data);\n    },\n    append: function append(data, parentNode) {\n      this.store.append(data, parentNode);\n    },\n    insertBefore: function insertBefore(data, refNode) {\n      this.store.insertBefore(data, refNode);\n    },\n    insertAfter: function insertAfter(data, refNode) {\n      this.store.insertAfter(data, refNode);\n    },\n    handleNodeExpand: function handleNodeExpand(nodeData, node, instance) {\n      this.broadcast('ElTreeNode', 'tree-node-expand', node);\n      this.$emit('node-expand', nodeData, node, instance);\n    },\n    updateKeyChildren: function updateKeyChildren(key, data) {\n      if (!this.nodeKey) throw new Error('[Tree] nodeKey is required in updateKeyChild');\n      this.store.updateChildren(key, data);\n    },\n    initTabIndex: function initTabIndex() {\n      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');\n      this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');\n      var checkedItem = this.$el.querySelectorAll('.is-checked[role=treeitem]');\n      if (checkedItem.length) {\n        checkedItem[0].setAttribute('tabindex', 0);\n        return;\n      }\n      this.treeItems[0] && this.treeItems[0].setAttribute('tabindex', 0);\n    },\n    handleKeydown: function handleKeydown(ev) {\n      var currentItem = ev.target;\n      if (currentItem.className.indexOf('el-tree-node') === -1) return;\n      var keyCode = ev.keyCode;\n      this.treeItems = this.$el.querySelectorAll('.is-focusable[role=treeitem]');\n      var currentIndex = this.treeItemArray.indexOf(currentItem);\n      var nextIndex = void 0;\n      if ([38, 40].indexOf(keyCode) > -1) {\n        // up、down\n        ev.preventDefault();\n        if (keyCode === 38) {\n          // up\n          nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;\n        } else {\n          nextIndex = currentIndex < this.treeItemArray.length - 1 ? currentIndex + 1 : 0;\n        }\n        this.treeItemArray[nextIndex].focus(); // 选中\n      }\n      if ([37, 39].indexOf(keyCode) > -1) {\n        // left、right 展开\n        ev.preventDefault();\n        currentItem.click(); // 选中\n      }\n      var hasInput = currentItem.querySelector('[type=\"checkbox\"]');\n      if ([13, 32].indexOf(keyCode) > -1 && hasInput) {\n        // space enter选中checkbox\n        ev.preventDefault();\n        hasInput.click();\n      }\n    }\n  },\n\n  created: function created() {\n    var _this = this;\n\n    this.isTree = true;\n\n    this.store = new tree_store({\n      key: this.nodeKey,\n      data: this.data,\n      lazy: this.lazy,\n      props: this.props,\n      load: this.load,\n      currentNodeKey: this.currentNodeKey,\n      checkStrictly: this.checkStrictly,\n      checkDescendants: this.checkDescendants,\n      defaultCheckedKeys: this.defaultCheckedKeys,\n      defaultExpandedKeys: this.defaultExpandedKeys,\n      autoExpandParent: this.autoExpandParent,\n      defaultExpandAll: this.defaultExpandAll,\n      filterNodeMethod: this.filterNodeMethod\n    });\n\n    this.root = this.store.root;\n\n    var dragState = this.dragState;\n    this.$on('tree-node-drag-start', function (event, treeNode) {\n      if (typeof _this.allowDrag === 'function' && !_this.allowDrag(treeNode.node)) {\n        event.preventDefault();\n        return false;\n      }\n      event.dataTransfer.effectAllowed = 'move';\n\n      // wrap in try catch to address IE's error when first param is 'text/plain'\n      try {\n        // setData is required for draggable to work in FireFox\n        // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox\n        event.dataTransfer.setData('text/plain', '');\n      } catch (e) {}\n      dragState.draggingNode = treeNode;\n      _this.$emit('node-drag-start', treeNode.node, event);\n    });\n\n    this.$on('tree-node-drag-over', function (event, treeNode) {\n      var dropNode = findNearestComponent(event.target, 'ElTreeNode');\n      var oldDropNode = dragState.dropNode;\n      if (oldDropNode && oldDropNode !== dropNode) {\n        Object(dom_[\"removeClass\"])(oldDropNode.$el, 'is-drop-inner');\n      }\n      var draggingNode = dragState.draggingNode;\n      if (!draggingNode || !dropNode) return;\n\n      var dropPrev = true;\n      var dropInner = true;\n      var dropNext = true;\n      var userAllowDropInner = true;\n      if (typeof _this.allowDrop === 'function') {\n        dropPrev = _this.allowDrop(draggingNode.node, dropNode.node, 'prev');\n        userAllowDropInner = dropInner = _this.allowDrop(draggingNode.node, dropNode.node, 'inner');\n        dropNext = _this.allowDrop(draggingNode.node, dropNode.node, 'next');\n      }\n      event.dataTransfer.dropEffect = dropInner ? 'move' : 'none';\n      if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {\n        if (oldDropNode) {\n          _this.$emit('node-drag-leave', draggingNode.node, oldDropNode.node, event);\n        }\n        _this.$emit('node-drag-enter', draggingNode.node, dropNode.node, event);\n      }\n\n      if (dropPrev || dropInner || dropNext) {\n        dragState.dropNode = dropNode;\n      }\n\n      if (dropNode.node.nextSibling === draggingNode.node) {\n        dropNext = false;\n      }\n      if (dropNode.node.previousSibling === draggingNode.node) {\n        dropPrev = false;\n      }\n      if (dropNode.node.contains(draggingNode.node, false)) {\n        dropInner = false;\n      }\n      if (draggingNode.node === dropNode.node || draggingNode.node.contains(dropNode.node)) {\n        dropPrev = false;\n        dropInner = false;\n        dropNext = false;\n      }\n\n      var targetPosition = dropNode.$el.getBoundingClientRect();\n      var treePosition = _this.$el.getBoundingClientRect();\n\n      var dropType = void 0;\n      var prevPercent = dropPrev ? dropInner ? 0.25 : dropNext ? 0.45 : 1 : -1;\n      var nextPercent = dropNext ? dropInner ? 0.75 : dropPrev ? 0.55 : 0 : 1;\n\n      var indicatorTop = -9999;\n      var distance = event.clientY - targetPosition.top;\n      if (distance < targetPosition.height * prevPercent) {\n        dropType = 'before';\n      } else if (distance > targetPosition.height * nextPercent) {\n        dropType = 'after';\n      } else if (dropInner) {\n        dropType = 'inner';\n      } else {\n        dropType = 'none';\n      }\n\n      var iconPosition = dropNode.$el.querySelector('.el-tree-node__expand-icon').getBoundingClientRect();\n      var dropIndicator = _this.$refs.dropIndicator;\n      if (dropType === 'before') {\n        indicatorTop = iconPosition.top - treePosition.top;\n      } else if (dropType === 'after') {\n        indicatorTop = iconPosition.bottom - treePosition.top;\n      }\n      dropIndicator.style.top = indicatorTop + 'px';\n      dropIndicator.style.left = iconPosition.right - treePosition.left + 'px';\n\n      if (dropType === 'inner') {\n        Object(dom_[\"addClass\"])(dropNode.$el, 'is-drop-inner');\n      } else {\n        Object(dom_[\"removeClass\"])(dropNode.$el, 'is-drop-inner');\n      }\n\n      dragState.showDropIndicator = dropType === 'before' || dropType === 'after';\n      dragState.allowDrop = dragState.showDropIndicator || userAllowDropInner;\n      dragState.dropType = dropType;\n      _this.$emit('node-drag-over', draggingNode.node, dropNode.node, event);\n    });\n\n    this.$on('tree-node-drag-end', function (event) {\n      var draggingNode = dragState.draggingNode,\n          dropType = dragState.dropType,\n          dropNode = dragState.dropNode;\n\n      event.preventDefault();\n      event.dataTransfer.dropEffect = 'move';\n\n      if (draggingNode && dropNode) {\n        var draggingNodeCopy = { data: draggingNode.node.data };\n        if (dropType !== 'none') {\n          draggingNode.node.remove();\n        }\n        if (dropType === 'before') {\n          dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);\n        } else if (dropType === 'after') {\n          dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);\n        } else if (dropType === 'inner') {\n          dropNode.node.insertChild(draggingNodeCopy);\n        }\n        if (dropType !== 'none') {\n          _this.store.registerNode(draggingNodeCopy);\n        }\n\n        Object(dom_[\"removeClass\"])(dropNode.$el, 'is-drop-inner');\n\n        _this.$emit('node-drag-end', draggingNode.node, dropNode.node, dropType, event);\n        if (dropType !== 'none') {\n          _this.$emit('node-drop', draggingNode.node, dropNode.node, dropType, event);\n        }\n      }\n      if (draggingNode && !dropNode) {\n        _this.$emit('node-drag-end', draggingNode.node, null, dropType, event);\n      }\n\n      dragState.showDropIndicator = false;\n      dragState.draggingNode = null;\n      dragState.dropNode = null;\n      dragState.allowDrop = true;\n    });\n  },\n  mounted: function mounted() {\n    this.initTabIndex();\n    this.$el.addEventListener('keydown', this.handleKeydown);\n  },\n  updated: function updated() {\n    this.treeItems = this.$el.querySelectorAll('[role=treeitem]');\n    this.checkboxItems = this.$el.querySelectorAll('input[type=checkbox]');\n  }\n});\n// CONCATENATED MODULE: ./packages/tree/src/tree.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_treevue_type_script_lang_js_ = (treevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/tree/src/tree.vue\n\n\n\n\n\n/* normalize component */\n\nvar tree_component = Object(componentNormalizer[\"a\" /* default */])(\n  src_treevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var tree_api; }\ntree_component.options.__file = \"packages/tree/src/tree.vue\"\n/* harmony default export */ var tree = (tree_component.exports);\n// CONCATENATED MODULE: ./packages/tree/index.js\n\n\n/* istanbul ignore next */\ntree.install = function (Vue) {\n  Vue.component(tree.name, tree);\n};\n\n/* harmony default export */ var packages_tree = __webpack_exports__[\"default\"] = (tree);\n\n/***/ }),\n\n/***/ 9:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! element-ui/lib/utils/merge */ \"./node_modules/element-ui/lib/utils/merge.js\");\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdHJlZS5qcz82NzIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkZBQTJGLDJCQUEyQixFQUFFO0FBQ3hIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFD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SDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDhHO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0c7QUFDQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLGdGQUE0Qjs7QUFFckQsT0FBTzs7QUFFUCxVQUFVIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3RyZWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDU4KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gMDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbGl6ZUNvbXBvbmVudDsgfSk7XG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvY2hlY2tib3hcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy9kb21cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvbG9jYWxlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjg6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL3RyYW5zaXRpb25zL2NvbGxhcHNlLXRyYW5zaXRpb25cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy91dGlsXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvbWl4aW5zL2VtaXR0ZXJcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1ODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvdHJlZS9zcmMvdHJlZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NTQ3NTc1YTYmXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdHJlZVwiLFxuICAgICAgY2xhc3M6IHtcbiAgICAgICAgXCJlbC10cmVlLS1oaWdobGlnaHQtY3VycmVudFwiOiBfdm0uaGlnaGxpZ2h0Q3VycmVudCxcbiAgICAgICAgXCJpcy1kcmFnZ2luZ1wiOiAhIV92bS5kcmFnU3RhdGUuZHJhZ2dpbmdOb2RlLFxuICAgICAgICBcImlzLWRyb3Atbm90LWFsbG93XCI6ICFfdm0uZHJhZ1N0YXRlLmFsbG93RHJvcCxcbiAgICAgICAgXCJpcy1kcm9wLWlubmVyXCI6IF92bS5kcmFnU3RhdGUuZHJvcFR5cGUgPT09IFwiaW5uZXJcIlxuICAgICAgfSxcbiAgICAgIGF0dHJzOiB7IHJvbGU6IFwidHJlZVwiIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF92bS5fbChfdm0ucm9vdC5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICByZXR1cm4gX2MoXCJlbC10cmVlLW5vZGVcIiwge1xuICAgICAgICAgIGtleTogX3ZtLmdldE5vZGVLZXkoY2hpbGQpLFxuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgIHByb3BzOiBfdm0ucHJvcHMsXG4gICAgICAgICAgICBcInJlbmRlci1hZnRlci1leHBhbmRcIjogX3ZtLnJlbmRlckFmdGVyRXhwYW5kLFxuICAgICAgICAgICAgXCJzaG93LWNoZWNrYm94XCI6IF92bS5zaG93Q2hlY2tib3gsXG4gICAgICAgICAgICBcInJlbmRlci1jb250ZW50XCI6IF92bS5yZW5kZXJDb250ZW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjogeyBcIm5vZGUtZXhwYW5kXCI6IF92bS5oYW5kbGVOb2RlRXhwYW5kIH1cbiAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgICAgX3ZtLmlzRW1wdHlcbiAgICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImVsLXRyZWVfX2VtcHR5LWJsb2NrXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtdHJlZV9fZW1wdHktdGV4dFwiIH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uZW1wdHlUZXh0KSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgICAgICAgIHZhbHVlOiBfdm0uZHJhZ1N0YXRlLnNob3dEcm9wSW5kaWNhdG9yLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJkcmFnU3RhdGUuc2hvd0Ryb3BJbmRpY2F0b3JcIlxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcmVmOiBcImRyb3BJbmRpY2F0b3JcIixcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdHJlZV9fZHJvcC1pbmRpY2F0b3JcIlxuICAgICAgfSlcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RyZWUvc3JjL3RyZWUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTU0NzU3NWE2JlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvdXRpbHMvbWVyZ2VcIlxudmFyIG1lcmdlXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG52YXIgbWVyZ2VfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obWVyZ2VfKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy90cmVlL3NyYy9tb2RlbC91dGlsLmpzXG52YXIgTk9ERV9LRVkgPSAnJHRyZWVOb2RlSWQnO1xuXG52YXIgbWFya05vZGVEYXRhID0gZnVuY3Rpb24gbWFya05vZGVEYXRhKG5vZGUsIGRhdGEpIHtcbiAgaWYgKCFkYXRhIHx8IGRhdGFbTk9ERV9LRVldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhLCBOT0RFX0tFWSwge1xuICAgIHZhbHVlOiBub2RlLmlkLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xufTtcblxudmFyIHV0aWxfZ2V0Tm9kZUtleSA9IGZ1bmN0aW9uIGdldE5vZGVLZXkoa2V5LCBkYXRhKSB7XG4gIGlmICgha2V5KSByZXR1cm4gZGF0YVtOT0RFX0tFWV07XG4gIHJldHVybiBkYXRhW2tleV07XG59O1xuXG52YXIgZmluZE5lYXJlc3RDb21wb25lbnQgPSBmdW5jdGlvbiBmaW5kTmVhcmVzdENvbXBvbmVudChlbGVtZW50LCBjb21wb25lbnROYW1lKSB7XG4gIHZhciB0YXJnZXQgPSBlbGVtZW50O1xuICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICBpZiAodGFyZ2V0Ll9fdnVlX18gJiYgdGFyZ2V0Ll9fdnVlX18uJG9wdGlvbnMubmFtZSA9PT0gY29tcG9uZW50TmFtZSkge1xuICAgICAgcmV0dXJuIHRhcmdldC5fX3Z1ZV9fO1xuICAgIH1cbiAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvdXRpbHMvdXRpbFwiXG52YXIgdXRpbF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RyZWUvc3JjL21vZGVsL25vZGUuanNcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblxuXG5cblxudmFyIGdldENoaWxkU3RhdGUgPSBmdW5jdGlvbiBnZXRDaGlsZFN0YXRlKG5vZGUpIHtcbiAgdmFyIGFsbCA9IHRydWU7XG4gIHZhciBub25lID0gdHJ1ZTtcbiAgdmFyIGFsbFdpdGhvdXREaXNhYmxlID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBub2RlLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBuID0gbm9kZVtpXTtcbiAgICBpZiAobi5jaGVja2VkICE9PSB0cnVlIHx8IG4uaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgYWxsID0gZmFsc2U7XG4gICAgICBpZiAoIW4uZGlzYWJsZWQpIHtcbiAgICAgICAgYWxsV2l0aG91dERpc2FibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4uY2hlY2tlZCAhPT0gZmFsc2UgfHwgbi5pbmRldGVybWluYXRlKSB7XG4gICAgICBub25lID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgYWxsOiBhbGwsIG5vbmU6IG5vbmUsIGFsbFdpdGhvdXREaXNhYmxlOiBhbGxXaXRob3V0RGlzYWJsZSwgaGFsZjogIWFsbCAmJiAhbm9uZSB9O1xufTtcblxudmFyIHJlSW5pdENoZWNrZWQgPSBmdW5jdGlvbiByZUluaXRDaGVja2VkKG5vZGUpIHtcbiAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICB2YXIgX2dldENoaWxkU3RhdGUgPSBnZXRDaGlsZFN0YXRlKG5vZGUuY2hpbGROb2RlcyksXG4gICAgICBhbGwgPSBfZ2V0Q2hpbGRTdGF0ZS5hbGwsXG4gICAgICBub25lID0gX2dldENoaWxkU3RhdGUubm9uZSxcbiAgICAgIGhhbGYgPSBfZ2V0Q2hpbGRTdGF0ZS5oYWxmO1xuXG4gIGlmIChhbGwpIHtcbiAgICBub2RlLmNoZWNrZWQgPSB0cnVlO1xuICAgIG5vZGUuaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGhhbGYpIHtcbiAgICBub2RlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICBub2RlLmluZGV0ZXJtaW5hdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG5vbmUpIHtcbiAgICBub2RlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICBub2RlLmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LmxldmVsID09PSAwKSByZXR1cm47XG5cbiAgaWYgKCFub2RlLnN0b3JlLmNoZWNrU3RyaWN0bHkpIHtcbiAgICByZUluaXRDaGVja2VkKHBhcmVudCk7XG4gIH1cbn07XG5cbnZhciBnZXRQcm9wZXJ0eUZyb21EYXRhID0gZnVuY3Rpb24gZ2V0UHJvcGVydHlGcm9tRGF0YShub2RlLCBwcm9wKSB7XG4gIHZhciBwcm9wcyA9IG5vZGUuc3RvcmUucHJvcHM7XG4gIHZhciBkYXRhID0gbm9kZS5kYXRhIHx8IHt9O1xuICB2YXIgY29uZmlnID0gcHJvcHNbcHJvcF07XG5cbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29uZmlnKGRhdGEsIG5vZGUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGFbY29uZmlnXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBkYXRhUHJvcCA9IGRhdGFbcHJvcF07XG4gICAgcmV0dXJuIGRhdGFQcm9wID09PSB1bmRlZmluZWQgPyAnJyA6IGRhdGFQcm9wO1xuICB9XG59O1xuXG52YXIgbm9kZUlkU2VlZCA9IDA7XG5cbnZhciBub2RlX05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5vZGUob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcblxuICAgIHRoaXMuaWQgPSBub2RlSWRTZWVkKys7XG4gICAgdGhpcy50ZXh0ID0gbnVsbDtcbiAgICB0aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ3VycmVudCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0aGlzW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbnRlcm5hbFxuICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5jaGlsZE5vZGVzID0gW107XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSB0aGlzLnBhcmVudC5sZXZlbCArIDE7XG4gICAgfVxuXG4gICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICBpZiAoIXN0b3JlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tOb2RlXXN0b3JlIGlzIHJlcXVpcmVkIScpO1xuICAgIH1cbiAgICBzdG9yZS5yZWdpc3Rlck5vZGUodGhpcyk7XG5cbiAgICB2YXIgcHJvcHMgPSBzdG9yZS5wcm9wcztcbiAgICBpZiAocHJvcHMgJiYgdHlwZW9mIHByb3BzLmlzTGVhZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBpc0xlYWYgPSBnZXRQcm9wZXJ0eUZyb21EYXRhKHRoaXMsICdpc0xlYWYnKTtcbiAgICAgIGlmICh0eXBlb2YgaXNMZWFmID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5pc0xlYWZCeVVzZXIgPSBpc0xlYWY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0b3JlLmxhenkgIT09IHRydWUgJiYgdGhpcy5kYXRhKSB7XG4gICAgICB0aGlzLnNldERhdGEodGhpcy5kYXRhKTtcblxuICAgICAgaWYgKHN0b3JlLmRlZmF1bHRFeHBhbmRBbGwpIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsID4gMCAmJiBzdG9yZS5sYXp5ICYmIHN0b3JlLmRlZmF1bHRFeHBhbmRBbGwpIHtcbiAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKSB7XG4gICAgICBtYXJrTm9kZURhdGEodGhpcywgdGhpcy5kYXRhKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRhdGEpIHJldHVybjtcbiAgICB2YXIgZGVmYXVsdEV4cGFuZGVkS2V5cyA9IHN0b3JlLmRlZmF1bHRFeHBhbmRlZEtleXM7XG4gICAgdmFyIGtleSA9IHN0b3JlLmtleTtcbiAgICBpZiAoa2V5ICYmIGRlZmF1bHRFeHBhbmRlZEtleXMgJiYgZGVmYXVsdEV4cGFuZGVkS2V5cy5pbmRleE9mKHRoaXMua2V5KSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuZXhwYW5kKG51bGwsIHN0b3JlLmF1dG9FeHBhbmRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChrZXkgJiYgc3RvcmUuY3VycmVudE5vZGVLZXkgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmtleSA9PT0gc3RvcmUuY3VycmVudE5vZGVLZXkpIHtcbiAgICAgIHN0b3JlLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgIHN0b3JlLmN1cnJlbnROb2RlLmlzQ3VycmVudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN0b3JlLmxhenkpIHtcbiAgICAgIHN0b3JlLl9pbml0RGVmYXVsdENoZWNrZWROb2RlKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTGVhZlN0YXRlKCk7XG4gIH1cblxuICBOb2RlLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YShkYXRhKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBtYXJrTm9kZURhdGEodGhpcywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmNoaWxkTm9kZXMgPSBbXTtcblxuICAgIHZhciBjaGlsZHJlbiA9IHZvaWQgMDtcbiAgICBpZiAodGhpcy5sZXZlbCA9PT0gMCAmJiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgY2hpbGRyZW4gPSB0aGlzLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuID0gZ2V0UHJvcGVydHlGcm9tRGF0YSh0aGlzLCAnY2hpbGRyZW4nKSB8fCBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdGhpcy5pbnNlcnRDaGlsZCh7IGRhdGE6IGNoaWxkcmVuW2ldIH0pO1xuICAgIH1cbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zKHRhcmdldCkge1xuICAgIHZhciBkZWVwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgdmFyIHdhbGsgPSBmdW5jdGlvbiB3YWxrKHBhcmVudCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkTm9kZXMgfHwgW107XG4gICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkID09PSB0YXJnZXQgfHwgZGVlcCAmJiB3YWxrKGNoaWxkKSkge1xuICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiB3YWxrKHRoaXMpO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5pbnNlcnRDaGlsZCA9IGZ1bmN0aW9uIGluc2VydENoaWxkKGNoaWxkLCBpbmRleCwgYmF0Y2gpIHtcbiAgICBpZiAoIWNoaWxkKSB0aHJvdyBuZXcgRXJyb3IoJ2luc2VydENoaWxkIGVycm9yOiBjaGlsZCBpcyByZXF1aXJlZC4nKTtcblxuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICAgIGlmICghYmF0Y2gpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbih0cnVlKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmluZGV4T2YoY2hpbGQuZGF0YSkgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVyZ2VfZGVmYXVsdCgpKGNoaWxkLCB7XG4gICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgc3RvcmU6IHRoaXMuc3RvcmVcbiAgICAgIH0pO1xuICAgICAgY2hpbGQgPSBuZXcgTm9kZShjaGlsZCk7XG4gICAgfVxuXG4gICAgY2hpbGQubGV2ZWwgPSB0aGlzLmxldmVsICsgMTtcblxuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnIHx8IGluZGV4IDwgMCkge1xuICAgICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVMZWFmU3RhdGUoKTtcbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoY2hpbGQsIHJlZikge1xuICAgIHZhciBpbmRleCA9IHZvaWQgMDtcbiAgICBpZiAocmVmKSB7XG4gICAgICBpbmRleCA9IHRoaXMuY2hpbGROb2Rlcy5pbmRleE9mKHJlZik7XG4gICAgfVxuICAgIHRoaXMuaW5zZXJ0Q2hpbGQoY2hpbGQsIGluZGV4KTtcbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKGNoaWxkLCByZWYpIHtcbiAgICB2YXIgaW5kZXggPSB2b2lkIDA7XG4gICAgaWYgKHJlZikge1xuICAgICAgaW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihyZWYpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgaW5kZXggKz0gMTtcbiAgICB9XG4gICAgdGhpcy5pbnNlcnRDaGlsZChjaGlsZCwgaW5kZXgpO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCkgfHwgW107XG4gICAgdmFyIGRhdGFJbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQuZGF0YSk7XG4gICAgaWYgKGRhdGFJbmRleCA+IC0xKSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoZGF0YUluZGV4LCAxKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCk7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5zdG9yZSAmJiB0aGlzLnN0b3JlLmRlcmVnaXN0ZXJOb2RlKGNoaWxkKTtcbiAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUxlYWZTdGF0ZSgpO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkQnlEYXRhID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGRCeURhdGEoZGF0YSkge1xuICAgIHZhciB0YXJnZXROb2RlID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZE5vZGVzW2ldLmRhdGEgPT09IGRhdGEpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldE5vZGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGFyZ2V0Tm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChjYWxsYmFjaywgZXhwYW5kUGFyZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGlmIChleHBhbmRQYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IF90aGlzLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5sZXZlbCA+IDApIHtcbiAgICAgICAgICBwYXJlbnQuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF90aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkTG9hZERhdGEoKSkge1xuICAgICAgdGhpcy5sb2FkRGF0YShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgaWYgKF90aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIF90aGlzLnNldENoZWNrZWQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghX3RoaXMuc3RvcmUuY2hlY2tTdHJpY3RseSkge1xuICAgICAgICAgICAgcmVJbml0Q2hlY2tlZChfdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuZG9DcmVhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIGRvQ3JlYXRlQ2hpbGRyZW4oYXJyYXkpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBkZWZhdWx0UHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgX3RoaXMyLmluc2VydENoaWxkKG1lcmdlX2RlZmF1bHQoKSh7IGRhdGE6IGl0ZW0gfSwgZGVmYXVsdFByb3BzKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5jb2xsYXBzZSA9IGZ1bmN0aW9uIGNvbGxhcHNlKCkge1xuICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5zaG91bGRMb2FkRGF0YSA9IGZ1bmN0aW9uIHNob3VsZExvYWREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnN0b3JlLmxhenkgPT09IHRydWUgJiYgdGhpcy5zdG9yZS5sb2FkICYmICF0aGlzLmxvYWRlZDtcbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS51cGRhdGVMZWFmU3RhdGUgPSBmdW5jdGlvbiB1cGRhdGVMZWFmU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMuc3RvcmUubGF6eSA9PT0gdHJ1ZSAmJiB0aGlzLmxvYWRlZCAhPT0gdHJ1ZSAmJiB0eXBlb2YgdGhpcy5pc0xlYWZCeVVzZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmlzTGVhZiA9IHRoaXMuaXNMZWFmQnlVc2VyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICBpZiAoIXRoaXMuc3RvcmUubGF6eSB8fCB0aGlzLnN0b3JlLmxhenkgPT09IHRydWUgJiYgdGhpcy5sb2FkZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuaXNMZWFmID0gIWNoaWxkTm9kZXMgfHwgY2hpbGROb2Rlcy5sZW5ndGggPT09IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNMZWFmID0gZmFsc2U7XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIHNldENoZWNrZWQodmFsdWUsIGRlZXAsIHJlY3Vyc2lvbiwgcGFzc1ZhbHVlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB0aGlzLmluZGV0ZXJtaW5hdGUgPSB2YWx1ZSA9PT0gJ2hhbGYnO1xuICAgIHRoaXMuY2hlY2tlZCA9IHZhbHVlID09PSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuc3RvcmUuY2hlY2tTdHJpY3RseSkgcmV0dXJuO1xuXG4gICAgaWYgKCEodGhpcy5zaG91bGRMb2FkRGF0YSgpICYmICF0aGlzLnN0b3JlLmNoZWNrRGVzY2VuZGFudHMpKSB7XG4gICAgICB2YXIgX2dldENoaWxkU3RhdGUyID0gZ2V0Q2hpbGRTdGF0ZSh0aGlzLmNoaWxkTm9kZXMpLFxuICAgICAgICAgIGFsbCA9IF9nZXRDaGlsZFN0YXRlMi5hbGwsXG4gICAgICAgICAgYWxsV2l0aG91dERpc2FibGUgPSBfZ2V0Q2hpbGRTdGF0ZTIuYWxsV2l0aG91dERpc2FibGU7XG5cbiAgICAgIGlmICghdGhpcy5pc0xlYWYgJiYgIWFsbCAmJiBhbGxXaXRob3V0RGlzYWJsZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZURlc2NlbmRhbnRzID0gZnVuY3Rpb24gaGFuZGxlRGVzY2VuZGFudHMoKSB7XG4gICAgICAgIGlmIChkZWVwKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBfdGhpczMuY2hpbGROb2RlcztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgcGFzc1ZhbHVlID0gcGFzc1ZhbHVlIHx8IHZhbHVlICE9PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc0NoZWNrID0gY2hpbGQuZGlzYWJsZWQgPyBjaGlsZC5jaGVja2VkIDogcGFzc1ZhbHVlO1xuICAgICAgICAgICAgY2hpbGQuc2V0Q2hlY2tlZChpc0NoZWNrLCBkZWVwLCB0cnVlLCBwYXNzVmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q2hpbGRTdGF0ZTMgPSBnZXRDaGlsZFN0YXRlKGNoaWxkTm9kZXMpLFxuICAgICAgICAgICAgICBoYWxmID0gX2dldENoaWxkU3RhdGUzLmhhbGYsXG4gICAgICAgICAgICAgIF9hbGwgPSBfZ2V0Q2hpbGRTdGF0ZTMuYWxsO1xuXG4gICAgICAgICAgaWYgKCFfYWxsKSB7XG4gICAgICAgICAgICBfdGhpczMuY2hlY2tlZCA9IF9hbGw7XG4gICAgICAgICAgICBfdGhpczMuaW5kZXRlcm1pbmF0ZSA9IGhhbGY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zaG91bGRMb2FkRGF0YSgpKSB7XG4gICAgICAgIC8vIE9ubHkgd29yayBvbiBsYXp5IGxvYWQgZGF0YS5cbiAgICAgICAgdGhpcy5sb2FkRGF0YShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlRGVzY2VuZGFudHMoKTtcbiAgICAgICAgICByZUluaXRDaGVja2VkKF90aGlzMyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjaGVja2VkOiB2YWx1ZSAhPT0gZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZURlc2NlbmRhbnRzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5sZXZlbCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgaWYgKCFyZWN1cnNpb24pIHtcbiAgICAgIHJlSW5pdENoZWNrZWQocGFyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHtcbiAgICB2YXIgZm9yY2VJbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAvLyB0aGlzIGlzIGRhdGFcbiAgICBpZiAodGhpcy5sZXZlbCA9PT0gMCkgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5zdG9yZS5wcm9wcztcbiAgICB2YXIgY2hpbGRyZW4gPSAnY2hpbGRyZW4nO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbiB8fCAnY2hpbGRyZW4nO1xuICAgIH1cblxuICAgIGlmIChkYXRhW2NoaWxkcmVuXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXRhW2NoaWxkcmVuXSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlSW5pdCAmJiAhZGF0YVtjaGlsZHJlbl0pIHtcbiAgICAgIGRhdGFbY2hpbGRyZW5dID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFbY2hpbGRyZW5dO1xuICB9O1xuXG4gIE5vZGUucHJvdG90eXBlLnVwZGF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4oKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgbmV3RGF0YSA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSB8fCBbXTtcbiAgICB2YXIgb2xkRGF0YSA9IHRoaXMuY2hpbGROb2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmRhdGE7XG4gICAgfSk7XG5cbiAgICB2YXIgbmV3RGF0YU1hcCA9IHt9O1xuICAgIHZhciBuZXdOb2RlcyA9IFtdO1xuXG4gICAgbmV3RGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgdmFyIGtleSA9IGl0ZW1bTk9ERV9LRVldO1xuICAgICAgdmFyIGlzTm9kZUV4aXN0cyA9ICEha2V5ICYmIE9iamVjdCh1dGlsX1tcImFycmF5RmluZEluZGV4XCJdKShvbGREYXRhLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVtOT0RFX0tFWV0gPT09IGtleTtcbiAgICAgIH0pID49IDA7XG4gICAgICBpZiAoaXNOb2RlRXhpc3RzKSB7XG4gICAgICAgIG5ld0RhdGFNYXBba2V5XSA9IHsgaW5kZXg6IGluZGV4LCBkYXRhOiBpdGVtIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdOb2Rlcy5wdXNoKHsgaW5kZXg6IGluZGV4LCBkYXRhOiBpdGVtIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLnN0b3JlLmxhenkpIHtcbiAgICAgIG9sZERhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIW5ld0RhdGFNYXBbaXRlbVtOT0RFX0tFWV1dKSBfdGhpczQucmVtb3ZlQ2hpbGRCeURhdGEoaXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBuZXdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgaW5kZXggPSBfcmVmLmluZGV4LFxuICAgICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG5cbiAgICAgIF90aGlzNC5pbnNlcnRDaGlsZCh7IGRhdGE6IGRhdGEgfSwgaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGVMZWFmU3RhdGUoKTtcbiAgfTtcblxuICBOb2RlLnByb3RvdHlwZS5sb2FkRGF0YSA9IGZ1bmN0aW9uIGxvYWREYXRhKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgZGVmYXVsdFByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIGlmICh0aGlzLnN0b3JlLmxhenkgPT09IHRydWUgJiYgdGhpcy5zdG9yZS5sb2FkICYmICF0aGlzLmxvYWRlZCAmJiAoIXRoaXMubG9hZGluZyB8fCBPYmplY3Qua2V5cyhkZWZhdWx0UHJvcHMpLmxlbmd0aCkpIHtcbiAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG5cbiAgICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShjaGlsZHJlbikge1xuICAgICAgICBfdGhpczUubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgX3RoaXM1LmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXM1LmNoaWxkTm9kZXMgPSBbXTtcblxuICAgICAgICBfdGhpczUuZG9DcmVhdGVDaGlsZHJlbihjaGlsZHJlbiwgZGVmYXVsdFByb3BzKTtcblxuICAgICAgICBfdGhpczUudXBkYXRlTGVhZlN0YXRlKCk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoX3RoaXM1LCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc3RvcmUubG9hZCh0aGlzLCByZXNvbHZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogJ2xhYmVsJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUZyb21EYXRhKHRoaXMsICdsYWJlbCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2tleScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbm9kZUtleSA9IHRoaXMuc3RvcmUua2V5O1xuICAgICAgaWYgKHRoaXMuZGF0YSkgcmV0dXJuIHRoaXMuZGF0YVtub2RlS2V5XTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBnZXRQcm9wZXJ0eUZyb21EYXRhKHRoaXMsICdkaXNhYmxlZCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25leHRTaWJsaW5nJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50LmNoaWxkTm9kZXMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkTm9kZXNbaW5kZXggKyAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncHJldmlvdXNTaWJsaW5nJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcGFyZW50LmNoaWxkTm9kZXMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXggPiAwID8gcGFyZW50LmNoaWxkTm9kZXNbaW5kZXggLSAxXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBtb2RlbF9ub2RlID0gKG5vZGVfTm9kZSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RyZWUvc3JjL21vZGVsL3RyZWUtc3RvcmUuanNcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gdHJlZV9zdG9yZV9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblxuXG5cbnZhciB0cmVlX3N0b3JlX1RyZWVTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJlZVN0b3JlKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdHJlZV9zdG9yZV9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmVlU3RvcmUpO1xuXG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50Tm9kZUtleSA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICB0aGlzW29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ub2Rlc01hcCA9IHt9O1xuXG4gICAgdGhpcy5yb290ID0gbmV3IG1vZGVsX25vZGUoe1xuICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgc3RvcmU6IHRoaXNcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmxhenkgJiYgdGhpcy5sb2FkKSB7XG4gICAgICB2YXIgbG9hZEZuID0gdGhpcy5sb2FkO1xuICAgICAgbG9hZEZuKHRoaXMucm9vdCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX3RoaXMucm9vdC5kb0NyZWF0ZUNoaWxkcmVuKGRhdGEpO1xuICAgICAgICBfdGhpcy5faW5pdERlZmF1bHRDaGVja2VkTm9kZXMoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbml0RGVmYXVsdENoZWNrZWROb2RlcygpO1xuICAgIH1cbiAgfVxuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKHZhbHVlKSB7XG4gICAgdmFyIGZpbHRlck5vZGVNZXRob2QgPSB0aGlzLmZpbHRlck5vZGVNZXRob2Q7XG4gICAgdmFyIGxhenkgPSB0aGlzLmxhenk7XG4gICAgdmFyIHRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSkge1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlLnJvb3QgPyBub2RlLnJvb3QuY2hpbGROb2RlcyA6IG5vZGUuY2hpbGROb2RlcztcblxuICAgICAgY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC52aXNpYmxlID0gZmlsdGVyTm9kZU1ldGhvZC5jYWxsKGNoaWxkLCB2YWx1ZSwgY2hpbGQuZGF0YSwgY2hpbGQpO1xuXG4gICAgICAgIHRyYXZlcnNlKGNoaWxkKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW5vZGUudmlzaWJsZSAmJiBjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYWxsSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgYWxsSGlkZGVuID0gIWNoaWxkTm9kZXMuc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGQudmlzaWJsZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG5vZGUucm9vdCkge1xuICAgICAgICAgIG5vZGUucm9vdC52aXNpYmxlID0gYWxsSGlkZGVuID09PSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnZpc2libGUgPSBhbGxIaWRkZW4gPT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlKSByZXR1cm47XG5cbiAgICAgIGlmIChub2RlLnZpc2libGUgJiYgIW5vZGUuaXNMZWFmICYmICFsYXp5KSBub2RlLmV4cGFuZCgpO1xuICAgIH07XG5cbiAgICB0cmF2ZXJzZSh0aGlzKTtcbiAgfTtcblxuICBUcmVlU3RvcmUucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhKG5ld1ZhbCkge1xuICAgIHZhciBpbnN0YW5jZUNoYW5nZWQgPSBuZXdWYWwgIT09IHRoaXMucm9vdC5kYXRhO1xuICAgIGlmIChpbnN0YW5jZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMucm9vdC5zZXREYXRhKG5ld1ZhbCk7XG4gICAgICB0aGlzLl9pbml0RGVmYXVsdENoZWNrZWROb2RlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3QudXBkYXRlQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgVHJlZVN0b3JlLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gZ2V0Tm9kZShkYXRhKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBtb2RlbF9ub2RlKSByZXR1cm4gZGF0YTtcbiAgICB2YXIga2V5ID0gKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgIT09ICdvYmplY3QnID8gZGF0YSA6IHV0aWxfZ2V0Tm9kZUtleSh0aGlzLmtleSwgZGF0YSk7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNNYXBba2V5XSB8fCBudWxsO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGRhdGEsIHJlZkRhdGEpIHtcbiAgICB2YXIgcmVmTm9kZSA9IHRoaXMuZ2V0Tm9kZShyZWZEYXRhKTtcbiAgICByZWZOb2RlLnBhcmVudC5pbnNlcnRCZWZvcmUoeyBkYXRhOiBkYXRhIH0sIHJlZk5vZGUpO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiBpbnNlcnRBZnRlcihkYXRhLCByZWZEYXRhKSB7XG4gICAgdmFyIHJlZk5vZGUgPSB0aGlzLmdldE5vZGUocmVmRGF0YSk7XG4gICAgcmVmTm9kZS5wYXJlbnQuaW5zZXJ0QWZ0ZXIoeyBkYXRhOiBkYXRhIH0sIHJlZk5vZGUpO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGRhdGEpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZShkYXRhKTtcblxuICAgIGlmIChub2RlICYmIG5vZGUucGFyZW50KSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5jdXJyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUucGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBUcmVlU3RvcmUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZChkYXRhLCBwYXJlbnREYXRhKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnREYXRhID8gdGhpcy5nZXROb2RlKHBhcmVudERhdGEpIDogdGhpcy5yb290O1xuXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0Q2hpbGQoeyBkYXRhOiBkYXRhIH0pO1xuICAgIH1cbiAgfTtcblxuICBUcmVlU3RvcmUucHJvdG90eXBlLl9pbml0RGVmYXVsdENoZWNrZWROb2RlcyA9IGZ1bmN0aW9uIF9pbml0RGVmYXVsdENoZWNrZWROb2RlcygpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBkZWZhdWx0Q2hlY2tlZEtleXMgPSB0aGlzLmRlZmF1bHRDaGVja2VkS2V5cyB8fCBbXTtcbiAgICB2YXIgbm9kZXNNYXAgPSB0aGlzLm5vZGVzTWFwO1xuXG4gICAgZGVmYXVsdENoZWNrZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGNoZWNrZWRLZXkpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNNYXBbY2hlY2tlZEtleV07XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuc2V0Q2hlY2tlZCh0cnVlLCAhX3RoaXMyLmNoZWNrU3RyaWN0bHkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuX2luaXREZWZhdWx0Q2hlY2tlZE5vZGUgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDaGVja2VkTm9kZShub2RlKSB7XG4gICAgdmFyIGRlZmF1bHRDaGVja2VkS2V5cyA9IHRoaXMuZGVmYXVsdENoZWNrZWRLZXlzIHx8IFtdO1xuXG4gICAgaWYgKGRlZmF1bHRDaGVja2VkS2V5cy5pbmRleE9mKG5vZGUua2V5KSAhPT0gLTEpIHtcbiAgICAgIG5vZGUuc2V0Q2hlY2tlZCh0cnVlLCAhdGhpcy5jaGVja1N0cmljdGx5KTtcbiAgICB9XG4gIH07XG5cbiAgVHJlZVN0b3JlLnByb3RvdHlwZS5zZXREZWZhdWx0Q2hlY2tlZEtleSA9IGZ1bmN0aW9uIHNldERlZmF1bHRDaGVja2VkS2V5KG5ld1ZhbCkge1xuICAgIGlmIChuZXdWYWwgIT09IHRoaXMuZGVmYXVsdENoZWNrZWRLZXlzKSB7XG4gICAgICB0aGlzLmRlZmF1bHRDaGVja2VkS2V5cyA9IG5ld1ZhbDtcbiAgICAgIHRoaXMuX2luaXREZWZhdWx0Q2hlY2tlZE5vZGVzKCk7XG4gICAgfVxuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJOb2RlID0gZnVuY3Rpb24gcmVnaXN0ZXJOb2RlKG5vZGUpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG4gICAgaWYgKCFrZXkgfHwgIW5vZGUgfHwgIW5vZGUuZGF0YSkgcmV0dXJuO1xuXG4gICAgdmFyIG5vZGVLZXkgPSBub2RlLmtleTtcbiAgICBpZiAobm9kZUtleSAhPT0gdW5kZWZpbmVkKSB0aGlzLm5vZGVzTWFwW25vZGUua2V5XSA9IG5vZGU7XG4gIH07XG5cbiAgVHJlZVN0b3JlLnByb3RvdHlwZS5kZXJlZ2lzdGVyTm9kZSA9IGZ1bmN0aW9uIGRlcmVnaXN0ZXJOb2RlKG5vZGUpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBrZXkgPSB0aGlzLmtleTtcbiAgICBpZiAoIWtleSB8fCAhbm9kZSB8fCAhbm9kZS5kYXRhKSByZXR1cm47XG5cbiAgICBub2RlLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIF90aGlzMy5kZXJlZ2lzdGVyTm9kZShjaGlsZCk7XG4gICAgfSk7XG5cbiAgICBkZWxldGUgdGhpcy5ub2Rlc01hcFtub2RlLmtleV07XG4gIH07XG5cbiAgVHJlZVN0b3JlLnByb3RvdHlwZS5nZXRDaGVja2VkTm9kZXMgPSBmdW5jdGlvbiBnZXRDaGVja2VkTm9kZXMoKSB7XG4gICAgdmFyIGxlYWZPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgaW5jbHVkZUhhbGZDaGVja2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHZhciBjaGVja2VkTm9kZXMgPSBbXTtcbiAgICB2YXIgdHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShub2RlKSB7XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGUucm9vdCA/IG5vZGUucm9vdC5jaGlsZE5vZGVzIDogbm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICBjaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmICgoY2hpbGQuY2hlY2tlZCB8fCBpbmNsdWRlSGFsZkNoZWNrZWQgJiYgY2hpbGQuaW5kZXRlcm1pbmF0ZSkgJiYgKCFsZWFmT25seSB8fCBsZWFmT25seSAmJiBjaGlsZC5pc0xlYWYpKSB7XG4gICAgICAgICAgY2hlY2tlZE5vZGVzLnB1c2goY2hpbGQuZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmF2ZXJzZShjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdHJhdmVyc2UodGhpcyk7XG5cbiAgICByZXR1cm4gY2hlY2tlZE5vZGVzO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuZ2V0Q2hlY2tlZEtleXMgPSBmdW5jdGlvbiBnZXRDaGVja2VkS2V5cygpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBsZWFmT25seSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRDaGVja2VkTm9kZXMobGVhZk9ubHkpLm1hcChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIChkYXRhIHx8IHt9KVtfdGhpczQua2V5XTtcbiAgICB9KTtcbiAgfTtcblxuICBUcmVlU3RvcmUucHJvdG90eXBlLmdldEhhbGZDaGVja2VkTm9kZXMgPSBmdW5jdGlvbiBnZXRIYWxmQ2hlY2tlZE5vZGVzKCkge1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciB0cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZS5yb290ID8gbm9kZS5yb290LmNoaWxkTm9kZXMgOiBub2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgIGNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhdmVyc2UoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRyYXZlcnNlKHRoaXMpO1xuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuZ2V0SGFsZkNoZWNrZWRLZXlzID0gZnVuY3Rpb24gZ2V0SGFsZkNoZWNrZWRLZXlzKCkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0SGFsZkNoZWNrZWROb2RlcygpLm1hcChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIChkYXRhIHx8IHt9KVtfdGhpczUua2V5XTtcbiAgICB9KTtcbiAgfTtcblxuICBUcmVlU3RvcmUucHJvdG90eXBlLl9nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uIF9nZXRBbGxOb2RlcygpIHtcbiAgICB2YXIgYWxsTm9kZXMgPSBbXTtcbiAgICB2YXIgbm9kZXNNYXAgPSB0aGlzLm5vZGVzTWFwO1xuICAgIGZvciAodmFyIG5vZGVLZXkgaW4gbm9kZXNNYXApIHtcbiAgICAgIGlmIChub2Rlc01hcC5oYXNPd25Qcm9wZXJ0eShub2RlS2V5KSkge1xuICAgICAgICBhbGxOb2Rlcy5wdXNoKG5vZGVzTWFwW25vZGVLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWxsTm9kZXM7XG4gIH07XG5cbiAgVHJlZVN0b3JlLnByb3RvdHlwZS51cGRhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKGtleSwgZGF0YSkge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc01hcFtrZXldO1xuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIGZvciAodmFyIGkgPSBjaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgdGhpcy5yZW1vdmUoY2hpbGQuZGF0YSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgaiA9IGRhdGEubGVuZ3RoOyBfaSA8IGo7IF9pKyspIHtcbiAgICAgIHZhciBfY2hpbGQgPSBkYXRhW19pXTtcbiAgICAgIHRoaXMuYXBwZW5kKF9jaGlsZCwgbm9kZS5kYXRhKTtcbiAgICB9XG4gIH07XG5cbiAgVHJlZVN0b3JlLnByb3RvdHlwZS5fc2V0Q2hlY2tlZEtleXMgPSBmdW5jdGlvbiBfc2V0Q2hlY2tlZEtleXMoa2V5KSB7XG4gICAgdmFyIGxlYWZPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgY2hlY2tlZEtleXMgPSBhcmd1bWVudHNbMl07XG5cbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLl9nZXRBbGxOb2RlcygpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLmxldmVsIC0gYS5sZXZlbDtcbiAgICB9KTtcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2hlY2tlZEtleXMpO1xuICAgIGFsbE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLnNldENoZWNrZWQoZmFsc2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFsbE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIHZhciBub2RlS2V5ID0gbm9kZS5kYXRhW2tleV0udG9TdHJpbmcoKTtcbiAgICAgIHZhciBjaGVja2VkID0ga2V5cy5pbmRleE9mKG5vZGVLZXkpID4gLTE7XG4gICAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hlY2tlZCAmJiAhY2FjaGVbbm9kZUtleV0pIHtcbiAgICAgICAgICBub2RlLnNldENoZWNrZWQoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQubGV2ZWwgPiAwKSB7XG4gICAgICAgIGNhY2hlW3BhcmVudC5kYXRhW2tleV1dID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuaXNMZWFmIHx8IHRoaXMuY2hlY2tTdHJpY3RseSkge1xuICAgICAgICBub2RlLnNldENoZWNrZWQodHJ1ZSwgZmFsc2UpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2V0Q2hlY2tlZCh0cnVlLCB0cnVlKTtcblxuICAgICAgaWYgKGxlYWZPbmx5KSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbm9kZS5zZXRDaGVja2VkKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgdmFyIHRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBjaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGQuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuc2V0Q2hlY2tlZChmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyYXZlcnNlKGNoaWxkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdHJhdmVyc2Uobm9kZSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuc2V0Q2hlY2tlZE5vZGVzID0gZnVuY3Rpb24gc2V0Q2hlY2tlZE5vZGVzKGFycmF5KSB7XG4gICAgdmFyIGxlYWZPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHZhciBrZXkgPSB0aGlzLmtleTtcbiAgICB2YXIgY2hlY2tlZEtleXMgPSB7fTtcbiAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBjaGVja2VkS2V5c1soaXRlbSB8fCB7fSlba2V5XV0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0Q2hlY2tlZEtleXMoa2V5LCBsZWFmT25seSwgY2hlY2tlZEtleXMpO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuc2V0Q2hlY2tlZEtleXMgPSBmdW5jdGlvbiBzZXRDaGVja2VkS2V5cyhrZXlzKSB7XG4gICAgdmFyIGxlYWZPbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICAgIHRoaXMuZGVmYXVsdENoZWNrZWRLZXlzID0ga2V5cztcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG4gICAgdmFyIGNoZWNrZWRLZXlzID0ge307XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGNoZWNrZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0Q2hlY2tlZEtleXMoa2V5LCBsZWFmT25seSwgY2hlY2tlZEtleXMpO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuc2V0RGVmYXVsdEV4cGFuZGVkS2V5cyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFeHBhbmRlZEtleXMoa2V5cykge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAga2V5cyA9IGtleXMgfHwgW107XG4gICAgdGhpcy5kZWZhdWx0RXhwYW5kZWRLZXlzID0ga2V5cztcblxuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbm9kZSA9IF90aGlzNi5nZXROb2RlKGtleSk7XG4gICAgICBpZiAobm9kZSkgbm9kZS5leHBhbmQobnVsbCwgX3RoaXM2LmF1dG9FeHBhbmRQYXJlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIHNldENoZWNrZWQoZGF0YSwgY2hlY2tlZCwgZGVlcCkge1xuICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlKGRhdGEpO1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUuc2V0Q2hlY2tlZCghIWNoZWNrZWQsIGRlZXApO1xuICAgIH1cbiAgfTtcblxuICBUcmVlU3RvcmUucHJvdG90eXBlLmdldEN1cnJlbnROb2RlID0gZnVuY3Rpb24gZ2V0Q3VycmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudE5vZGU7XG4gIH07XG5cbiAgVHJlZVN0b3JlLnByb3RvdHlwZS5zZXRDdXJyZW50Tm9kZSA9IGZ1bmN0aW9uIHNldEN1cnJlbnROb2RlKGN1cnJlbnROb2RlKSB7XG4gICAgdmFyIHByZXZDdXJyZW50Tm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgaWYgKHByZXZDdXJyZW50Tm9kZSkge1xuICAgICAgcHJldkN1cnJlbnROb2RlLmlzQ3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnROb2RlID0gY3VycmVudE5vZGU7XG4gICAgdGhpcy5jdXJyZW50Tm9kZS5pc0N1cnJlbnQgPSB0cnVlO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuc2V0VXNlckN1cnJlbnROb2RlID0gZnVuY3Rpb24gc2V0VXNlckN1cnJlbnROb2RlKG5vZGUpIHtcbiAgICB2YXIga2V5ID0gbm9kZVt0aGlzLmtleV07XG4gICAgdmFyIGN1cnJOb2RlID0gdGhpcy5ub2Rlc01hcFtrZXldO1xuICAgIHRoaXMuc2V0Q3VycmVudE5vZGUoY3Vyck5vZGUpO1xuICB9O1xuXG4gIFRyZWVTdG9yZS5wcm90b3R5cGUuc2V0Q3VycmVudE5vZGVLZXkgPSBmdW5jdGlvbiBzZXRDdXJyZW50Tm9kZUtleShrZXkpIHtcbiAgICBpZiAoa2V5ID09PSBudWxsIHx8IGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmN1cnJlbnROb2RlICYmICh0aGlzLmN1cnJlbnROb2RlLmlzQ3VycmVudCA9IGZhbHNlKTtcbiAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZShrZXkpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnROb2RlKG5vZGUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVHJlZVN0b3JlO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmVlX3N0b3JlID0gKHRyZWVfc3RvcmVfVHJlZVN0b3JlKTtcbjtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvdHJlZS9zcmMvdHJlZS1ub2RlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zYmEzZWYwZSZcbnZhciB0cmVlX25vZGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zYmEzZWYwZV9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXNcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgIHZhbHVlOiBfdm0ubm9kZS52aXNpYmxlLFxuICAgICAgICAgIGV4cHJlc3Npb246IFwibm9kZS52aXNpYmxlXCJcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHJlZjogXCJub2RlXCIsXG4gICAgICBzdGF0aWNDbGFzczogXCJlbC10cmVlLW5vZGVcIixcbiAgICAgIGNsYXNzOiB7XG4gICAgICAgIFwiaXMtZXhwYW5kZWRcIjogX3ZtLmV4cGFuZGVkLFxuICAgICAgICBcImlzLWN1cnJlbnRcIjogX3ZtLm5vZGUuaXNDdXJyZW50LFxuICAgICAgICBcImlzLWhpZGRlblwiOiAhX3ZtLm5vZGUudmlzaWJsZSxcbiAgICAgICAgXCJpcy1mb2N1c2FibGVcIjogIV92bS5ub2RlLmRpc2FibGVkLFxuICAgICAgICBcImlzLWNoZWNrZWRcIjogIV92bS5ub2RlLmRpc2FibGVkICYmIF92bS5ub2RlLmNoZWNrZWRcbiAgICAgIH0sXG4gICAgICBhdHRyczoge1xuICAgICAgICByb2xlOiBcInRyZWVpdGVtXCIsXG4gICAgICAgIHRhYmluZGV4OiBcIi0xXCIsXG4gICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiBfdm0uZXhwYW5kZWQsXG4gICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiBfdm0ubm9kZS5kaXNhYmxlZCxcbiAgICAgICAgXCJhcmlhLWNoZWNrZWRcIjogX3ZtLm5vZGUuY2hlY2tlZCxcbiAgICAgICAgZHJhZ2dhYmxlOiBfdm0udHJlZS5kcmFnZ2FibGVcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgcmV0dXJuIF92bS5oYW5kbGVDbGljaygkZXZlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcyQxLmhhbmRsZUNvbnRleHRNZW51KCRldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICByZXR1cm4gX3ZtLmhhbmRsZURyYWdTdGFydCgkZXZlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdvdmVyOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICByZXR1cm4gX3ZtLmhhbmRsZURyYWdPdmVyKCRldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VuZDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgcmV0dXJuIF92bS5oYW5kbGVEcmFnRW5kKCRldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgcmV0dXJuIF92bS5oYW5kbGVEcm9wKCRldmVudClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10cmVlLW5vZGVfX2NvbnRlbnRcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIjogKF92bS5ub2RlLmxldmVsIC0gMSkgKiBfdm0udHJlZS5pbmRlbnQgKyBcInB4XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcInNwYW5cIiwge1xuICAgICAgICAgICAgY2xhc3M6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiaXMtbGVhZlwiOiBfdm0ubm9kZS5pc0xlYWYsXG4gICAgICAgICAgICAgICAgZXhwYW5kZWQ6ICFfdm0ubm9kZS5pc0xlYWYgJiYgX3ZtLmV4cGFuZGVkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiZWwtdHJlZS1ub2RlX19leHBhbmQtaWNvblwiLFxuICAgICAgICAgICAgICBfdm0udHJlZS5pY29uQ2xhc3MgPyBfdm0udHJlZS5pY29uQ2xhc3MgOiBcImVsLWljb24tY2FyZXQtcmlnaHRcIlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmhhbmRsZUV4cGFuZEljb25DbGljaygkZXZlbnQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uc2hvd0NoZWNrYm94XG4gICAgICAgICAgICA/IF9jKFwiZWwtY2hlY2tib3hcIiwge1xuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICBpbmRldGVybWluYXRlOiBfdm0ubm9kZS5pbmRldGVybWluYXRlLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICEhX3ZtLm5vZGUuZGlzYWJsZWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uOiB7IGNoYW5nZTogX3ZtLmhhbmRsZUNoZWNrQ2hhbmdlIH0sXG4gICAgICAgICAgICAgICAgbmF0aXZlT246IHtcbiAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5ub2RlLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS4kc2V0KF92bS5ub2RlLCBcImNoZWNrZWRcIiwgJCR2KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwibm9kZS5jaGVja2VkXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgIF92bS5ub2RlLmxvYWRpbmdcbiAgICAgICAgICAgID8gX2MoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10cmVlLW5vZGVfX2xvYWRpbmctaWNvbiBlbC1pY29uLWxvYWRpbmdcIlxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICBfYyhcIm5vZGUtY29udGVudFwiLCB7IGF0dHJzOiB7IG5vZGU6IF92bS5ub2RlIH0gfSlcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF9jKFwiZWwtY29sbGFwc2UtdHJhbnNpdGlvblwiLCBbXG4gICAgICAgICFfdm0ucmVuZGVyQWZ0ZXJFeHBhbmQgfHwgX3ZtLmNoaWxkTm9kZVJlbmRlcmVkXG4gICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uZXhwYW5kZWQsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiZXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdHJlZS1ub2RlX19jaGlsZHJlblwiLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IHJvbGU6IFwiZ3JvdXBcIiwgXCJhcmlhLWV4cGFuZGVkXCI6IF92bS5leHBhbmRlZCB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF92bS5fbChfdm0ubm9kZS5jaGlsZE5vZGVzLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYyhcImVsLXRyZWUtbm9kZVwiLCB7XG4gICAgICAgICAgICAgICAgICBrZXk6IF92bS5nZXROb2RlS2V5KGNoaWxkKSxcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwicmVuZGVyLWNvbnRlbnRcIjogX3ZtLnJlbmRlckNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIFwicmVuZGVyLWFmdGVyLWV4cGFuZFwiOiBfdm0ucmVuZGVyQWZ0ZXJFeHBhbmQsXG4gICAgICAgICAgICAgICAgICAgIFwic2hvdy1jaGVja2JveFwiOiBfdm0uc2hvd0NoZWNrYm94LFxuICAgICAgICAgICAgICAgICAgICBub2RlOiBjaGlsZFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG9uOiB7IFwibm9kZS1leHBhbmRcIjogX3ZtLmhhbmRsZUNoaWxkTm9kZUV4cGFuZCB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICBdKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgdHJlZV9ub2RldnVlX3R5cGVfdGVtcGxhdGVfaWRfM2JhM2VmMGVfc3RhdGljUmVuZGVyRm5zID0gW11cbnRyZWVfbm9kZXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzNiYTNlZjBlX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvdHJlZS9zcmMvdHJlZS1ub2RlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zYmEzZWYwZSZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL3RyYW5zaXRpb25zL2NvbGxhcHNlLXRyYW5zaXRpb25cIlxudmFyIGNvbGxhcHNlX3RyYW5zaXRpb25fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG52YXIgY29sbGFwc2VfdHJhbnNpdGlvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb2xsYXBzZV90cmFuc2l0aW9uXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi9jaGVja2JveFwiXG52YXIgY2hlY2tib3hfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG52YXIgY2hlY2tib3hfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2hlY2tib3hfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL21peGlucy9lbWl0dGVyXCJcbnZhciBlbWl0dGVyXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgZW1pdHRlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihlbWl0dGVyXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL3RyZWUvc3JjL3RyZWUtbm9kZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJlZV9ub2RldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0VsVHJlZU5vZGUnLFxuXG4gIGNvbXBvbmVudE5hbWU6ICdFbFRyZWVOb2RlJyxcblxuICBtaXhpbnM6IFtlbWl0dGVyX2RlZmF1bHQuYV0sXG5cbiAgcHJvcHM6IHtcbiAgICBub2RlOiB7XG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHt9LFxuICAgIHJlbmRlckNvbnRlbnQ6IEZ1bmN0aW9uLFxuICAgIHJlbmRlckFmdGVyRXhwYW5kOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgc2hvd0NoZWNrYm94OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIEVsQ29sbGFwc2VUcmFuc2l0aW9uOiBjb2xsYXBzZV90cmFuc2l0aW9uX2RlZmF1bHQuYSxcbiAgICBFbENoZWNrYm94OiBjaGVja2JveF9kZWZhdWx0LmEsXG4gICAgTm9kZUNvbnRlbnQ6IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG5vZGU6IHtcbiAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy4kcGFyZW50O1xuICAgICAgICB2YXIgdHJlZSA9IHBhcmVudC50cmVlO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgdmFyIGRhdGEgPSBub2RlLmRhdGEsXG4gICAgICAgICAgICBzdG9yZSA9IG5vZGUuc3RvcmU7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudC5yZW5kZXJDb250ZW50ID8gcGFyZW50LnJlbmRlckNvbnRlbnQuY2FsbChwYXJlbnQuX3JlbmRlclByb3h5LCBoLCB7IF9zZWxmOiB0cmVlLiR2bm9kZS5jb250ZXh0LCBub2RlOiBub2RlLCBkYXRhOiBkYXRhLCBzdG9yZTogc3RvcmUgfSkgOiB0cmVlLiRzY29wZWRTbG90cy5kZWZhdWx0ID8gdHJlZS4kc2NvcGVkU2xvdHMuZGVmYXVsdCh7IG5vZGU6IG5vZGUsIGRhdGE6IGRhdGEgfSkgOiBoKFxuICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICB7ICdjbGFzcyc6ICdlbC10cmVlLW5vZGVfX2xhYmVsJyB9LFxuICAgICAgICAgIFtub2RlLmxhYmVsXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmVlOiBudWxsLFxuICAgICAgZXhwYW5kZWQ6IGZhbHNlLFxuICAgICAgY2hpbGROb2RlUmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgb2xkQ2hlY2tlZDogbnVsbCxcbiAgICAgIG9sZEluZGV0ZXJtaW5hdGU6IG51bGxcbiAgICB9O1xuICB9LFxuXG5cbiAgd2F0Y2g6IHtcbiAgICAnbm9kZS5pbmRldGVybWluYXRlJzogZnVuY3Rpb24gbm9kZUluZGV0ZXJtaW5hdGUodmFsKSB7XG4gICAgICB0aGlzLmhhbmRsZVNlbGVjdENoYW5nZSh0aGlzLm5vZGUuY2hlY2tlZCwgdmFsKTtcbiAgICB9LFxuICAgICdub2RlLmNoZWNrZWQnOiBmdW5jdGlvbiBub2RlQ2hlY2tlZCh2YWwpIHtcbiAgICAgIHRoaXMuaGFuZGxlU2VsZWN0Q2hhbmdlKHZhbCwgdGhpcy5ub2RlLmluZGV0ZXJtaW5hdGUpO1xuICAgIH0sXG4gICAgJ25vZGUuZXhwYW5kZWQnOiBmdW5jdGlvbiBub2RlRXhwYW5kZWQodmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5leHBhbmRlZCA9IHZhbDtcbiAgICAgIH0pO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLmNoaWxkTm9kZVJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdldE5vZGVLZXk6IGZ1bmN0aW9uIGdldE5vZGVLZXkobm9kZSkge1xuICAgICAgcmV0dXJuIHV0aWxfZ2V0Tm9kZUtleSh0aGlzLnRyZWUubm9kZUtleSwgbm9kZS5kYXRhKTtcbiAgICB9LFxuICAgIGhhbmRsZVNlbGVjdENoYW5nZTogZnVuY3Rpb24gaGFuZGxlU2VsZWN0Q2hhbmdlKGNoZWNrZWQsIGluZGV0ZXJtaW5hdGUpIHtcbiAgICAgIGlmICh0aGlzLm9sZENoZWNrZWQgIT09IGNoZWNrZWQgJiYgdGhpcy5vbGRJbmRldGVybWluYXRlICE9PSBpbmRldGVybWluYXRlKSB7XG4gICAgICAgIHRoaXMudHJlZS4kZW1pdCgnY2hlY2stY2hhbmdlJywgdGhpcy5ub2RlLmRhdGEsIGNoZWNrZWQsIGluZGV0ZXJtaW5hdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbGRDaGVja2VkID0gY2hlY2tlZDtcbiAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gICAgfSxcbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soKSB7XG4gICAgICB2YXIgc3RvcmUgPSB0aGlzLnRyZWUuc3RvcmU7XG4gICAgICBzdG9yZS5zZXRDdXJyZW50Tm9kZSh0aGlzLm5vZGUpO1xuICAgICAgdGhpcy50cmVlLiRlbWl0KCdjdXJyZW50LWNoYW5nZScsIHN0b3JlLmN1cnJlbnROb2RlID8gc3RvcmUuY3VycmVudE5vZGUuZGF0YSA6IG51bGwsIHN0b3JlLmN1cnJlbnROb2RlKTtcbiAgICAgIHRoaXMudHJlZS5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICBpZiAodGhpcy50cmVlLmV4cGFuZE9uQ2xpY2tOb2RlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXhwYW5kSWNvbkNsaWNrKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50cmVlLmNoZWNrT25DbGlja05vZGUgJiYgIXRoaXMubm9kZS5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmhhbmRsZUNoZWNrQ2hhbmdlKG51bGwsIHtcbiAgICAgICAgICB0YXJnZXQ6IHsgY2hlY2tlZDogIXRoaXMubm9kZS5jaGVja2VkIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyZWUuJGVtaXQoJ25vZGUtY2xpY2snLCB0aGlzLm5vZGUuZGF0YSwgdGhpcy5ub2RlLCB0aGlzKTtcbiAgICB9LFxuICAgIGhhbmRsZUNvbnRleHRNZW51OiBmdW5jdGlvbiBoYW5kbGVDb250ZXh0TWVudShldmVudCkge1xuICAgICAgaWYgKHRoaXMudHJlZS5fZXZlbnRzWydub2RlLWNvbnRleHRtZW51J10gJiYgdGhpcy50cmVlLl9ldmVudHNbJ25vZGUtY29udGV4dG1lbnUnXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmVlLiRlbWl0KCdub2RlLWNvbnRleHRtZW51JywgZXZlbnQsIHRoaXMubm9kZS5kYXRhLCB0aGlzLm5vZGUsIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRXhwYW5kSWNvbkNsaWNrOiBmdW5jdGlvbiBoYW5kbGVFeHBhbmRJY29uQ2xpY2soKSB7XG4gICAgICBpZiAodGhpcy5ub2RlLmlzTGVhZikgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgdGhpcy50cmVlLiRlbWl0KCdub2RlLWNvbGxhcHNlJywgdGhpcy5ub2RlLmRhdGEsIHRoaXMubm9kZSwgdGhpcyk7XG4gICAgICAgIHRoaXMubm9kZS5jb2xsYXBzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLmV4cGFuZCgpO1xuICAgICAgICB0aGlzLiRlbWl0KCdub2RlLWV4cGFuZCcsIHRoaXMubm9kZS5kYXRhLCB0aGlzLm5vZGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlQ2hlY2tDaGFuZ2U6IGZ1bmN0aW9uIGhhbmRsZUNoZWNrQ2hhbmdlKHZhbHVlLCBldikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMubm9kZS5zZXRDaGVja2VkKGV2LnRhcmdldC5jaGVja2VkLCAhdGhpcy50cmVlLmNoZWNrU3RyaWN0bHkpO1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RvcmUgPSBfdGhpczIudHJlZS5zdG9yZTtcbiAgICAgICAgX3RoaXMyLnRyZWUuJGVtaXQoJ2NoZWNrJywgX3RoaXMyLm5vZGUuZGF0YSwge1xuICAgICAgICAgIGNoZWNrZWROb2Rlczogc3RvcmUuZ2V0Q2hlY2tlZE5vZGVzKCksXG4gICAgICAgICAgY2hlY2tlZEtleXM6IHN0b3JlLmdldENoZWNrZWRLZXlzKCksXG4gICAgICAgICAgaGFsZkNoZWNrZWROb2Rlczogc3RvcmUuZ2V0SGFsZkNoZWNrZWROb2RlcygpLFxuICAgICAgICAgIGhhbGZDaGVja2VkS2V5czogc3RvcmUuZ2V0SGFsZkNoZWNrZWRLZXlzKClcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGhhbmRsZUNoaWxkTm9kZUV4cGFuZDogZnVuY3Rpb24gaGFuZGxlQ2hpbGROb2RlRXhwYW5kKG5vZGVEYXRhLCBub2RlLCBpbnN0YW5jZSkge1xuICAgICAgdGhpcy5icm9hZGNhc3QoJ0VsVHJlZU5vZGUnLCAndHJlZS1ub2RlLWV4cGFuZCcsIG5vZGUpO1xuICAgICAgdGhpcy50cmVlLiRlbWl0KCdub2RlLWV4cGFuZCcsIG5vZGVEYXRhLCBub2RlLCBpbnN0YW5jZSk7XG4gICAgfSxcbiAgICBoYW5kbGVEcmFnU3RhcnQ6IGZ1bmN0aW9uIGhhbmRsZURyYWdTdGFydChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLnRyZWUuZHJhZ2dhYmxlKSByZXR1cm47XG4gICAgICB0aGlzLnRyZWUuJGVtaXQoJ3RyZWUtbm9kZS1kcmFnLXN0YXJ0JywgZXZlbnQsIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRHJhZ092ZXI6IGZ1bmN0aW9uIGhhbmRsZURyYWdPdmVyKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMudHJlZS5kcmFnZ2FibGUpIHJldHVybjtcbiAgICAgIHRoaXMudHJlZS4kZW1pdCgndHJlZS1ub2RlLWRyYWctb3ZlcicsIGV2ZW50LCB0aGlzKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxcbiAgICBoYW5kbGVEcm9wOiBmdW5jdGlvbiBoYW5kbGVEcm9wKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG4gICAgaGFuZGxlRHJhZ0VuZDogZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLnRyZWUuZHJhZ2dhYmxlKSByZXR1cm47XG4gICAgICB0aGlzLnRyZWUuJGVtaXQoJ3RyZWUtbm9kZS1kcmFnLWVuZCcsIGV2ZW50LCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50LmlzVHJlZSkge1xuICAgICAgdGhpcy50cmVlID0gcGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyZWUgPSBwYXJlbnQudHJlZTtcbiAgICB9XG5cbiAgICB2YXIgdHJlZSA9IHRoaXMudHJlZTtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2FuIG5vdCBmaW5kIG5vZGVcXCdzIHRyZWUuJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gdHJlZS5wcm9wcyB8fCB7fTtcbiAgICB2YXIgY2hpbGRyZW5LZXkgPSBwcm9wc1snY2hpbGRyZW4nXSB8fCAnY2hpbGRyZW4nO1xuXG4gICAgdGhpcy4kd2F0Y2goJ25vZGUuZGF0YS4nICsgY2hpbGRyZW5LZXksIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5ub2RlLnVwZGF0ZUNoaWxkcmVuKCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5ub2RlLmV4cGFuZGVkKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hpbGROb2RlUmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRyZWUuYWNjb3JkaW9uKSB7XG4gICAgICB0aGlzLiRvbigndHJlZS1ub2RlLWV4cGFuZCcsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChfdGhpczMubm9kZSAhPT0gbm9kZSkge1xuICAgICAgICAgIF90aGlzMy5ub2RlLmNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RyZWUvc3JjL3RyZWUtbm9kZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3RyZWVfbm9kZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh0cmVlX25vZGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG52YXIgY29tcG9uZW50Tm9ybWFsaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvdHJlZS9zcmMvdHJlZS1ub2RlLnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGNvbXBvbmVudCA9IE9iamVjdChjb21wb25lbnROb3JtYWxpemVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShcbiAgc3JjX3RyZWVfbm9kZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgdHJlZV9ub2RldnVlX3R5cGVfdGVtcGxhdGVfaWRfM2JhM2VmMGVfcmVuZGVyLFxuICB0cmVlX25vZGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zYmEzZWYwZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWNrYWdlcy90cmVlL3NyYy90cmVlLW5vZGUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyZWVfbm9kZSA9IChjb21wb25lbnQuZXhwb3J0cyk7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvbG9jYWxlXCJcbnZhciBsb2NhbGVfID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy9kb21cIlxudmFyIGRvbV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy90cmVlL3NyYy90cmVlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyZWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnRWxUcmVlJyxcblxuICBtaXhpbnM6IFtlbWl0dGVyX2RlZmF1bHQuYV0sXG5cbiAgY29tcG9uZW50czoge1xuICAgIEVsVHJlZU5vZGU6IHRyZWVfbm9kZVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JlOiBudWxsLFxuICAgICAgcm9vdDogbnVsbCxcbiAgICAgIGN1cnJlbnROb2RlOiBudWxsLFxuICAgICAgdHJlZUl0ZW1zOiBudWxsLFxuICAgICAgY2hlY2tib3hJdGVtczogW10sXG4gICAgICBkcmFnU3RhdGU6IHtcbiAgICAgICAgc2hvd0Ryb3BJbmRpY2F0b3I6IGZhbHNlLFxuICAgICAgICBkcmFnZ2luZ05vZGU6IG51bGwsXG4gICAgICAgIGRyb3BOb2RlOiBudWxsLFxuICAgICAgICBhbGxvd0Ryb3A6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG5cbiAgcHJvcHM6IHtcbiAgICBkYXRhOiB7XG4gICAgICB0eXBlOiBBcnJheVxuICAgIH0sXG4gICAgZW1wdHlUZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChsb2NhbGVfW1widFwiXSkoJ2VsLnRyZWUuZW1wdHlUZXh0Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJBZnRlckV4cGFuZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIG5vZGVLZXk6IFN0cmluZyxcbiAgICBjaGVja1N0cmljdGx5OiBCb29sZWFuLFxuICAgIGRlZmF1bHRFeHBhbmRBbGw6IEJvb2xlYW4sXG4gICAgZXhwYW5kT25DbGlja05vZGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBjaGVja09uQ2xpY2tOb2RlOiBCb29sZWFuLFxuICAgIGNoZWNrRGVzY2VuZGFudHM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXV0b0V4cGFuZFBhcmVudDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGRlZmF1bHRDaGVja2VkS2V5czogQXJyYXksXG4gICAgZGVmYXVsdEV4cGFuZGVkS2V5czogQXJyYXksXG4gICAgY3VycmVudE5vZGVLZXk6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgcmVuZGVyQ29udGVudDogRnVuY3Rpb24sXG4gICAgc2hvd0NoZWNrYm94OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGRyYWdnYWJsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhbGxvd0RyYWc6IEZ1bmN0aW9uLFxuICAgIGFsbG93RHJvcDogRnVuY3Rpb24sXG4gICAgcHJvcHM6IHtcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICAgICAgICAgIGxhYmVsOiAnbGFiZWwnLFxuICAgICAgICAgIGRpc2FibGVkOiAnZGlzYWJsZWQnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBsYXp5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGhpZ2hsaWdodEN1cnJlbnQ6IEJvb2xlYW4sXG4gICAgbG9hZDogRnVuY3Rpb24sXG4gICAgZmlsdGVyTm9kZU1ldGhvZDogRnVuY3Rpb24sXG4gICAgYWNjb3JkaW9uOiBCb29sZWFuLFxuICAgIGluZGVudDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMThcbiAgICB9LFxuICAgIGljb25DbGFzczogU3RyaW5nXG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBjaGlsZHJlbjoge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRyZWVJdGVtQXJyYXk6IGZ1bmN0aW9uIHRyZWVJdGVtQXJyYXkoKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy50cmVlSXRlbXMpO1xuICAgIH0sXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5yb290LmNoaWxkTm9kZXM7XG5cbiAgICAgIHJldHVybiAhY2hpbGROb2RlcyB8fCBjaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBjaGlsZE5vZGVzLmV2ZXJ5KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB2aXNpYmxlID0gX3JlZi52aXNpYmxlO1xuICAgICAgICByZXR1cm4gIXZpc2libGU7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBkZWZhdWx0Q2hlY2tlZEtleXM6IGZ1bmN0aW9uIGRlZmF1bHRDaGVja2VkS2V5cyhuZXdWYWwpIHtcbiAgICAgIHRoaXMuc3RvcmUuc2V0RGVmYXVsdENoZWNrZWRLZXkobmV3VmFsKTtcbiAgICB9LFxuICAgIGRlZmF1bHRFeHBhbmRlZEtleXM6IGZ1bmN0aW9uIGRlZmF1bHRFeHBhbmRlZEtleXMobmV3VmFsKSB7XG4gICAgICB0aGlzLnN0b3JlLmRlZmF1bHRFeHBhbmRlZEtleXMgPSBuZXdWYWw7XG4gICAgICB0aGlzLnN0b3JlLnNldERlZmF1bHRFeHBhbmRlZEtleXMobmV3VmFsKTtcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEobmV3VmFsKSB7XG4gICAgICB0aGlzLnN0b3JlLnNldERhdGEobmV3VmFsKTtcbiAgICB9LFxuICAgIGNoZWNrYm94SXRlbXM6IGZ1bmN0aW9uIGNoZWNrYm94SXRlbXModmFsKSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHZhbCwgZnVuY3Rpb24gKGNoZWNrYm94KSB7XG4gICAgICAgIGNoZWNrYm94LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNoZWNrU3RyaWN0bHk6IGZ1bmN0aW9uIGNoZWNrU3RyaWN0bHkobmV3VmFsKSB7XG4gICAgICB0aGlzLnN0b3JlLmNoZWNrU3RyaWN0bHkgPSBuZXdWYWw7XG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcih2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmZpbHRlck5vZGVNZXRob2QpIHRocm93IG5ldyBFcnJvcignW1RyZWVdIGZpbHRlck5vZGVNZXRob2QgaXMgcmVxdWlyZWQgd2hlbiBmaWx0ZXInKTtcbiAgICAgIHRoaXMuc3RvcmUuZmlsdGVyKHZhbHVlKTtcbiAgICB9LFxuICAgIGdldE5vZGVLZXk6IGZ1bmN0aW9uIGdldE5vZGVLZXkobm9kZSkge1xuICAgICAgcmV0dXJuIHV0aWxfZ2V0Tm9kZUtleSh0aGlzLm5vZGVLZXksIG5vZGUuZGF0YSk7XG4gICAgfSxcbiAgICBnZXROb2RlUGF0aDogZnVuY3Rpb24gZ2V0Tm9kZVBhdGgoZGF0YSkge1xuICAgICAgaWYgKCF0aGlzLm5vZGVLZXkpIHRocm93IG5ldyBFcnJvcignW1RyZWVdIG5vZGVLZXkgaXMgcmVxdWlyZWQgaW4gZ2V0Tm9kZVBhdGgnKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdG9yZS5nZXROb2RlKGRhdGEpO1xuICAgICAgaWYgKCFub2RlKSByZXR1cm4gW107XG4gICAgICB2YXIgcGF0aCA9IFtub2RlLmRhdGFdO1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IHRoaXMucm9vdCkge1xuICAgICAgICBwYXRoLnB1c2gocGFyZW50LmRhdGEpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgZ2V0Q2hlY2tlZE5vZGVzOiBmdW5jdGlvbiBnZXRDaGVja2VkTm9kZXMobGVhZk9ubHksIGluY2x1ZGVIYWxmQ2hlY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0Q2hlY2tlZE5vZGVzKGxlYWZPbmx5LCBpbmNsdWRlSGFsZkNoZWNrZWQpO1xuICAgIH0sXG4gICAgZ2V0Q2hlY2tlZEtleXM6IGZ1bmN0aW9uIGdldENoZWNrZWRLZXlzKGxlYWZPbmx5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRDaGVja2VkS2V5cyhsZWFmT25seSk7XG4gICAgfSxcbiAgICBnZXRDdXJyZW50Tm9kZTogZnVuY3Rpb24gZ2V0Q3VycmVudE5vZGUoKSB7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLnN0b3JlLmdldEN1cnJlbnROb2RlKCk7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGUgPyBjdXJyZW50Tm9kZS5kYXRhIDogbnVsbDtcbiAgICB9LFxuICAgIGdldEN1cnJlbnRLZXk6IGZ1bmN0aW9uIGdldEN1cnJlbnRLZXkoKSB7XG4gICAgICBpZiAoIXRoaXMubm9kZUtleSkgdGhyb3cgbmV3IEVycm9yKCdbVHJlZV0gbm9kZUtleSBpcyByZXF1aXJlZCBpbiBnZXRDdXJyZW50S2V5Jyk7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLmdldEN1cnJlbnROb2RlKCk7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGUgPyBjdXJyZW50Tm9kZVt0aGlzLm5vZGVLZXldIDogbnVsbDtcbiAgICB9LFxuICAgIHNldENoZWNrZWROb2RlczogZnVuY3Rpb24gc2V0Q2hlY2tlZE5vZGVzKG5vZGVzLCBsZWFmT25seSkge1xuICAgICAgaWYgKCF0aGlzLm5vZGVLZXkpIHRocm93IG5ldyBFcnJvcignW1RyZWVdIG5vZGVLZXkgaXMgcmVxdWlyZWQgaW4gc2V0Q2hlY2tlZE5vZGVzJyk7XG4gICAgICB0aGlzLnN0b3JlLnNldENoZWNrZWROb2Rlcyhub2RlcywgbGVhZk9ubHkpO1xuICAgIH0sXG4gICAgc2V0Q2hlY2tlZEtleXM6IGZ1bmN0aW9uIHNldENoZWNrZWRLZXlzKGtleXMsIGxlYWZPbmx5KSB7XG4gICAgICBpZiAoIXRoaXMubm9kZUtleSkgdGhyb3cgbmV3IEVycm9yKCdbVHJlZV0gbm9kZUtleSBpcyByZXF1aXJlZCBpbiBzZXRDaGVja2VkS2V5cycpO1xuICAgICAgdGhpcy5zdG9yZS5zZXRDaGVja2VkS2V5cyhrZXlzLCBsZWFmT25seSk7XG4gICAgfSxcbiAgICBzZXRDaGVja2VkOiBmdW5jdGlvbiBzZXRDaGVja2VkKGRhdGEsIGNoZWNrZWQsIGRlZXApIHtcbiAgICAgIHRoaXMuc3RvcmUuc2V0Q2hlY2tlZChkYXRhLCBjaGVja2VkLCBkZWVwKTtcbiAgICB9LFxuICAgIGdldEhhbGZDaGVja2VkTm9kZXM6IGZ1bmN0aW9uIGdldEhhbGZDaGVja2VkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRIYWxmQ2hlY2tlZE5vZGVzKCk7XG4gICAgfSxcbiAgICBnZXRIYWxmQ2hlY2tlZEtleXM6IGZ1bmN0aW9uIGdldEhhbGZDaGVja2VkS2V5cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldEhhbGZDaGVja2VkS2V5cygpO1xuICAgIH0sXG4gICAgc2V0Q3VycmVudE5vZGU6IGZ1bmN0aW9uIHNldEN1cnJlbnROb2RlKG5vZGUpIHtcbiAgICAgIGlmICghdGhpcy5ub2RlS2V5KSB0aHJvdyBuZXcgRXJyb3IoJ1tUcmVlXSBub2RlS2V5IGlzIHJlcXVpcmVkIGluIHNldEN1cnJlbnROb2RlJyk7XG4gICAgICB0aGlzLnN0b3JlLnNldFVzZXJDdXJyZW50Tm9kZShub2RlKTtcbiAgICB9LFxuICAgIHNldEN1cnJlbnRLZXk6IGZ1bmN0aW9uIHNldEN1cnJlbnRLZXkoa2V5KSB7XG4gICAgICBpZiAoIXRoaXMubm9kZUtleSkgdGhyb3cgbmV3IEVycm9yKCdbVHJlZV0gbm9kZUtleSBpcyByZXF1aXJlZCBpbiBzZXRDdXJyZW50S2V5Jyk7XG4gICAgICB0aGlzLnN0b3JlLnNldEN1cnJlbnROb2RlS2V5KGtleSk7XG4gICAgfSxcbiAgICBnZXROb2RlOiBmdW5jdGlvbiBnZXROb2RlKGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JlLmdldE5vZGUoZGF0YSk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShkYXRhKSB7XG4gICAgICB0aGlzLnN0b3JlLnJlbW92ZShkYXRhKTtcbiAgICB9LFxuICAgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKGRhdGEsIHBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuc3RvcmUuYXBwZW5kKGRhdGEsIHBhcmVudE5vZGUpO1xuICAgIH0sXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZGF0YSwgcmVmTm9kZSkge1xuICAgICAgdGhpcy5zdG9yZS5pbnNlcnRCZWZvcmUoZGF0YSwgcmVmTm9kZSk7XG4gICAgfSxcbiAgICBpbnNlcnRBZnRlcjogZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZGF0YSwgcmVmTm9kZSkge1xuICAgICAgdGhpcy5zdG9yZS5pbnNlcnRBZnRlcihkYXRhLCByZWZOb2RlKTtcbiAgICB9LFxuICAgIGhhbmRsZU5vZGVFeHBhbmQ6IGZ1bmN0aW9uIGhhbmRsZU5vZGVFeHBhbmQobm9kZURhdGEsIG5vZGUsIGluc3RhbmNlKSB7XG4gICAgICB0aGlzLmJyb2FkY2FzdCgnRWxUcmVlTm9kZScsICd0cmVlLW5vZGUtZXhwYW5kJywgbm9kZSk7XG4gICAgICB0aGlzLiRlbWl0KCdub2RlLWV4cGFuZCcsIG5vZGVEYXRhLCBub2RlLCBpbnN0YW5jZSk7XG4gICAgfSxcbiAgICB1cGRhdGVLZXlDaGlsZHJlbjogZnVuY3Rpb24gdXBkYXRlS2V5Q2hpbGRyZW4oa2V5LCBkYXRhKSB7XG4gICAgICBpZiAoIXRoaXMubm9kZUtleSkgdGhyb3cgbmV3IEVycm9yKCdbVHJlZV0gbm9kZUtleSBpcyByZXF1aXJlZCBpbiB1cGRhdGVLZXlDaGlsZCcpO1xuICAgICAgdGhpcy5zdG9yZS51cGRhdGVDaGlsZHJlbihrZXksIGRhdGEpO1xuICAgIH0sXG4gICAgaW5pdFRhYkluZGV4OiBmdW5jdGlvbiBpbml0VGFiSW5kZXgoKSB7XG4gICAgICB0aGlzLnRyZWVJdGVtcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5pcy1mb2N1c2FibGVbcm9sZT10cmVlaXRlbV0nKTtcbiAgICAgIHRoaXMuY2hlY2tib3hJdGVtcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9Y2hlY2tib3hdJyk7XG4gICAgICB2YXIgY2hlY2tlZEl0ZW0gPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcuaXMtY2hlY2tlZFtyb2xlPXRyZWVpdGVtXScpO1xuICAgICAgaWYgKGNoZWNrZWRJdGVtLmxlbmd0aCkge1xuICAgICAgICBjaGVja2VkSXRlbVswXS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJlZUl0ZW1zWzBdICYmIHRoaXMudHJlZUl0ZW1zWzBdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICB9LFxuICAgIGhhbmRsZUtleWRvd246IGZ1bmN0aW9uIGhhbmRsZUtleWRvd24oZXYpIHtcbiAgICAgIHZhciBjdXJyZW50SXRlbSA9IGV2LnRhcmdldDtcbiAgICAgIGlmIChjdXJyZW50SXRlbS5jbGFzc05hbWUuaW5kZXhPZignZWwtdHJlZS1ub2RlJykgPT09IC0xKSByZXR1cm47XG4gICAgICB2YXIga2V5Q29kZSA9IGV2LmtleUNvZGU7XG4gICAgICB0aGlzLnRyZWVJdGVtcyA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5pcy1mb2N1c2FibGVbcm9sZT10cmVlaXRlbV0nKTtcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLnRyZWVJdGVtQXJyYXkuaW5kZXhPZihjdXJyZW50SXRlbSk7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gdm9pZCAwO1xuICAgICAgaWYgKFszOCwgNDBdLmluZGV4T2Yoa2V5Q29kZSkgPiAtMSkge1xuICAgICAgICAvLyB1cOOAgWRvd25cbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IDM4KSB7XG4gICAgICAgICAgLy8gdXBcbiAgICAgICAgICBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggIT09IDAgPyBjdXJyZW50SW5kZXggLSAxIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggPCB0aGlzLnRyZWVJdGVtQXJyYXkubGVuZ3RoIC0gMSA/IGN1cnJlbnRJbmRleCArIDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJlZUl0ZW1BcnJheVtuZXh0SW5kZXhdLmZvY3VzKCk7IC8vIOmAieS4rVxuICAgICAgfVxuICAgICAgaWYgKFszNywgMzldLmluZGV4T2Yoa2V5Q29kZSkgPiAtMSkge1xuICAgICAgICAvLyBsZWZ044CBcmlnaHQg5bGV5byAXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGN1cnJlbnRJdGVtLmNsaWNrKCk7IC8vIOmAieS4rVxuICAgICAgfVxuICAgICAgdmFyIGhhc0lucHV0ID0gY3VycmVudEl0ZW0ucXVlcnlTZWxlY3RvcignW3R5cGU9XCJjaGVja2JveFwiXScpO1xuICAgICAgaWYgKFsxMywgMzJdLmluZGV4T2Yoa2V5Q29kZSkgPiAtMSAmJiBoYXNJbnB1dCkge1xuICAgICAgICAvLyBzcGFjZSBlbnRlcumAieS4rWNoZWNrYm94XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGhhc0lucHV0LmNsaWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuaXNUcmVlID0gdHJ1ZTtcblxuICAgIHRoaXMuc3RvcmUgPSBuZXcgdHJlZV9zdG9yZSh7XG4gICAgICBrZXk6IHRoaXMubm9kZUtleSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgIGxhenk6IHRoaXMubGF6eSxcbiAgICAgIHByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgbG9hZDogdGhpcy5sb2FkLFxuICAgICAgY3VycmVudE5vZGVLZXk6IHRoaXMuY3VycmVudE5vZGVLZXksXG4gICAgICBjaGVja1N0cmljdGx5OiB0aGlzLmNoZWNrU3RyaWN0bHksXG4gICAgICBjaGVja0Rlc2NlbmRhbnRzOiB0aGlzLmNoZWNrRGVzY2VuZGFudHMsXG4gICAgICBkZWZhdWx0Q2hlY2tlZEtleXM6IHRoaXMuZGVmYXVsdENoZWNrZWRLZXlzLFxuICAgICAgZGVmYXVsdEV4cGFuZGVkS2V5czogdGhpcy5kZWZhdWx0RXhwYW5kZWRLZXlzLFxuICAgICAgYXV0b0V4cGFuZFBhcmVudDogdGhpcy5hdXRvRXhwYW5kUGFyZW50LFxuICAgICAgZGVmYXVsdEV4cGFuZEFsbDogdGhpcy5kZWZhdWx0RXhwYW5kQWxsLFxuICAgICAgZmlsdGVyTm9kZU1ldGhvZDogdGhpcy5maWx0ZXJOb2RlTWV0aG9kXG4gICAgfSk7XG5cbiAgICB0aGlzLnJvb3QgPSB0aGlzLnN0b3JlLnJvb3Q7XG5cbiAgICB2YXIgZHJhZ1N0YXRlID0gdGhpcy5kcmFnU3RhdGU7XG4gICAgdGhpcy4kb24oJ3RyZWUtbm9kZS1kcmFnLXN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50LCB0cmVlTm9kZSkge1xuICAgICAgaWYgKHR5cGVvZiBfdGhpcy5hbGxvd0RyYWcgPT09ICdmdW5jdGlvbicgJiYgIV90aGlzLmFsbG93RHJhZyh0cmVlTm9kZS5ub2RlKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcblxuICAgICAgLy8gd3JhcCBpbiB0cnkgY2F0Y2ggdG8gYWRkcmVzcyBJRSdzIGVycm9yIHdoZW4gZmlyc3QgcGFyYW0gaXMgJ3RleHQvcGxhaW4nXG4gICAgICB0cnkge1xuICAgICAgICAvLyBzZXREYXRhIGlzIHJlcXVpcmVkIGZvciBkcmFnZ2FibGUgdG8gd29yayBpbiBGaXJlRm94XG4gICAgICAgIC8vIHRoZSBjb250ZW50IGhhcyB0byBiZSAnJyBzbyBkcmFnZ2luZyBhIG5vZGUgb3V0IG9mIHRoZSB0cmVlIHdvbid0IG9wZW4gYSBuZXcgdGFiIGluIEZpcmVGb3hcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQvcGxhaW4nLCAnJyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgZHJhZ1N0YXRlLmRyYWdnaW5nTm9kZSA9IHRyZWVOb2RlO1xuICAgICAgX3RoaXMuJGVtaXQoJ25vZGUtZHJhZy1zdGFydCcsIHRyZWVOb2RlLm5vZGUsIGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuJG9uKCd0cmVlLW5vZGUtZHJhZy1vdmVyJywgZnVuY3Rpb24gKGV2ZW50LCB0cmVlTm9kZSkge1xuICAgICAgdmFyIGRyb3BOb2RlID0gZmluZE5lYXJlc3RDb21wb25lbnQoZXZlbnQudGFyZ2V0LCAnRWxUcmVlTm9kZScpO1xuICAgICAgdmFyIG9sZERyb3BOb2RlID0gZHJhZ1N0YXRlLmRyb3BOb2RlO1xuICAgICAgaWYgKG9sZERyb3BOb2RlICYmIG9sZERyb3BOb2RlICE9PSBkcm9wTm9kZSkge1xuICAgICAgICBPYmplY3QoZG9tX1tcInJlbW92ZUNsYXNzXCJdKShvbGREcm9wTm9kZS4kZWwsICdpcy1kcm9wLWlubmVyJyk7XG4gICAgICB9XG4gICAgICB2YXIgZHJhZ2dpbmdOb2RlID0gZHJhZ1N0YXRlLmRyYWdnaW5nTm9kZTtcbiAgICAgIGlmICghZHJhZ2dpbmdOb2RlIHx8ICFkcm9wTm9kZSkgcmV0dXJuO1xuXG4gICAgICB2YXIgZHJvcFByZXYgPSB0cnVlO1xuICAgICAgdmFyIGRyb3BJbm5lciA9IHRydWU7XG4gICAgICB2YXIgZHJvcE5leHQgPSB0cnVlO1xuICAgICAgdmFyIHVzZXJBbGxvd0Ryb3BJbm5lciA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIF90aGlzLmFsbG93RHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkcm9wUHJldiA9IF90aGlzLmFsbG93RHJvcChkcmFnZ2luZ05vZGUubm9kZSwgZHJvcE5vZGUubm9kZSwgJ3ByZXYnKTtcbiAgICAgICAgdXNlckFsbG93RHJvcElubmVyID0gZHJvcElubmVyID0gX3RoaXMuYWxsb3dEcm9wKGRyYWdnaW5nTm9kZS5ub2RlLCBkcm9wTm9kZS5ub2RlLCAnaW5uZXInKTtcbiAgICAgICAgZHJvcE5leHQgPSBfdGhpcy5hbGxvd0Ryb3AoZHJhZ2dpbmdOb2RlLm5vZGUsIGRyb3BOb2RlLm5vZGUsICduZXh0Jyk7XG4gICAgICB9XG4gICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGRyb3BJbm5lciA/ICdtb3ZlJyA6ICdub25lJztcbiAgICAgIGlmICgoZHJvcFByZXYgfHwgZHJvcElubmVyIHx8IGRyb3BOZXh0KSAmJiBvbGREcm9wTm9kZSAhPT0gZHJvcE5vZGUpIHtcbiAgICAgICAgaWYgKG9sZERyb3BOb2RlKSB7XG4gICAgICAgICAgX3RoaXMuJGVtaXQoJ25vZGUtZHJhZy1sZWF2ZScsIGRyYWdnaW5nTm9kZS5ub2RlLCBvbGREcm9wTm9kZS5ub2RlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuJGVtaXQoJ25vZGUtZHJhZy1lbnRlcicsIGRyYWdnaW5nTm9kZS5ub2RlLCBkcm9wTm9kZS5ub2RlLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcm9wUHJldiB8fCBkcm9wSW5uZXIgfHwgZHJvcE5leHQpIHtcbiAgICAgICAgZHJhZ1N0YXRlLmRyb3BOb2RlID0gZHJvcE5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChkcm9wTm9kZS5ub2RlLm5leHRTaWJsaW5nID09PSBkcmFnZ2luZ05vZGUubm9kZSkge1xuICAgICAgICBkcm9wTmV4dCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGRyb3BOb2RlLm5vZGUucHJldmlvdXNTaWJsaW5nID09PSBkcmFnZ2luZ05vZGUubm9kZSkge1xuICAgICAgICBkcm9wUHJldiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGRyb3BOb2RlLm5vZGUuY29udGFpbnMoZHJhZ2dpbmdOb2RlLm5vZGUsIGZhbHNlKSkge1xuICAgICAgICBkcm9wSW5uZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmFnZ2luZ05vZGUubm9kZSA9PT0gZHJvcE5vZGUubm9kZSB8fCBkcmFnZ2luZ05vZGUubm9kZS5jb250YWlucyhkcm9wTm9kZS5ub2RlKSkge1xuICAgICAgICBkcm9wUHJldiA9IGZhbHNlO1xuICAgICAgICBkcm9wSW5uZXIgPSBmYWxzZTtcbiAgICAgICAgZHJvcE5leHQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldFBvc2l0aW9uID0gZHJvcE5vZGUuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHRyZWVQb3NpdGlvbiA9IF90aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgdmFyIGRyb3BUeXBlID0gdm9pZCAwO1xuICAgICAgdmFyIHByZXZQZXJjZW50ID0gZHJvcFByZXYgPyBkcm9wSW5uZXIgPyAwLjI1IDogZHJvcE5leHQgPyAwLjQ1IDogMSA6IC0xO1xuICAgICAgdmFyIG5leHRQZXJjZW50ID0gZHJvcE5leHQgPyBkcm9wSW5uZXIgPyAwLjc1IDogZHJvcFByZXYgPyAwLjU1IDogMCA6IDE7XG5cbiAgICAgIHZhciBpbmRpY2F0b3JUb3AgPSAtOTk5OTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IGV2ZW50LmNsaWVudFkgLSB0YXJnZXRQb3NpdGlvbi50b3A7XG4gICAgICBpZiAoZGlzdGFuY2UgPCB0YXJnZXRQb3NpdGlvbi5oZWlnaHQgKiBwcmV2UGVyY2VudCkge1xuICAgICAgICBkcm9wVHlwZSA9ICdiZWZvcmUnO1xuICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSA+IHRhcmdldFBvc2l0aW9uLmhlaWdodCAqIG5leHRQZXJjZW50KSB7XG4gICAgICAgIGRyb3BUeXBlID0gJ2FmdGVyJztcbiAgICAgIH0gZWxzZSBpZiAoZHJvcElubmVyKSB7XG4gICAgICAgIGRyb3BUeXBlID0gJ2lubmVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyb3BUeXBlID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWNvblBvc2l0aW9uID0gZHJvcE5vZGUuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5lbC10cmVlLW5vZGVfX2V4cGFuZC1pY29uJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgZHJvcEluZGljYXRvciA9IF90aGlzLiRyZWZzLmRyb3BJbmRpY2F0b3I7XG4gICAgICBpZiAoZHJvcFR5cGUgPT09ICdiZWZvcmUnKSB7XG4gICAgICAgIGluZGljYXRvclRvcCA9IGljb25Qb3NpdGlvbi50b3AgLSB0cmVlUG9zaXRpb24udG9wO1xuICAgICAgfSBlbHNlIGlmIChkcm9wVHlwZSA9PT0gJ2FmdGVyJykge1xuICAgICAgICBpbmRpY2F0b3JUb3AgPSBpY29uUG9zaXRpb24uYm90dG9tIC0gdHJlZVBvc2l0aW9uLnRvcDtcbiAgICAgIH1cbiAgICAgIGRyb3BJbmRpY2F0b3Iuc3R5bGUudG9wID0gaW5kaWNhdG9yVG9wICsgJ3B4JztcbiAgICAgIGRyb3BJbmRpY2F0b3Iuc3R5bGUubGVmdCA9IGljb25Qb3NpdGlvbi5yaWdodCAtIHRyZWVQb3NpdGlvbi5sZWZ0ICsgJ3B4JztcblxuICAgICAgaWYgKGRyb3BUeXBlID09PSAnaW5uZXInKSB7XG4gICAgICAgIE9iamVjdChkb21fW1wiYWRkQ2xhc3NcIl0pKGRyb3BOb2RlLiRlbCwgJ2lzLWRyb3AtaW5uZXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdChkb21fW1wicmVtb3ZlQ2xhc3NcIl0pKGRyb3BOb2RlLiRlbCwgJ2lzLWRyb3AtaW5uZXInKTtcbiAgICAgIH1cblxuICAgICAgZHJhZ1N0YXRlLnNob3dEcm9wSW5kaWNhdG9yID0gZHJvcFR5cGUgPT09ICdiZWZvcmUnIHx8IGRyb3BUeXBlID09PSAnYWZ0ZXInO1xuICAgICAgZHJhZ1N0YXRlLmFsbG93RHJvcCA9IGRyYWdTdGF0ZS5zaG93RHJvcEluZGljYXRvciB8fCB1c2VyQWxsb3dEcm9wSW5uZXI7XG4gICAgICBkcmFnU3RhdGUuZHJvcFR5cGUgPSBkcm9wVHlwZTtcbiAgICAgIF90aGlzLiRlbWl0KCdub2RlLWRyYWctb3ZlcicsIGRyYWdnaW5nTm9kZS5ub2RlLCBkcm9wTm9kZS5ub2RlLCBldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLiRvbigndHJlZS1ub2RlLWRyYWctZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgZHJhZ2dpbmdOb2RlID0gZHJhZ1N0YXRlLmRyYWdnaW5nTm9kZSxcbiAgICAgICAgICBkcm9wVHlwZSA9IGRyYWdTdGF0ZS5kcm9wVHlwZSxcbiAgICAgICAgICBkcm9wTm9kZSA9IGRyYWdTdGF0ZS5kcm9wTm9kZTtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuXG4gICAgICBpZiAoZHJhZ2dpbmdOb2RlICYmIGRyb3BOb2RlKSB7XG4gICAgICAgIHZhciBkcmFnZ2luZ05vZGVDb3B5ID0geyBkYXRhOiBkcmFnZ2luZ05vZGUubm9kZS5kYXRhIH07XG4gICAgICAgIGlmIChkcm9wVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgZHJhZ2dpbmdOb2RlLm5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRyb3BUeXBlID09PSAnYmVmb3JlJykge1xuICAgICAgICAgIGRyb3BOb2RlLm5vZGUucGFyZW50Lmluc2VydEJlZm9yZShkcmFnZ2luZ05vZGVDb3B5LCBkcm9wTm9kZS5ub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkcm9wVHlwZSA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgIGRyb3BOb2RlLm5vZGUucGFyZW50Lmluc2VydEFmdGVyKGRyYWdnaW5nTm9kZUNvcHksIGRyb3BOb2RlLm5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGRyb3BUeXBlID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgZHJvcE5vZGUubm9kZS5pbnNlcnRDaGlsZChkcmFnZ2luZ05vZGVDb3B5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJvcFR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgIF90aGlzLnN0b3JlLnJlZ2lzdGVyTm9kZShkcmFnZ2luZ05vZGVDb3B5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdChkb21fW1wicmVtb3ZlQ2xhc3NcIl0pKGRyb3BOb2RlLiRlbCwgJ2lzLWRyb3AtaW5uZXInKTtcblxuICAgICAgICBfdGhpcy4kZW1pdCgnbm9kZS1kcmFnLWVuZCcsIGRyYWdnaW5nTm9kZS5ub2RlLCBkcm9wTm9kZS5ub2RlLCBkcm9wVHlwZSwgZXZlbnQpO1xuICAgICAgICBpZiAoZHJvcFR5cGUgIT09ICdub25lJykge1xuICAgICAgICAgIF90aGlzLiRlbWl0KCdub2RlLWRyb3AnLCBkcmFnZ2luZ05vZGUubm9kZSwgZHJvcE5vZGUubm9kZSwgZHJvcFR5cGUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRyYWdnaW5nTm9kZSAmJiAhZHJvcE5vZGUpIHtcbiAgICAgICAgX3RoaXMuJGVtaXQoJ25vZGUtZHJhZy1lbmQnLCBkcmFnZ2luZ05vZGUubm9kZSwgbnVsbCwgZHJvcFR5cGUsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgZHJhZ1N0YXRlLnNob3dEcm9wSW5kaWNhdG9yID0gZmFsc2U7XG4gICAgICBkcmFnU3RhdGUuZHJhZ2dpbmdOb2RlID0gbnVsbDtcbiAgICAgIGRyYWdTdGF0ZS5kcm9wTm9kZSA9IG51bGw7XG4gICAgICBkcmFnU3RhdGUuYWxsb3dEcm9wID0gdHJ1ZTtcbiAgICB9KTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLmluaXRUYWJJbmRleCgpO1xuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24pO1xuICB9LFxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgIHRoaXMudHJlZUl0ZW1zID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnW3JvbGU9dHJlZWl0ZW1dJyk7XG4gICAgdGhpcy5jaGVja2JveEl0ZW1zID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1jaGVja2JveF0nKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RyZWUvc3JjL3RyZWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY190cmVldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHRyZWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvdHJlZS9zcmMvdHJlZS52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciB0cmVlX2NvbXBvbmVudCA9IE9iamVjdChjb21wb25lbnROb3JtYWxpemVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShcbiAgc3JjX3RyZWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciB0cmVlX2FwaTsgfVxudHJlZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInBhY2thZ2VzL3RyZWUvc3JjL3RyZWUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyZWUgPSAodHJlZV9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RyZWUvaW5kZXguanNcblxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudHJlZS5pbnN0YWxsID0gZnVuY3Rpb24gKFZ1ZSkge1xuICBWdWUuY29tcG9uZW50KHRyZWUubmFtZSwgdHJlZSk7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwYWNrYWdlc190cmVlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAodHJlZSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy9tZXJnZVwiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/tree.js\n")}}]);