(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{157:function(module,exports,__webpack_require__){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 66);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n\n/***/ 1:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(76);\n\n/***/ }),\n\n/***/ 14:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(75);\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(58);\n\n/***/ }),\n\n/***/ 35:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(82);\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(30);\n\n/***/ }),\n\n/***/ 66:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/main.vue?vue&type=template&id=6d9756be&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"el-calendar\" }, [\n    _c(\"div\", { staticClass: \"el-calendar__header\" }, [\n      _c(\"div\", { staticClass: \"el-calendar__title\" }, [\n        _vm._v(\"\\n      \" + _vm._s(_vm.i18nDate) + \"\\n    \")\n      ]),\n      _vm.validatedRange.length === 0\n        ? _c(\n            \"div\",\n            { staticClass: \"el-calendar__button-group\" },\n            [\n              _c(\n                \"el-button-group\",\n                [\n                  _c(\n                    \"el-button\",\n                    {\n                      attrs: { type: \"plain\", size: \"mini\" },\n                      on: {\n                        click: function($event) {\n                          _vm.selectDate(\"prev-month\")\n                        }\n                      }\n                    },\n                    [\n                      _vm._v(\n                        \"\\n          \" +\n                          _vm._s(_vm.t(\"el.datepicker.prevMonth\")) +\n                          \"\\n        \"\n                      )\n                    ]\n                  ),\n                  _c(\n                    \"el-button\",\n                    {\n                      attrs: { type: \"plain\", size: \"mini\" },\n                      on: {\n                        click: function($event) {\n                          _vm.selectDate(\"today\")\n                        }\n                      }\n                    },\n                    [\n                      _vm._v(\n                        \"\\n          \" +\n                          _vm._s(_vm.t(\"el.datepicker.today\")) +\n                          \"\\n        \"\n                      )\n                    ]\n                  ),\n                  _c(\n                    \"el-button\",\n                    {\n                      attrs: { type: \"plain\", size: \"mini\" },\n                      on: {\n                        click: function($event) {\n                          _vm.selectDate(\"next-month\")\n                        }\n                      }\n                    },\n                    [\n                      _vm._v(\n                        \"\\n          \" +\n                          _vm._s(_vm.t(\"el.datepicker.nextMonth\")) +\n                          \"\\n        \"\n                      )\n                    ]\n                  )\n                ],\n                1\n              )\n            ],\n            1\n          )\n        : _vm._e()\n    ]),\n    _vm.validatedRange.length === 0\n      ? _c(\n          \"div\",\n          { key: \"no-range\", staticClass: \"el-calendar__body\" },\n          [\n            _c(\"date-table\", {\n              attrs: {\n                date: _vm.date,\n                \"selected-day\": _vm.realSelectedDay,\n                \"first-day-of-week\": _vm.realFirstDayOfWeek\n              },\n              on: { pick: _vm.pickDay }\n            })\n          ],\n          1\n        )\n      : _c(\n          \"div\",\n          { key: \"has-range\", staticClass: \"el-calendar__body\" },\n          _vm._l(_vm.validatedRange, function(range, index) {\n            return _c(\"date-table\", {\n              key: index,\n              attrs: {\n                date: range[0],\n                \"selected-day\": _vm.realSelectedDay,\n                range: range,\n                \"hide-header\": index !== 0,\n                \"first-day-of-week\": _vm.realFirstDayOfWeek\n              },\n              on: { pick: _vm.pickDay }\n            })\n          }),\n          1\n        )\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/calendar/src/main.vue?vue&type=template&id=6d9756be&\n\n// EXTERNAL MODULE: external \"element-ui/lib/mixins/locale\"\nvar locale_ = __webpack_require__(6);\nvar locale_default = /*#__PURE__*/__webpack_require__.n(locale_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/utils/date\"\nvar date_ = __webpack_require__(24);\nvar date_default = /*#__PURE__*/__webpack_require__.n(date_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/button\"\nvar button_ = __webpack_require__(14);\nvar button_default = /*#__PURE__*/__webpack_require__.n(button_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/button-group\"\nvar button_group_ = __webpack_require__(35);\nvar button_group_default = /*#__PURE__*/__webpack_require__.n(button_group_);\n\n// EXTERNAL MODULE: external \"element-ui/lib/utils/date-util\"\nvar date_util_ = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/date-table.vue?vue&type=script&lang=js&\n\n\n\n\n/* harmony default export */ var date_tablevue_type_script_lang_js_ = ({\n  props: {\n    selectedDay: String, // formated date yyyy-MM-dd\n    range: {\n      type: Array,\n      validator: function validator(val) {\n        if (!(val && val.length)) return true;\n        var start = val[0],\n            end = val[1];\n\n        return Object(date_util_[\"validateRangeInOneMonth\"])(start, end);\n      }\n    },\n    date: Date,\n    hideHeader: Boolean,\n    firstDayOfWeek: Number\n  },\n\n  inject: ['elCalendar'],\n\n  methods: {\n    toNestedArr: function toNestedArr(days) {\n      return Object(date_util_[\"range\"])(days.length / 7).map(function (_, index) {\n        var start = index * 7;\n        return days.slice(start, start + 7);\n      });\n    },\n    getFormateDate: function getFormateDate(day, type) {\n      if (!day || ['prev', 'current', 'next'].indexOf(type) === -1) {\n        throw new Error('invalid day or type');\n      }\n      var prefix = this.curMonthDatePrefix;\n      if (type === 'prev') {\n        prefix = this.prevMonthDatePrefix;\n      } else if (type === 'next') {\n        prefix = this.nextMonthDatePrefix;\n      }\n      day = ('00' + day).slice(-2);\n      return prefix + '-' + day;\n    },\n    getCellClass: function getCellClass(_ref) {\n      var text = _ref.text,\n          type = _ref.type;\n\n      var classes = [type];\n      if (type === 'current') {\n        var date = this.getFormateDate(text, type);\n        if (date === this.selectedDay) {\n          classes.push('is-selected');\n        }\n        if (date === this.formatedToday) {\n          classes.push('is-today');\n        }\n      }\n      return classes;\n    },\n    pickDay: function pickDay(_ref2) {\n      var text = _ref2.text,\n          type = _ref2.type;\n\n      var date = this.getFormateDate(text, type);\n      this.$emit('pick', date);\n    },\n    cellRenderProxy: function cellRenderProxy(_ref3) {\n      var text = _ref3.text,\n          type = _ref3.type;\n      var h = this.$createElement;\n\n      var render = this.elCalendar.$scopedSlots.dateCell;\n      if (!render) return h('span', [text]);\n\n      var day = this.getFormateDate(text, type);\n      var date = new Date(day);\n      var data = {\n        isSelected: this.selectedDay === day,\n        type: type + '-month',\n        day: day\n      };\n      return render({ date: date, data: data });\n    }\n  },\n\n  computed: {\n    WEEK_DAYS: function WEEK_DAYS() {\n      return Object(date_util_[\"getI18nSettings\"])().dayNames;\n    },\n    prevMonthDatePrefix: function prevMonthDatePrefix() {\n      var temp = new Date(this.date.getTime());\n      temp.setDate(0);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    curMonthDatePrefix: function curMonthDatePrefix() {\n      return date_default.a.format(this.date, 'yyyy-MM');\n    },\n    nextMonthDatePrefix: function nextMonthDatePrefix() {\n      var temp = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 1);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    formatedToday: function formatedToday() {\n      return this.elCalendar.formatedToday;\n    },\n    isInRange: function isInRange() {\n      return this.range && this.range.length;\n    },\n    rows: function rows() {\n      var days = [];\n      // if range exists, should render days in range.\n      if (this.isInRange) {\n        var _range = this.range,\n            start = _range[0],\n            end = _range[1];\n\n        var currentMonthRange = Object(date_util_[\"range\"])(end.getDate() - start.getDate() + 1).map(function (_, index) {\n          return {\n            text: start.getDate() + index,\n            type: 'current'\n          };\n        });\n        var remaining = currentMonthRange.length % 7;\n        remaining = remaining === 0 ? 0 : 7 - remaining;\n        var nextMonthRange = Object(date_util_[\"range\"])(remaining).map(function (_, index) {\n          return {\n            text: index + 1,\n            type: 'next'\n          };\n        });\n        days = currentMonthRange.concat(nextMonthRange);\n      } else {\n        var date = this.date;\n        var firstDay = Object(date_util_[\"getFirstDayOfMonth\"])(date);\n        firstDay = firstDay === 0 ? 7 : firstDay;\n        var firstDayOfWeek = typeof this.firstDayOfWeek === 'number' ? this.firstDayOfWeek : 1;\n        var prevMonthDays = Object(date_util_[\"getPrevMonthLastDays\"])(date, firstDay - firstDayOfWeek).map(function (day) {\n          return {\n            text: day,\n            type: 'prev'\n          };\n        });\n        var currentMonthDays = Object(date_util_[\"getMonthDays\"])(date).map(function (day) {\n          return {\n            text: day,\n            type: 'current'\n          };\n        });\n        days = [].concat(prevMonthDays, currentMonthDays);\n        var nextMonthDays = Object(date_util_[\"range\"])(42 - days.length).map(function (_, index) {\n          return {\n            text: index + 1,\n            type: 'next'\n          };\n        });\n        days = days.concat(nextMonthDays);\n      }\n      return this.toNestedArr(days);\n    },\n    weekDays: function weekDays() {\n      var start = this.firstDayOfWeek;\n      var WEEK_DAYS = this.WEEK_DAYS;\n\n\n      if (typeof start !== 'number' || start === 0) {\n        return WEEK_DAYS.slice();\n      } else {\n        return WEEK_DAYS.slice(start).concat(WEEK_DAYS.slice(0, start));\n      }\n    }\n  },\n\n  render: function render() {\n    var _this = this;\n\n    var h = arguments[0];\n\n    var thead = this.hideHeader ? null : h('thead', [this.weekDays.map(function (day) {\n      return h(\n        'th',\n        { key: day },\n        [day]\n      );\n    })]);\n    return h(\n      'table',\n      {\n        'class': {\n          'el-calendar-table': true,\n          'is-range': this.isInRange\n        },\n        attrs: { cellspacing: '0',\n          cellpadding: '0' }\n      },\n      [thead, h('tbody', [this.rows.map(function (row, index) {\n        return h(\n          'tr',\n          {\n            'class': {\n              'el-calendar-table__row': true,\n              'el-calendar-table__row--hide-border': index === 0 && _this.hideHeader\n            },\n            key: index },\n          [row.map(function (cell, key) {\n            return h(\n              'td',\n              { key: key,\n                'class': _this.getCellClass(cell),\n                on: {\n                  'click': _this.pickDay.bind(_this, cell)\n                }\n              },\n              [h(\n                'div',\n                { 'class': 'el-calendar-day' },\n                [_this.cellRenderProxy(cell)]\n              )]\n            );\n          })]\n        );\n      })])]\n    );\n  }\n});\n// CONCATENATED MODULE: ./packages/calendar/src/date-table.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_date_tablevue_type_script_lang_js_ = (date_tablevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/calendar/src/date-table.vue\nvar date_table_render, date_table_staticRenderFns\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  src_date_tablevue_type_script_lang_js_,\n  date_table_render,\n  date_table_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"packages/calendar/src/date-table.vue\"\n/* harmony default export */ var date_table = (component.exports);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/calendar/src/main.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\nvar validTypes = ['prev-month', 'today', 'next-month'];\nvar weekDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nvar oneDay = 86400000;\n\n/* harmony default export */ var mainvue_type_script_lang_js_ = ({\n  name: 'ElCalendar',\n\n  mixins: [locale_default.a],\n\n  components: {\n    DateTable: date_table,\n    ElButton: button_default.a,\n    ElButtonGroup: button_group_default.a\n  },\n\n  props: {\n    value: [Date, String, Number],\n    range: {\n      type: Array,\n      validator: function validator(range) {\n        if (Array.isArray(range)) {\n          return range.length === 2 && range.every(function (item) {\n            return typeof item === 'string' || typeof item === 'number' || item instanceof Date;\n          });\n        } else {\n          return true;\n        }\n      }\n    },\n    firstDayOfWeek: {\n      type: Number,\n      default: 1\n    }\n  },\n\n  provide: function provide() {\n    return {\n      elCalendar: this\n    };\n  },\n\n\n  methods: {\n    pickDay: function pickDay(day) {\n      this.realSelectedDay = day;\n    },\n    selectDate: function selectDate(type) {\n      if (validTypes.indexOf(type) === -1) {\n        throw new Error('invalid type ' + type);\n      }\n      var day = '';\n      if (type === 'prev-month') {\n        day = this.prevMonthDatePrefix + '-01';\n      } else if (type === 'next-month') {\n        day = this.nextMonthDatePrefix + '-01';\n      } else {\n        day = this.formatedToday;\n      }\n\n      if (day === this.formatedDate) return;\n      this.pickDay(day);\n    },\n    toDate: function toDate(val) {\n      if (!val) {\n        throw new Error('invalid val');\n      }\n      return val instanceof Date ? val : new Date(val);\n    },\n    rangeValidator: function rangeValidator(date, isStart) {\n      var firstDayOfWeek = this.realFirstDayOfWeek;\n      var expected = isStart ? firstDayOfWeek : firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;\n      var message = (isStart ? 'start' : 'end') + ' of range should be ' + weekDays[expected] + '.';\n      if (date.getDay() !== expected) {\n        console.warn('[ElementCalendar]', message, 'Invalid range will be ignored.');\n        return false;\n      }\n      return true;\n    }\n  },\n\n  computed: {\n    prevMonthDatePrefix: function prevMonthDatePrefix() {\n      var temp = new Date(this.date.getTime());\n      temp.setDate(0);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    curMonthDatePrefix: function curMonthDatePrefix() {\n      return date_default.a.format(this.date, 'yyyy-MM');\n    },\n    nextMonthDatePrefix: function nextMonthDatePrefix() {\n      var temp = new Date(this.date.getFullYear(), this.date.getMonth() + 1, 1);\n      return date_default.a.format(temp, 'yyyy-MM');\n    },\n    formatedDate: function formatedDate() {\n      return date_default.a.format(this.date, 'yyyy-MM-dd');\n    },\n    i18nDate: function i18nDate() {\n      var year = this.date.getFullYear();\n      var month = this.date.getMonth() + 1;\n      return year + ' ' + this.t('el.datepicker.year') + ' ' + this.t('el.datepicker.month' + month);\n    },\n    formatedToday: function formatedToday() {\n      return date_default.a.format(this.now, 'yyyy-MM-dd');\n    },\n\n\n    realSelectedDay: {\n      get: function get() {\n        if (!this.value) return this.selectedDay;\n        return this.formatedDate;\n      },\n      set: function set(val) {\n        this.selectedDay = val;\n        var date = new Date(val);\n        this.$emit('input', date);\n      }\n    },\n\n    date: function date() {\n      if (!this.value) {\n        if (this.realSelectedDay) {\n          var d = this.selectedDay.split('-');\n          return new Date(d[0], d[1] - 1, d[2]);\n        } else if (this.validatedRange.length) {\n          return this.validatedRange[0][0];\n        }\n        return this.now;\n      } else {\n        return this.toDate(this.value);\n      }\n    },\n\n\n    // if range is valid, we get a two-digit array\n    validatedRange: function validatedRange() {\n      var _this = this;\n\n      var range = this.range;\n      if (!range) return [];\n      range = range.reduce(function (prev, val, index) {\n        var date = _this.toDate(val);\n        if (_this.rangeValidator(date, index === 0)) {\n          prev = prev.concat(date);\n        }\n        return prev;\n      }, []);\n      if (range.length === 2) {\n        var _range = range,\n            start = _range[0],\n            end = _range[1];\n\n        if (start > end) {\n          console.warn('[ElementCalendar]end time should be greater than start time');\n          return [];\n        }\n        // start time and end time in one month\n        if (Object(date_util_[\"validateRangeInOneMonth\"])(start, end)) {\n          return [[start, end]];\n        }\n        var data = [];\n        var startDay = new Date(start.getFullYear(), start.getMonth() + 1, 1);\n        var lastDay = this.toDate(startDay.getTime() - oneDay);\n        if (!Object(date_util_[\"validateRangeInOneMonth\"])(startDay, end)) {\n          console.warn('[ElementCalendar]start time and end time interval must not exceed two months');\n          return [];\n        }\n        // 第一个月的时间范围\n        data.push([start, lastDay]);\n        // 下一月的时间范围，需要计算一下该月的第一个周起始日\n        var firstDayOfWeek = this.realFirstDayOfWeek;\n        var nextMontFirstDay = startDay.getDay();\n        var interval = 0;\n        if (nextMontFirstDay !== firstDayOfWeek) {\n          if (firstDayOfWeek === 0) {\n            interval = 7 - nextMontFirstDay;\n          } else {\n            interval = firstDayOfWeek - nextMontFirstDay;\n            interval = interval > 0 ? interval : 7 + interval;\n          }\n        }\n        startDay = this.toDate(startDay.getTime() + interval * oneDay);\n        if (startDay.getDate() < end.getDate()) {\n          data.push([startDay, end]);\n        }\n        return data;\n      }\n      return [];\n    },\n    realFirstDayOfWeek: function realFirstDayOfWeek() {\n      if (this.firstDayOfWeek < 1 || this.firstDayOfWeek > 6) {\n        return 0;\n      }\n      return Math.floor(this.firstDayOfWeek);\n    }\n  },\n\n  data: function data() {\n    return {\n      selectedDay: '',\n      now: new Date()\n    };\n  }\n});\n// CONCATENATED MODULE: ./packages/calendar/src/main.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_mainvue_type_script_lang_js_ = (mainvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/calendar/src/main.vue\n\n\n\n\n\n/* normalize component */\n\nvar main_component = Object(componentNormalizer[\"a\" /* default */])(\n  src_mainvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var main_api; }\nmain_component.options.__file = \"packages/calendar/src/main.vue\"\n/* harmony default export */ var main = (main_component.exports);\n// CONCATENATED MODULE: ./packages/calendar/index.js\n\n\n/* istanbul ignore next */\nmain.install = function (Vue) {\n  Vue.component(main.name, main);\n};\n\n/* harmony default export */ var calendar = __webpack_exports__[\"default\"] = (main);\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvY2FsZW5kYXIuanM/ZTM2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRiwyQkFBMkIsRUFBRTtBQUN4SDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvRztBQUNBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQLFVBQVUiLCJmaWxlIjoiMTU3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0L1wiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2Nik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIDA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWxpemVDb21wb25lbnQ7IH0pO1xuLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChyZW5kZXIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSAnZGF0YS12LScgKyBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCB0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvdXRpbHMvZGF0ZS11dGlsXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL2J1dHRvblwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDI0OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy9kYXRlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMzU6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL2J1dHRvbi1ncm91cFwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDY6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL21peGlucy9sb2NhbGVcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Njpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvY2FsZW5kYXIvc3JjL21haW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZkOTc1NmJlJlxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImVsLWNhbGVuZGFyXCIgfSwgW1xuICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtY2FsZW5kYXJfX2hlYWRlclwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtY2FsZW5kYXJfX3RpdGxlXCIgfSwgW1xuICAgICAgICBfdm0uX3YoXCJcXG4gICAgICBcIiArIF92bS5fcyhfdm0uaTE4bkRhdGUpICsgXCJcXG4gICAgXCIpXG4gICAgICBdKSxcbiAgICAgIF92bS52YWxpZGF0ZWRSYW5nZS5sZW5ndGggPT09IDBcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImVsLWNhbGVuZGFyX19idXR0b24tZ3JvdXBcIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImVsLWJ1dHRvbi1ncm91cFwiLFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICBcImVsLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJwbGFpblwiLCBzaXplOiBcIm1pbmlcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5zZWxlY3REYXRlKFwicHJldi1tb250aFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS50KFwiZWwuZGF0ZXBpY2tlci5wcmV2TW9udGhcIikpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwiZWwtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcInBsYWluXCIsIHNpemU6IFwibWluaVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnNlbGVjdERhdGUoXCJ0b2RheVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS50KFwiZWwuZGF0ZXBpY2tlci50b2RheVwiKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJlbC1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwicGxhaW5cIiwgc2l6ZTogXCJtaW5pXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2VsZWN0RGF0ZShcIm5leHQtbW9udGhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udChcImVsLmRhdGVwaWNrZXIubmV4dE1vbnRoXCIpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKVxuICAgIF0pLFxuICAgIF92bS52YWxpZGF0ZWRSYW5nZS5sZW5ndGggPT09IDBcbiAgICAgID8gX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7IGtleTogXCJuby1yYW5nZVwiLCBzdGF0aWNDbGFzczogXCJlbC1jYWxlbmRhcl9fYm9keVwiIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXCJkYXRlLXRhYmxlXCIsIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBkYXRlOiBfdm0uZGF0ZSxcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkLWRheVwiOiBfdm0ucmVhbFNlbGVjdGVkRGF5LFxuICAgICAgICAgICAgICAgIFwiZmlyc3QtZGF5LW9mLXdlZWtcIjogX3ZtLnJlYWxGaXJzdERheU9mV2Vla1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjogeyBwaWNrOiBfdm0ucGlja0RheSB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF0sXG4gICAgICAgICAgMVxuICAgICAgICApXG4gICAgICA6IF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgeyBrZXk6IFwiaGFzLXJhbmdlXCIsIHN0YXRpY0NsYXNzOiBcImVsLWNhbGVuZGFyX19ib2R5XCIgfSxcbiAgICAgICAgICBfdm0uX2woX3ZtLnZhbGlkYXRlZFJhbmdlLCBmdW5jdGlvbihyYW5nZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBfYyhcImRhdGUtdGFibGVcIiwge1xuICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgIGRhdGU6IHJhbmdlWzBdLFxuICAgICAgICAgICAgICAgIFwic2VsZWN0ZWQtZGF5XCI6IF92bS5yZWFsU2VsZWN0ZWREYXksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgIFwiaGlkZS1oZWFkZXJcIjogaW5kZXggIT09IDAsXG4gICAgICAgICAgICAgICAgXCJmaXJzdC1kYXktb2Ytd2Vla1wiOiBfdm0ucmVhbEZpcnN0RGF5T2ZXZWVrXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uOiB7IHBpY2s6IF92bS5waWNrRGF5IH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksXG4gICAgICAgICAgMVxuICAgICAgICApXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvY2FsZW5kYXIvc3JjL21haW4udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZkOTc1NmJlJlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvbWl4aW5zL2xvY2FsZVwiXG52YXIgbG9jYWxlXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgbG9jYWxlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvY2FsZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvdXRpbHMvZGF0ZVwiXG52YXIgZGF0ZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbnZhciBkYXRlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGRhdGVfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL2J1dHRvblwiXG52YXIgYnV0dG9uXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIGJ1dHRvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihidXR0b25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL2J1dHRvbi1ncm91cFwiXG52YXIgYnV0dG9uX2dyb3VwXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xudmFyIGJ1dHRvbl9ncm91cF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihidXR0b25fZ3JvdXBfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL3V0aWxzL2RhdGUtdXRpbFwiXG52YXIgZGF0ZV91dGlsXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2NhbGVuZGFyL3NyYy9kYXRlLXRhYmxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIHByb3BzOiB7XG4gICAgc2VsZWN0ZWREYXk6IFN0cmluZywgLy8gZm9ybWF0ZWQgZGF0ZSB5eXl5LU1NLWRkXG4gICAgcmFuZ2U6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IodmFsKSB7XG4gICAgICAgIGlmICghKHZhbCAmJiB2YWwubGVuZ3RoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBzdGFydCA9IHZhbFswXSxcbiAgICAgICAgICAgIGVuZCA9IHZhbFsxXTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJ2YWxpZGF0ZVJhbmdlSW5PbmVNb250aFwiXSkoc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRlOiBEYXRlLFxuICAgIGhpZGVIZWFkZXI6IEJvb2xlYW4sXG4gICAgZmlyc3REYXlPZldlZWs6IE51bWJlclxuICB9LFxuXG4gIGluamVjdDogWydlbENhbGVuZGFyJ10sXG5cbiAgbWV0aG9kczoge1xuICAgIHRvTmVzdGVkQXJyOiBmdW5jdGlvbiB0b05lc3RlZEFycihkYXlzKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJyYW5nZVwiXSkoZGF5cy5sZW5ndGggLyA3KS5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgIHZhciBzdGFydCA9IGluZGV4ICogNztcbiAgICAgICAgcmV0dXJuIGRheXMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgNyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEZvcm1hdGVEYXRlOiBmdW5jdGlvbiBnZXRGb3JtYXRlRGF0ZShkYXksIHR5cGUpIHtcbiAgICAgIGlmICghZGF5IHx8IFsncHJldicsICdjdXJyZW50JywgJ25leHQnXS5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF5IG9yIHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmVmaXggPSB0aGlzLmN1ck1vbnRoRGF0ZVByZWZpeDtcbiAgICAgIGlmICh0eXBlID09PSAncHJldicpIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5wcmV2TW9udGhEYXRlUHJlZml4O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmV4dCcpIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5uZXh0TW9udGhEYXRlUHJlZml4O1xuICAgICAgfVxuICAgICAgZGF5ID0gKCcwMCcgKyBkYXkpLnNsaWNlKC0yKTtcbiAgICAgIHJldHVybiBwcmVmaXggKyAnLScgKyBkYXk7XG4gICAgfSxcbiAgICBnZXRDZWxsQ2xhc3M6IGZ1bmN0aW9uIGdldENlbGxDbGFzcyhfcmVmKSB7XG4gICAgICB2YXIgdGV4dCA9IF9yZWYudGV4dCxcbiAgICAgICAgICB0eXBlID0gX3JlZi50eXBlO1xuXG4gICAgICB2YXIgY2xhc3NlcyA9IFt0eXBlXTtcbiAgICAgIGlmICh0eXBlID09PSAnY3VycmVudCcpIHtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldEZvcm1hdGVEYXRlKHRleHQsIHR5cGUpO1xuICAgICAgICBpZiAoZGF0ZSA9PT0gdGhpcy5zZWxlY3RlZERheSkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaCgnaXMtc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZSA9PT0gdGhpcy5mb3JtYXRlZFRvZGF5KSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKCdpcy10b2RheScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9LFxuICAgIHBpY2tEYXk6IGZ1bmN0aW9uIHBpY2tEYXkoX3JlZjIpIHtcbiAgICAgIHZhciB0ZXh0ID0gX3JlZjIudGV4dCxcbiAgICAgICAgICB0eXBlID0gX3JlZjIudHlwZTtcblxuICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldEZvcm1hdGVEYXRlKHRleHQsIHR5cGUpO1xuICAgICAgdGhpcy4kZW1pdCgncGljaycsIGRhdGUpO1xuICAgIH0sXG4gICAgY2VsbFJlbmRlclByb3h5OiBmdW5jdGlvbiBjZWxsUmVuZGVyUHJveHkoX3JlZjMpIHtcbiAgICAgIHZhciB0ZXh0ID0gX3JlZjMudGV4dCxcbiAgICAgICAgICB0eXBlID0gX3JlZjMudHlwZTtcbiAgICAgIHZhciBoID0gdGhpcy4kY3JlYXRlRWxlbWVudDtcblxuICAgICAgdmFyIHJlbmRlciA9IHRoaXMuZWxDYWxlbmRhci4kc2NvcGVkU2xvdHMuZGF0ZUNlbGw7XG4gICAgICBpZiAoIXJlbmRlcikgcmV0dXJuIGgoJ3NwYW4nLCBbdGV4dF0pO1xuXG4gICAgICB2YXIgZGF5ID0gdGhpcy5nZXRGb3JtYXRlRGF0ZSh0ZXh0LCB0eXBlKTtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoZGF5KTtcbiAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICBpc1NlbGVjdGVkOiB0aGlzLnNlbGVjdGVkRGF5ID09PSBkYXksXG4gICAgICAgIHR5cGU6IHR5cGUgKyAnLW1vbnRoJyxcbiAgICAgICAgZGF5OiBkYXlcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVuZGVyKHsgZGF0ZTogZGF0ZSwgZGF0YTogZGF0YSB9KTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBXRUVLX0RBWVM6IGZ1bmN0aW9uIFdFRUtfREFZUygpIHtcbiAgICAgIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImdldEkxOG5TZXR0aW5nc1wiXSkoKS5kYXlOYW1lcztcbiAgICB9LFxuICAgIHByZXZNb250aERhdGVQcmVmaXg6IGZ1bmN0aW9uIHByZXZNb250aERhdGVQcmVmaXgoKSB7XG4gICAgICB2YXIgdGVtcCA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgdGVtcC5zZXREYXRlKDApO1xuICAgICAgcmV0dXJuIGRhdGVfZGVmYXVsdC5hLmZvcm1hdCh0ZW1wLCAneXl5eS1NTScpO1xuICAgIH0sXG4gICAgY3VyTW9udGhEYXRlUHJlZml4OiBmdW5jdGlvbiBjdXJNb250aERhdGVQcmVmaXgoKSB7XG4gICAgICByZXR1cm4gZGF0ZV9kZWZhdWx0LmEuZm9ybWF0KHRoaXMuZGF0ZSwgJ3l5eXktTU0nKTtcbiAgICB9LFxuICAgIG5leHRNb250aERhdGVQcmVmaXg6IGZ1bmN0aW9uIG5leHRNb250aERhdGVQcmVmaXgoKSB7XG4gICAgICB2YXIgdGVtcCA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmRhdGUuZ2V0TW9udGgoKSArIDEsIDEpO1xuICAgICAgcmV0dXJuIGRhdGVfZGVmYXVsdC5hLmZvcm1hdCh0ZW1wLCAneXl5eS1NTScpO1xuICAgIH0sXG4gICAgZm9ybWF0ZWRUb2RheTogZnVuY3Rpb24gZm9ybWF0ZWRUb2RheSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsQ2FsZW5kYXIuZm9ybWF0ZWRUb2RheTtcbiAgICB9LFxuICAgIGlzSW5SYW5nZTogZnVuY3Rpb24gaXNJblJhbmdlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFuZ2UgJiYgdGhpcy5yYW5nZS5sZW5ndGg7XG4gICAgfSxcbiAgICByb3dzOiBmdW5jdGlvbiByb3dzKCkge1xuICAgICAgdmFyIGRheXMgPSBbXTtcbiAgICAgIC8vIGlmIHJhbmdlIGV4aXN0cywgc2hvdWxkIHJlbmRlciBkYXlzIGluIHJhbmdlLlxuICAgICAgaWYgKHRoaXMuaXNJblJhbmdlKSB7XG4gICAgICAgIHZhciBfcmFuZ2UgPSB0aGlzLnJhbmdlLFxuICAgICAgICAgICAgc3RhcnQgPSBfcmFuZ2VbMF0sXG4gICAgICAgICAgICBlbmQgPSBfcmFuZ2VbMV07XG5cbiAgICAgICAgdmFyIGN1cnJlbnRNb250aFJhbmdlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJyYW5nZVwiXSkoZW5kLmdldERhdGUoKSAtIHN0YXJ0LmdldERhdGUoKSArIDEpLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogc3RhcnQuZ2V0RGF0ZSgpICsgaW5kZXgsXG4gICAgICAgICAgICB0eXBlOiAnY3VycmVudCdcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGN1cnJlbnRNb250aFJhbmdlLmxlbmd0aCAlIDc7XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZyA9PT0gMCA/IDAgOiA3IC0gcmVtYWluaW5nO1xuICAgICAgICB2YXIgbmV4dE1vbnRoUmFuZ2UgPSBPYmplY3QoZGF0ZV91dGlsX1tcInJhbmdlXCJdKShyZW1haW5pbmcpLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogaW5kZXggKyAxLFxuICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRheXMgPSBjdXJyZW50TW9udGhSYW5nZS5jb25jYXQobmV4dE1vbnRoUmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmRhdGU7XG4gICAgICAgIHZhciBmaXJzdERheSA9IE9iamVjdChkYXRlX3V0aWxfW1wiZ2V0Rmlyc3REYXlPZk1vbnRoXCJdKShkYXRlKTtcbiAgICAgICAgZmlyc3REYXkgPSBmaXJzdERheSA9PT0gMCA/IDcgOiBmaXJzdERheTtcbiAgICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gdHlwZW9mIHRoaXMuZmlyc3REYXlPZldlZWsgPT09ICdudW1iZXInID8gdGhpcy5maXJzdERheU9mV2VlayA6IDE7XG4gICAgICAgIHZhciBwcmV2TW9udGhEYXlzID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJnZXRQcmV2TW9udGhMYXN0RGF5c1wiXSkoZGF0ZSwgZmlyc3REYXkgLSBmaXJzdERheU9mV2VlaykubWFwKGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZGF5LFxuICAgICAgICAgICAgdHlwZTogJ3ByZXYnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjdXJyZW50TW9udGhEYXlzID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJnZXRNb250aERheXNcIl0pKGRhdGUpLm1hcChmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRheSxcbiAgICAgICAgICAgIHR5cGU6ICdjdXJyZW50J1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkYXlzID0gW10uY29uY2F0KHByZXZNb250aERheXMsIGN1cnJlbnRNb250aERheXMpO1xuICAgICAgICB2YXIgbmV4dE1vbnRoRGF5cyA9IE9iamVjdChkYXRlX3V0aWxfW1wicmFuZ2VcIl0pKDQyIC0gZGF5cy5sZW5ndGgpLm1hcChmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogaW5kZXggKyAxLFxuICAgICAgICAgICAgdHlwZTogJ25leHQnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRheXMgPSBkYXlzLmNvbmNhdChuZXh0TW9udGhEYXlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRvTmVzdGVkQXJyKGRheXMpO1xuICAgIH0sXG4gICAgd2Vla0RheXM6IGZ1bmN0aW9uIHdlZWtEYXlzKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5maXJzdERheU9mV2VlaztcbiAgICAgIHZhciBXRUVLX0RBWVMgPSB0aGlzLldFRUtfREFZUztcblxuXG4gICAgICBpZiAodHlwZW9mIHN0YXJ0ICE9PSAnbnVtYmVyJyB8fCBzdGFydCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gV0VFS19EQVlTLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gV0VFS19EQVlTLnNsaWNlKHN0YXJ0KS5jb25jYXQoV0VFS19EQVlTLnNsaWNlKDAsIHN0YXJ0KSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgaCA9IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciB0aGVhZCA9IHRoaXMuaGlkZUhlYWRlciA/IG51bGwgOiBoKCd0aGVhZCcsIFt0aGlzLndlZWtEYXlzLm1hcChmdW5jdGlvbiAoZGF5KSB7XG4gICAgICByZXR1cm4gaChcbiAgICAgICAgJ3RoJyxcbiAgICAgICAgeyBrZXk6IGRheSB9LFxuICAgICAgICBbZGF5XVxuICAgICAgKTtcbiAgICB9KV0pO1xuICAgIHJldHVybiBoKFxuICAgICAgJ3RhYmxlJyxcbiAgICAgIHtcbiAgICAgICAgJ2NsYXNzJzoge1xuICAgICAgICAgICdlbC1jYWxlbmRhci10YWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2lzLXJhbmdlJzogdGhpcy5pc0luUmFuZ2VcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cnM6IHsgY2VsbHNwYWNpbmc6ICcwJyxcbiAgICAgICAgICBjZWxscGFkZGluZzogJzAnIH1cbiAgICAgIH0sXG4gICAgICBbdGhlYWQsIGgoJ3Rib2R5JywgW3RoaXMucm93cy5tYXAoZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGgoXG4gICAgICAgICAgJ3RyJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAnY2xhc3MnOiB7XG4gICAgICAgICAgICAgICdlbC1jYWxlbmRhci10YWJsZV9fcm93JzogdHJ1ZSxcbiAgICAgICAgICAgICAgJ2VsLWNhbGVuZGFyLXRhYmxlX19yb3ctLWhpZGUtYm9yZGVyJzogaW5kZXggPT09IDAgJiYgX3RoaXMuaGlkZUhlYWRlclxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleTogaW5kZXggfSxcbiAgICAgICAgICBbcm93Lm1hcChmdW5jdGlvbiAoY2VsbCwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gaChcbiAgICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgICAgeyBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiBfdGhpcy5nZXRDZWxsQ2xhc3MoY2VsbCksXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICdjbGljayc6IF90aGlzLnBpY2tEYXkuYmluZChfdGhpcywgY2VsbClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtoKFxuICAgICAgICAgICAgICAgICdkaXYnLFxuICAgICAgICAgICAgICAgIHsgJ2NsYXNzJzogJ2VsLWNhbGVuZGFyLWRheScgfSxcbiAgICAgICAgICAgICAgICBbX3RoaXMuY2VsbFJlbmRlclByb3h5KGNlbGwpXVxuICAgICAgICAgICAgICApXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KV1cbiAgICAgICAgKTtcbiAgICAgIH0pXSldXG4gICAgKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2NhbGVuZGFyL3NyYy9kYXRlLXRhYmxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChkYXRlX3RhYmxldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xudmFyIGNvbXBvbmVudE5vcm1hbGl6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2NhbGVuZGFyL3NyYy9kYXRlLXRhYmxlLnZ1ZVxudmFyIGRhdGVfdGFibGVfcmVuZGVyLCBkYXRlX3RhYmxlX3N0YXRpY1JlbmRlckZuc1xuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBjb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIHNyY19kYXRlX3RhYmxldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBkYXRlX3RhYmxlX3JlbmRlcixcbiAgZGF0ZV90YWJsZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWNrYWdlcy9jYWxlbmRhci9zcmMvZGF0ZS10YWJsZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGF0ZV90YWJsZSA9IChjb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9jYWxlbmRhci9zcmMvbWFpbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuXG5cbnZhciB2YWxpZFR5cGVzID0gWydwcmV2LW1vbnRoJywgJ3RvZGF5JywgJ25leHQtbW9udGgnXTtcbnZhciB3ZWVrRGF5cyA9IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXTtcbnZhciBvbmVEYXkgPSA4NjQwMDAwMDtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbWFpbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdFbENhbGVuZGFyJyxcblxuICBtaXhpbnM6IFtsb2NhbGVfZGVmYXVsdC5hXSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgRGF0ZVRhYmxlOiBkYXRlX3RhYmxlLFxuICAgIEVsQnV0dG9uOiBidXR0b25fZGVmYXVsdC5hLFxuICAgIEVsQnV0dG9uR3JvdXA6IGJ1dHRvbl9ncm91cF9kZWZhdWx0LmFcbiAgfSxcblxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbRGF0ZSwgU3RyaW5nLCBOdW1iZXJdLFxuICAgIHJhbmdlOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHJhbmdlKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhbmdlKSkge1xuICAgICAgICAgIHJldHVybiByYW5nZS5sZW5ndGggPT09IDIgJiYgcmFuZ2UuZXZlcnkoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInIHx8IGl0ZW0gaW5zdGFuY2VvZiBEYXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmaXJzdERheU9mV2Vlazoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMVxuICAgIH1cbiAgfSxcblxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlbENhbGVuZGFyOiB0aGlzXG4gICAgfTtcbiAgfSxcblxuXG4gIG1ldGhvZHM6IHtcbiAgICBwaWNrRGF5OiBmdW5jdGlvbiBwaWNrRGF5KGRheSkge1xuICAgICAgdGhpcy5yZWFsU2VsZWN0ZWREYXkgPSBkYXk7XG4gICAgfSxcbiAgICBzZWxlY3REYXRlOiBmdW5jdGlvbiBzZWxlY3REYXRlKHR5cGUpIHtcbiAgICAgIGlmICh2YWxpZFR5cGVzLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlICcgKyB0eXBlKTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXkgPSAnJztcbiAgICAgIGlmICh0eXBlID09PSAncHJldi1tb250aCcpIHtcbiAgICAgICAgZGF5ID0gdGhpcy5wcmV2TW9udGhEYXRlUHJlZml4ICsgJy0wMSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduZXh0LW1vbnRoJykge1xuICAgICAgICBkYXkgPSB0aGlzLm5leHRNb250aERhdGVQcmVmaXggKyAnLTAxJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRheSA9IHRoaXMuZm9ybWF0ZWRUb2RheTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRheSA9PT0gdGhpcy5mb3JtYXRlZERhdGUpIHJldHVybjtcbiAgICAgIHRoaXMucGlja0RheShkYXkpO1xuICAgIH0sXG4gICAgdG9EYXRlOiBmdW5jdGlvbiB0b0RhdGUodmFsKSB7XG4gICAgICBpZiAoIXZhbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgRGF0ZSA/IHZhbCA6IG5ldyBEYXRlKHZhbCk7XG4gICAgfSxcbiAgICByYW5nZVZhbGlkYXRvcjogZnVuY3Rpb24gcmFuZ2VWYWxpZGF0b3IoZGF0ZSwgaXNTdGFydCkge1xuICAgICAgdmFyIGZpcnN0RGF5T2ZXZWVrID0gdGhpcy5yZWFsRmlyc3REYXlPZldlZWs7XG4gICAgICB2YXIgZXhwZWN0ZWQgPSBpc1N0YXJ0ID8gZmlyc3REYXlPZldlZWsgOiBmaXJzdERheU9mV2VlayA9PT0gMCA/IDYgOiBmaXJzdERheU9mV2VlayAtIDE7XG4gICAgICB2YXIgbWVzc2FnZSA9IChpc1N0YXJ0ID8gJ3N0YXJ0JyA6ICdlbmQnKSArICcgb2YgcmFuZ2Ugc2hvdWxkIGJlICcgKyB3ZWVrRGF5c1tleHBlY3RlZF0gKyAnLic7XG4gICAgICBpZiAoZGF0ZS5nZXREYXkoKSAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbRWxlbWVudENhbGVuZGFyXScsIG1lc3NhZ2UsICdJbnZhbGlkIHJhbmdlIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgcHJldk1vbnRoRGF0ZVByZWZpeDogZnVuY3Rpb24gcHJldk1vbnRoRGF0ZVByZWZpeCgpIHtcbiAgICAgIHZhciB0ZW1wID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgICB0ZW1wLnNldERhdGUoMCk7XG4gICAgICByZXR1cm4gZGF0ZV9kZWZhdWx0LmEuZm9ybWF0KHRlbXAsICd5eXl5LU1NJyk7XG4gICAgfSxcbiAgICBjdXJNb250aERhdGVQcmVmaXg6IGZ1bmN0aW9uIGN1ck1vbnRoRGF0ZVByZWZpeCgpIHtcbiAgICAgIHJldHVybiBkYXRlX2RlZmF1bHQuYS5mb3JtYXQodGhpcy5kYXRlLCAneXl5eS1NTScpO1xuICAgIH0sXG4gICAgbmV4dE1vbnRoRGF0ZVByZWZpeDogZnVuY3Rpb24gbmV4dE1vbnRoRGF0ZVByZWZpeCgpIHtcbiAgICAgIHZhciB0ZW1wID0gbmV3IERhdGUodGhpcy5kYXRlLmdldEZ1bGxZZWFyKCksIHRoaXMuZGF0ZS5nZXRNb250aCgpICsgMSwgMSk7XG4gICAgICByZXR1cm4gZGF0ZV9kZWZhdWx0LmEuZm9ybWF0KHRlbXAsICd5eXl5LU1NJyk7XG4gICAgfSxcbiAgICBmb3JtYXRlZERhdGU6IGZ1bmN0aW9uIGZvcm1hdGVkRGF0ZSgpIHtcbiAgICAgIHJldHVybiBkYXRlX2RlZmF1bHQuYS5mb3JtYXQodGhpcy5kYXRlLCAneXl5eS1NTS1kZCcpO1xuICAgIH0sXG4gICAgaTE4bkRhdGU6IGZ1bmN0aW9uIGkxOG5EYXRlKCkge1xuICAgICAgdmFyIHllYXIgPSB0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHZhciBtb250aCA9IHRoaXMuZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgIHJldHVybiB5ZWFyICsgJyAnICsgdGhpcy50KCdlbC5kYXRlcGlja2VyLnllYXInKSArICcgJyArIHRoaXMudCgnZWwuZGF0ZXBpY2tlci5tb250aCcgKyBtb250aCk7XG4gICAgfSxcbiAgICBmb3JtYXRlZFRvZGF5OiBmdW5jdGlvbiBmb3JtYXRlZFRvZGF5KCkge1xuICAgICAgcmV0dXJuIGRhdGVfZGVmYXVsdC5hLmZvcm1hdCh0aGlzLm5vdywgJ3l5eXktTU0tZGQnKTtcbiAgICB9LFxuXG5cbiAgICByZWFsU2VsZWN0ZWREYXk6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsdWUpIHJldHVybiB0aGlzLnNlbGVjdGVkRGF5O1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRlZERhdGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXkgPSB2YWw7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUodmFsKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBkYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGF0ZTogZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5yZWFsU2VsZWN0ZWREYXkpIHtcbiAgICAgICAgICB2YXIgZCA9IHRoaXMuc2VsZWN0ZWREYXkuc3BsaXQoJy0nKTtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZFswXSwgZFsxXSAtIDEsIGRbMl0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmFsaWRhdGVkUmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVkUmFuZ2VbMF1bMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKHRoaXMudmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIGlmIHJhbmdlIGlzIHZhbGlkLCB3ZSBnZXQgYSB0d28tZGlnaXQgYXJyYXlcbiAgICB2YWxpZGF0ZWRSYW5nZTogZnVuY3Rpb24gdmFsaWRhdGVkUmFuZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgICAgaWYgKCFyYW5nZSkgcmV0dXJuIFtdO1xuICAgICAgcmFuZ2UgPSByYW5nZS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHZhbCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBfdGhpcy50b0RhdGUodmFsKTtcbiAgICAgICAgaWYgKF90aGlzLnJhbmdlVmFsaWRhdG9yKGRhdGUsIGluZGV4ID09PSAwKSkge1xuICAgICAgICAgIHByZXYgPSBwcmV2LmNvbmNhdChkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIFtdKTtcbiAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIF9yYW5nZSA9IHJhbmdlLFxuICAgICAgICAgICAgc3RhcnQgPSBfcmFuZ2VbMF0sXG4gICAgICAgICAgICBlbmQgPSBfcmFuZ2VbMV07XG5cbiAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbRWxlbWVudENhbGVuZGFyXWVuZCB0aW1lIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gc3RhcnQgdGltZScpO1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydCB0aW1lIGFuZCBlbmQgdGltZSBpbiBvbmUgbW9udGhcbiAgICAgICAgaWYgKE9iamVjdChkYXRlX3V0aWxfW1widmFsaWRhdGVSYW5nZUluT25lTW9udGhcIl0pKHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgcmV0dXJuIFtbc3RhcnQsIGVuZF1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIHZhciBzdGFydERheSA9IG5ldyBEYXRlKHN0YXJ0LmdldEZ1bGxZZWFyKCksIHN0YXJ0LmdldE1vbnRoKCkgKyAxLCAxKTtcbiAgICAgICAgdmFyIGxhc3REYXkgPSB0aGlzLnRvRGF0ZShzdGFydERheS5nZXRUaW1lKCkgLSBvbmVEYXkpO1xuICAgICAgICBpZiAoIU9iamVjdChkYXRlX3V0aWxfW1widmFsaWRhdGVSYW5nZUluT25lTW9udGhcIl0pKHN0YXJ0RGF5LCBlbmQpKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbRWxlbWVudENhbGVuZGFyXXN0YXJ0IHRpbWUgYW5kIGVuZCB0aW1lIGludGVydmFsIG11c3Qgbm90IGV4Y2VlZCB0d28gbW9udGhzJyk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIOesrOS4gOS4quaciOeahOaXtumXtOiMg+WbtFxuICAgICAgICBkYXRhLnB1c2goW3N0YXJ0LCBsYXN0RGF5XSk7XG4gICAgICAgIC8vIOS4i+S4gOaciOeahOaXtumXtOiMg+WbtO+8jOmcgOimgeiuoeeul+S4gOS4i+ivpeaciOeahOesrOS4gOS4quWRqOi1t+Wni+aXpVxuICAgICAgICB2YXIgZmlyc3REYXlPZldlZWsgPSB0aGlzLnJlYWxGaXJzdERheU9mV2VlaztcbiAgICAgICAgdmFyIG5leHRNb250Rmlyc3REYXkgPSBzdGFydERheS5nZXREYXkoKTtcbiAgICAgICAgdmFyIGludGVydmFsID0gMDtcbiAgICAgICAgaWYgKG5leHRNb250Rmlyc3REYXkgIT09IGZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrID09PSAwKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IDcgLSBuZXh0TW9udEZpcnN0RGF5O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnZhbCA9IGZpcnN0RGF5T2ZXZWVrIC0gbmV4dE1vbnRGaXJzdERheTtcbiAgICAgICAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgPiAwID8gaW50ZXJ2YWwgOiA3ICsgaW50ZXJ2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0RGF5ID0gdGhpcy50b0RhdGUoc3RhcnREYXkuZ2V0VGltZSgpICsgaW50ZXJ2YWwgKiBvbmVEYXkpO1xuICAgICAgICBpZiAoc3RhcnREYXkuZ2V0RGF0ZSgpIDwgZW5kLmdldERhdGUoKSkge1xuICAgICAgICAgIGRhdGEucHVzaChbc3RhcnREYXksIGVuZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgcmVhbEZpcnN0RGF5T2ZXZWVrOiBmdW5jdGlvbiByZWFsRmlyc3REYXlPZldlZWsoKSB7XG4gICAgICBpZiAodGhpcy5maXJzdERheU9mV2VlayA8IDEgfHwgdGhpcy5maXJzdERheU9mV2VlayA+IDYpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmZpcnN0RGF5T2ZXZWVrKTtcbiAgICB9XG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWREYXk6ICcnLFxuICAgICAgbm93OiBuZXcgRGF0ZSgpXG4gICAgfTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2NhbGVuZGFyL3NyYy9tYWluLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfbWFpbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChtYWludnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2NhbGVuZGFyL3NyYy9tYWluLnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIG1haW5fY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBzcmNfbWFpbnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIG1haW5fYXBpOyB9XG5tYWluX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFja2FnZXMvY2FsZW5kYXIvc3JjL21haW4udnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1haW4gPSAobWFpbl9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2NhbGVuZGFyL2luZGV4LmpzXG5cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbm1haW4uaW5zdGFsbCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgVnVlLmNvbXBvbmVudChtYWluLm5hbWUsIG1haW4pO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2FsZW5kYXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChtYWluKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///157\n")}}]);