(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{168:function(module,exports,__webpack_require__){eval('module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === \'object\' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, \'default\', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != \'string\') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "/dist/";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 55);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === \'function\'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = \'data-v-\' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== \'undefined\') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn\'t\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(76);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(5);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(3);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(7);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(20);\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(30);\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(0);\n\n/***/ }),\n/* 8 */,\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(21);\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(31);\n\n/***/ }),\n/* 11 */,\n/* 12 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(53);\n\n/***/ }),\n/* 13 */,\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(75);\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(32);\n\n/***/ }),\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time.vue?vue&type=template&id=3d939089&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "transition",\n    {\n      attrs: { name: "el-zoom-in-top" },\n      on: {\n        "after-leave": function($event) {\n          _vm.$emit("dodestroy")\n        }\n      }\n    },\n    [\n      _c(\n        "div",\n        {\n          directives: [\n            {\n              name: "show",\n              rawName: "v-show",\n              value: _vm.visible,\n              expression: "visible"\n            }\n          ],\n          staticClass: "el-time-panel el-popper",\n          class: _vm.popperClass\n        },\n        [\n          _c(\n            "div",\n            {\n              staticClass: "el-time-panel__content",\n              class: { "has-seconds": _vm.showSeconds }\n            },\n            [\n              _c("time-spinner", {\n                ref: "spinner",\n                attrs: {\n                  "arrow-control": _vm.useArrow,\n                  "show-seconds": _vm.showSeconds,\n                  "am-pm-mode": _vm.amPmMode,\n                  date: _vm.date\n                },\n                on: {\n                  change: _vm.handleChange,\n                  "select-range": _vm.setSelectionRange\n                }\n              })\n            ],\n            1\n          ),\n          _c("div", { staticClass: "el-time-panel__footer" }, [\n            _c(\n              "button",\n              {\n                staticClass: "el-time-panel__btn cancel",\n                attrs: { type: "button" },\n                on: { click: _vm.handleCancel }\n              },\n              [_vm._v(_vm._s(_vm.t("el.datepicker.cancel")))]\n            ),\n            _c(\n              "button",\n              {\n                staticClass: "el-time-panel__btn",\n                class: { confirm: !_vm.disabled },\n                attrs: { type: "button" },\n                on: {\n                  click: function($event) {\n                    _vm.handleConfirm()\n                  }\n                }\n              },\n              [_vm._v(_vm._s(_vm.t("el.datepicker.confirm")))]\n            )\n          ])\n        ]\n      )\n    ]\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue?vue&type=template&id=3d939089&\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/date-util"\nvar date_util_ = __webpack_require__(1);\n\n// EXTERNAL MODULE: external "element-ui/lib/mixins/locale"\nvar locale_ = __webpack_require__(6);\nvar locale_default = /*#__PURE__*/__webpack_require__.n(locale_);\n\n// EXTERNAL MODULE: ./packages/date-picker/src/basic/time-spinner.vue + 4 modules\nvar time_spinner = __webpack_require__(34);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/time.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ var timevue_type_script_lang_js_ = ({\n  mixins: [locale_default.a],\n\n  components: {\n    TimeSpinner: time_spinner["a" /* default */]\n  },\n\n  props: {\n    visible: Boolean,\n    timeArrowControl: Boolean\n  },\n\n  watch: {\n    visible: function visible(val) {\n      var _this = this;\n\n      if (val) {\n        this.oldValue = this.value;\n        this.$nextTick(function () {\n          return _this.$refs.spinner.emitSelectRange(\'hours\');\n        });\n      } else {\n        this.needInitAdjust = true;\n      }\n    },\n    value: function value(newVal) {\n      var _this2 = this;\n\n      var date = void 0;\n      if (newVal instanceof Date) {\n        date = Object(date_util_["limitTimeRange"])(newVal, this.selectableRange, this.format);\n      } else if (!newVal) {\n        date = this.defaultValue ? new Date(this.defaultValue) : new Date();\n      }\n\n      this.date = date;\n      if (this.visible && this.needInitAdjust) {\n        this.$nextTick(function (_) {\n          return _this2.adjustSpinners();\n        });\n        this.needInitAdjust = false;\n      }\n    },\n    selectableRange: function selectableRange(val) {\n      this.$refs.spinner.selectableRange = val;\n    },\n    defaultValue: function defaultValue(val) {\n      if (!Object(date_util_["isDate"])(this.value)) {\n        this.date = val ? new Date(val) : new Date();\n      }\n    }\n  },\n\n  data: function data() {\n    return {\n      popperClass: \'\',\n      format: \'HH:mm:ss\',\n      value: \'\',\n      defaultValue: null,\n      date: new Date(),\n      oldValue: new Date(),\n      selectableRange: [],\n      selectionRange: [0, 2],\n      disabled: false,\n      arrowControl: false,\n      needInitAdjust: true\n    };\n  },\n\n\n  computed: {\n    showSeconds: function showSeconds() {\n      return (this.format || \'\').indexOf(\'ss\') !== -1;\n    },\n    useArrow: function useArrow() {\n      return this.arrowControl || this.timeArrowControl || false;\n    },\n    amPmMode: function amPmMode() {\n      if ((this.format || \'\').indexOf(\'A\') !== -1) return \'A\';\n      if ((this.format || \'\').indexOf(\'a\') !== -1) return \'a\';\n      return \'\';\n    }\n  },\n\n  methods: {\n    handleCancel: function handleCancel() {\n      this.$emit(\'pick\', this.oldValue, false);\n    },\n    handleChange: function handleChange(date) {\n      // this.visible avoids edge cases, when use scrolls during panel closing animation\n      if (this.visible) {\n        this.date = Object(date_util_["clearMilliseconds"])(date);\n        // if date is out of range, do not emit\n        if (this.isValidValue(this.date)) {\n          this.$emit(\'pick\', this.date, true);\n        }\n      }\n    },\n    setSelectionRange: function setSelectionRange(start, end) {\n      this.$emit(\'select-range\', start, end);\n      this.selectionRange = [start, end];\n    },\n    handleConfirm: function handleConfirm() {\n      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var first = arguments[1];\n\n      if (first) return;\n      var date = Object(date_util_["clearMilliseconds"])(Object(date_util_["limitTimeRange"])(this.date, this.selectableRange, this.format));\n      this.$emit(\'pick\', date, visible, first);\n    },\n    handleKeydown: function handleKeydown(event) {\n      var keyCode = event.keyCode;\n      var mapping = { 38: -1, 40: 1, 37: -1, 39: 1 };\n\n      // Left or Right\n      if (keyCode === 37 || keyCode === 39) {\n        var step = mapping[keyCode];\n        this.changeSelectionRange(step);\n        event.preventDefault();\n        return;\n      }\n\n      // Up or Down\n      if (keyCode === 38 || keyCode === 40) {\n        var _step = mapping[keyCode];\n        this.$refs.spinner.scrollDown(_step);\n        event.preventDefault();\n        return;\n      }\n    },\n    isValidValue: function isValidValue(date) {\n      return Object(date_util_["timeWithinRange"])(date, this.selectableRange, this.format);\n    },\n    adjustSpinners: function adjustSpinners() {\n      return this.$refs.spinner.adjustSpinners();\n    },\n    changeSelectionRange: function changeSelectionRange(step) {\n      var list = [0, 3].concat(this.showSeconds ? [6] : []);\n      var mapping = [\'hours\', \'minutes\'].concat(this.showSeconds ? [\'seconds\'] : []);\n      var index = list.indexOf(this.selectionRange[0]);\n      var next = (index + step + list.length) % list.length;\n      this.$refs.spinner.emitSelectRange(mapping[next]);\n    }\n  },\n\n  mounted: function mounted() {\n    var _this3 = this;\n\n    this.$nextTick(function () {\n      return _this3.handleConfirm(true, true);\n    });\n    this.$emit(\'mounted\');\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue?vue&type=script&lang=js&\n /* harmony default export */ var panel_timevue_type_script_lang_js_ = (timevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/time.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  panel_timevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "packages/date-picker/src/panel/time.vue"\n/* harmony default export */ var time = __webpack_exports__["a"] = (component.exports);\n\n/***/ }),\n/* 28 */,\n/* 29 */,\n/* 30 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n/* harmony import */ var element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/* harmony default export */ __webpack_exports__["a"] = ({\n  bind: function bind(el, binding, vnode) {\n    var interval = null;\n    var startTime = void 0;\n    var handler = function handler() {\n      return vnode.context[binding.expression].apply();\n    };\n    var clear = function clear() {\n      if (Date.now() - startTime < 100) {\n        handler();\n      }\n      clearInterval(interval);\n      interval = null;\n    };\n\n    Object(element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__["on"])(el, \'mousedown\', function (e) {\n      if (e.button !== 0) return;\n      startTime = Date.now();\n      Object(element_ui_src_utils_dom__WEBPACK_IMPORTED_MODULE_0__["once"])(document, \'mouseup\', clear);\n      clearInterval(interval);\n      interval = setInterval(handler, 100);\n    });\n  }\n});\n\n/***/ }),\n/* 31 */,\n/* 32 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/picker.vue?vue&type=template&id=79ae069f&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return !_vm.ranged\n    ? _c(\n        "el-input",\n        _vm._b(\n          {\n            directives: [\n              {\n                name: "clickoutside",\n                rawName: "v-clickoutside",\n                value: _vm.handleClose,\n                expression: "handleClose"\n              }\n            ],\n            ref: "reference",\n            staticClass: "el-date-editor",\n            class: "el-date-editor--" + _vm.type,\n            attrs: {\n              readonly:\n                !_vm.editable ||\n                _vm.readonly ||\n                _vm.type === "dates" ||\n                _vm.type === "week",\n              disabled: _vm.pickerDisabled,\n              size: _vm.pickerSize,\n              name: _vm.name,\n              placeholder: _vm.placeholder,\n              value: _vm.displayValue,\n              validateEvent: false\n            },\n            on: {\n              focus: _vm.handleFocus,\n              input: function(value) {\n                return (_vm.userInput = value)\n              },\n              change: _vm.handleChange\n            },\n            nativeOn: {\n              keydown: function($event) {\n                return _vm.handleKeydown($event)\n              },\n              mouseenter: function($event) {\n                return _vm.handleMouseEnter($event)\n              },\n              mouseleave: function($event) {\n                _vm.showClose = false\n              }\n            }\n          },\n          "el-input",\n          _vm.firstInputId,\n          false\n        ),\n        [\n          _c("i", {\n            staticClass: "el-input__icon",\n            class: _vm.triggerClass,\n            attrs: { slot: "prefix" },\n            on: { click: _vm.handleFocus },\n            slot: "prefix"\n          }),\n          _vm.haveTrigger\n            ? _c("i", {\n                staticClass: "el-input__icon",\n                class: [_vm.showClose ? "" + _vm.clearIcon : ""],\n                attrs: { slot: "suffix" },\n                on: { click: _vm.handleClickIcon },\n                slot: "suffix"\n              })\n            : _vm._e()\n        ]\n      )\n    : _c(\n        "div",\n        {\n          directives: [\n            {\n              name: "clickoutside",\n              rawName: "v-clickoutside",\n              value: _vm.handleClose,\n              expression: "handleClose"\n            }\n          ],\n          ref: "reference",\n          staticClass: "el-date-editor el-range-editor el-input__inner",\n          class: [\n            "el-date-editor--" + _vm.type,\n            _vm.pickerSize ? "el-range-editor--" + _vm.pickerSize : "",\n            _vm.pickerDisabled ? "is-disabled" : "",\n            _vm.pickerVisible ? "is-active" : ""\n          ],\n          on: {\n            click: _vm.handleRangeClick,\n            mouseenter: _vm.handleMouseEnter,\n            mouseleave: function($event) {\n              _vm.showClose = false\n            },\n            keydown: _vm.handleKeydown\n          }\n        },\n        [\n          _c("i", {\n            class: ["el-input__icon", "el-range__icon", _vm.triggerClass]\n          }),\n          _c(\n            "input",\n            _vm._b(\n              {\n                staticClass: "el-range-input",\n                attrs: {\n                  autocomplete: "off",\n                  placeholder: _vm.startPlaceholder,\n                  disabled: _vm.pickerDisabled,\n                  readonly: !_vm.editable || _vm.readonly,\n                  name: _vm.name && _vm.name[0]\n                },\n                domProps: { value: _vm.displayValue && _vm.displayValue[0] },\n                on: {\n                  input: _vm.handleStartInput,\n                  change: _vm.handleStartChange,\n                  focus: _vm.handleFocus\n                }\n              },\n              "input",\n              _vm.firstInputId,\n              false\n            )\n          ),\n          _vm._t("range-separator", [\n            _c("span", { staticClass: "el-range-separator" }, [\n              _vm._v(_vm._s(_vm.rangeSeparator))\n            ])\n          ]),\n          _c(\n            "input",\n            _vm._b(\n              {\n                staticClass: "el-range-input",\n                attrs: {\n                  autocomplete: "off",\n                  placeholder: _vm.endPlaceholder,\n                  disabled: _vm.pickerDisabled,\n                  readonly: !_vm.editable || _vm.readonly,\n                  name: _vm.name && _vm.name[1]\n                },\n                domProps: { value: _vm.displayValue && _vm.displayValue[1] },\n                on: {\n                  input: _vm.handleEndInput,\n                  change: _vm.handleEndChange,\n                  focus: _vm.handleFocus\n                }\n              },\n              "input",\n              _vm.secondInputId,\n              false\n            )\n          ),\n          _vm.haveTrigger\n            ? _c("i", {\n                staticClass: "el-input__icon el-range__close-icon",\n                class: [_vm.showClose ? "" + _vm.clearIcon : ""],\n                on: { click: _vm.handleClickIcon }\n              })\n            : _vm._e()\n        ],\n        2\n      )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/picker.vue?vue&type=template&id=79ae069f&\n\n// EXTERNAL MODULE: external "vue"\nvar external_vue_ = __webpack_require__(7);\nvar external_vue_default = /*#__PURE__*/__webpack_require__.n(external_vue_);\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/clickoutside"\nvar clickoutside_ = __webpack_require__(12);\nvar clickoutside_default = /*#__PURE__*/__webpack_require__.n(clickoutside_);\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/date-util"\nvar date_util_ = __webpack_require__(1);\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/vue-popper"\nvar vue_popper_ = __webpack_require__(5);\nvar vue_popper_default = /*#__PURE__*/__webpack_require__.n(vue_popper_);\n\n// EXTERNAL MODULE: external "element-ui/lib/mixins/emitter"\nvar emitter_ = __webpack_require__(4);\nvar emitter_default = /*#__PURE__*/__webpack_require__.n(emitter_);\n\n// EXTERNAL MODULE: external "element-ui/lib/input"\nvar input_ = __webpack_require__(10);\nvar input_default = /*#__PURE__*/__webpack_require__.n(input_);\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/merge"\nvar merge_ = __webpack_require__(9);\nvar merge_default = /*#__PURE__*/__webpack_require__.n(merge_);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/picker.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\nvar NewPopper = {\n  props: {\n    appendToBody: vue_popper_default.a.props.appendToBody,\n    offset: vue_popper_default.a.props.offset,\n    boundariesPadding: vue_popper_default.a.props.boundariesPadding,\n    arrowOffset: vue_popper_default.a.props.arrowOffset\n  },\n  methods: vue_popper_default.a.methods,\n  data: function data() {\n    return merge_default()({ visibleArrow: true }, vue_popper_default.a.data);\n  },\n\n  beforeDestroy: vue_popper_default.a.beforeDestroy\n};\n\nvar DEFAULT_FORMATS = {\n  date: \'yyyy-MM-dd\',\n  month: \'yyyy-MM\',\n  datetime: \'yyyy-MM-dd HH:mm:ss\',\n  time: \'HH:mm:ss\',\n  week: \'yyyywWW\',\n  timerange: \'HH:mm:ss\',\n  daterange: \'yyyy-MM-dd\',\n  monthrange: \'yyyy-MM\',\n  datetimerange: \'yyyy-MM-dd HH:mm:ss\',\n  year: \'yyyy\'\n};\nvar HAVE_TRIGGER_TYPES = [\'date\', \'datetime\', \'time\', \'time-select\', \'week\', \'month\', \'year\', \'daterange\', \'monthrange\', \'timerange\', \'datetimerange\', \'dates\'];\nvar pickervue_type_script_lang_js_DATE_FORMATTER = function DATE_FORMATTER(value, format) {\n  if (format === \'timestamp\') return value.getTime();\n  return Object(date_util_["formatDate"])(value, format);\n};\nvar pickervue_type_script_lang_js_DATE_PARSER = function DATE_PARSER(text, format) {\n  if (format === \'timestamp\') return new Date(Number(text));\n  return Object(date_util_["parseDate"])(text, format);\n};\nvar RANGE_FORMATTER = function RANGE_FORMATTER(value, format) {\n  if (Array.isArray(value) && value.length === 2) {\n    var start = value[0];\n    var end = value[1];\n\n    if (start && end) {\n      return [pickervue_type_script_lang_js_DATE_FORMATTER(start, format), pickervue_type_script_lang_js_DATE_FORMATTER(end, format)];\n    }\n  }\n  return \'\';\n};\nvar RANGE_PARSER = function RANGE_PARSER(array, format, separator) {\n  if (!Array.isArray(array)) {\n    array = array.split(separator);\n  }\n  if (array.length === 2) {\n    var range1 = array[0];\n    var range2 = array[1];\n\n    return [pickervue_type_script_lang_js_DATE_PARSER(range1, format), pickervue_type_script_lang_js_DATE_PARSER(range2, format)];\n  }\n  return [];\n};\nvar TYPE_VALUE_RESOLVER_MAP = {\n  default: {\n    formatter: function formatter(value) {\n      if (!value) return \'\';\n      return \'\' + value;\n    },\n    parser: function parser(text) {\n      if (text === undefined || text === \'\') return null;\n      return text;\n    }\n  },\n  week: {\n    formatter: function formatter(value, format) {\n      var week = Object(date_util_["getWeekNumber"])(value);\n      var month = value.getMonth();\n      var trueDate = new Date(value);\n      if (week === 1 && month === 11) {\n        trueDate.setHours(0, 0, 0, 0);\n        trueDate.setDate(trueDate.getDate() + 3 - (trueDate.getDay() + 6) % 7);\n      }\n      var date = Object(date_util_["formatDate"])(trueDate, format);\n\n      date = /WW/.test(date) ? date.replace(/WW/, week < 10 ? \'0\' + week : week) : date.replace(/W/, week);\n      return date;\n    },\n    parser: function parser(text, format) {\n      // parse as if a normal date\n      return TYPE_VALUE_RESOLVER_MAP.date.parser(text, format);\n    }\n  },\n  date: {\n    formatter: pickervue_type_script_lang_js_DATE_FORMATTER,\n    parser: pickervue_type_script_lang_js_DATE_PARSER\n  },\n  datetime: {\n    formatter: pickervue_type_script_lang_js_DATE_FORMATTER,\n    parser: pickervue_type_script_lang_js_DATE_PARSER\n  },\n  daterange: {\n    formatter: RANGE_FORMATTER,\n    parser: RANGE_PARSER\n  },\n  monthrange: {\n    formatter: RANGE_FORMATTER,\n    parser: RANGE_PARSER\n  },\n  datetimerange: {\n    formatter: RANGE_FORMATTER,\n    parser: RANGE_PARSER\n  },\n  timerange: {\n    formatter: RANGE_FORMATTER,\n    parser: RANGE_PARSER\n  },\n  time: {\n    formatter: pickervue_type_script_lang_js_DATE_FORMATTER,\n    parser: pickervue_type_script_lang_js_DATE_PARSER\n  },\n  month: {\n    formatter: pickervue_type_script_lang_js_DATE_FORMATTER,\n    parser: pickervue_type_script_lang_js_DATE_PARSER\n  },\n  year: {\n    formatter: pickervue_type_script_lang_js_DATE_FORMATTER,\n    parser: pickervue_type_script_lang_js_DATE_PARSER\n  },\n  number: {\n    formatter: function formatter(value) {\n      if (!value) return \'\';\n      return \'\' + value;\n    },\n    parser: function parser(text) {\n      var result = Number(text);\n\n      if (!isNaN(text)) {\n        return result;\n      } else {\n        return null;\n      }\n    }\n  },\n  dates: {\n    formatter: function formatter(value, format) {\n      return value.map(function (date) {\n        return pickervue_type_script_lang_js_DATE_FORMATTER(date, format);\n      });\n    },\n    parser: function parser(value, format) {\n      return (typeof value === \'string\' ? value.split(\', \') : value).map(function (date) {\n        return date instanceof Date ? date : pickervue_type_script_lang_js_DATE_PARSER(date, format);\n      });\n    }\n  }\n};\nvar PLACEMENT_MAP = {\n  left: \'bottom-start\',\n  center: \'bottom\',\n  right: \'bottom-end\'\n};\n\nvar parseAsFormatAndType = function parseAsFormatAndType(value, customFormat, type) {\n  var rangeSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \'-\';\n\n  if (!value) return null;\n  var parser = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP[\'default\']).parser;\n  var format = customFormat || DEFAULT_FORMATS[type];\n  return parser(value, format, rangeSeparator);\n};\n\nvar formatAsFormatAndType = function formatAsFormatAndType(value, customFormat, type) {\n  if (!value) return null;\n  var formatter = (TYPE_VALUE_RESOLVER_MAP[type] || TYPE_VALUE_RESOLVER_MAP[\'default\']).formatter;\n  var format = customFormat || DEFAULT_FORMATS[type];\n  return formatter(value, format);\n};\n\n/*\n * Considers:\n *   1. Date object\n *   2. date string\n *   3. array of 1 or 2\n */\nvar valueEquals = function valueEquals(a, b) {\n  // considers Date object and string\n  var dateEquals = function dateEquals(a, b) {\n    var aIsDate = a instanceof Date;\n    var bIsDate = b instanceof Date;\n    if (aIsDate && bIsDate) {\n      return a.getTime() === b.getTime();\n    }\n    if (!aIsDate && !bIsDate) {\n      return a === b;\n    }\n    return false;\n  };\n\n  var aIsArray = a instanceof Array;\n  var bIsArray = b instanceof Array;\n  if (aIsArray && bIsArray) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    return a.every(function (item, index) {\n      return dateEquals(item, b[index]);\n    });\n  }\n  if (!aIsArray && !bIsArray) {\n    return dateEquals(a, b);\n  }\n  return false;\n};\n\nvar isString = function isString(val) {\n  return typeof val === \'string\' || val instanceof String;\n};\n\nvar validator = function validator(val) {\n  // either: String, Array of String, null / undefined\n  return val === null || val === undefined || isString(val) || Array.isArray(val) && val.length === 2 && val.every(isString);\n};\n\n/* harmony default export */ var pickervue_type_script_lang_js_ = ({\n  mixins: [emitter_default.a, NewPopper],\n\n  inject: {\n    elForm: {\n      default: \'\'\n    },\n    elFormItem: {\n      default: \'\'\n    }\n  },\n\n  props: {\n    size: String,\n    format: String,\n    valueFormat: String,\n    readonly: Boolean,\n    placeholder: String,\n    startPlaceholder: String,\n    endPlaceholder: String,\n    prefixIcon: String,\n    clearIcon: {\n      type: String,\n      default: \'el-icon-circle-close\'\n    },\n    name: {\n      default: \'\',\n      validator: validator\n    },\n    disabled: Boolean,\n    clearable: {\n      type: Boolean,\n      default: true\n    },\n    id: {\n      default: \'\',\n      validator: validator\n    },\n    popperClass: String,\n    editable: {\n      type: Boolean,\n      default: true\n    },\n    align: {\n      type: String,\n      default: \'left\'\n    },\n    value: {},\n    defaultValue: {},\n    defaultTime: {},\n    rangeSeparator: {\n      default: \'-\'\n    },\n    pickerOptions: {},\n    unlinkPanels: Boolean,\n    validateEvent: {\n      type: Boolean,\n      default: true\n    }\n  },\n\n  components: { ElInput: input_default.a },\n\n  directives: { Clickoutside: clickoutside_default.a },\n\n  data: function data() {\n    return {\n      pickerVisible: false,\n      showClose: false,\n      userInput: null,\n      valueOnOpen: null, // value when picker opens, used to determine whether to emit change\n      unwatchPickerOptions: null\n    };\n  },\n\n\n  watch: {\n    pickerVisible: function pickerVisible(val) {\n      if (this.readonly || this.pickerDisabled) return;\n      if (val) {\n        this.showPicker();\n        this.valueOnOpen = Array.isArray(this.value) ? [].concat(this.value) : this.value;\n      } else {\n        this.hidePicker();\n        this.emitChange(this.value);\n        this.userInput = null;\n        if (this.validateEvent) {\n          this.dispatch(\'ElFormItem\', \'el.form.blur\');\n        }\n        this.$emit(\'blur\', this);\n        this.blur();\n      }\n    },\n\n    parsedValue: {\n      immediate: true,\n      handler: function handler(val) {\n        if (this.picker) {\n          this.picker.value = val;\n        }\n      }\n    },\n    defaultValue: function defaultValue(val) {\n      // NOTE: should eventually move to jsx style picker + panel ?\n      if (this.picker) {\n        this.picker.defaultValue = val;\n      }\n    },\n    value: function value(val, oldVal) {\n      if (!valueEquals(val, oldVal) && !this.pickerVisible && this.validateEvent) {\n        this.dispatch(\'ElFormItem\', \'el.form.change\', val);\n      }\n    }\n  },\n\n  computed: {\n    ranged: function ranged() {\n      return this.type.indexOf(\'range\') > -1;\n    },\n    reference: function reference() {\n      var reference = this.$refs.reference;\n      return reference.$el || reference;\n    },\n    refInput: function refInput() {\n      if (this.reference) {\n        return [].slice.call(this.reference.querySelectorAll(\'input\'));\n      }\n      return [];\n    },\n    valueIsEmpty: function valueIsEmpty() {\n      var val = this.value;\n      if (Array.isArray(val)) {\n        for (var i = 0, len = val.length; i < len; i++) {\n          if (val[i]) {\n            return false;\n          }\n        }\n      } else {\n        if (val) {\n          return false;\n        }\n      }\n      return true;\n    },\n    triggerClass: function triggerClass() {\n      return this.prefixIcon || (this.type.indexOf(\'time\') !== -1 ? \'el-icon-time\' : \'el-icon-date\');\n    },\n    selectionMode: function selectionMode() {\n      if (this.type === \'week\') {\n        return \'week\';\n      } else if (this.type === \'month\') {\n        return \'month\';\n      } else if (this.type === \'year\') {\n        return \'year\';\n      } else if (this.type === \'dates\') {\n        return \'dates\';\n      }\n\n      return \'day\';\n    },\n    haveTrigger: function haveTrigger() {\n      if (typeof this.showTrigger !== \'undefined\') {\n        return this.showTrigger;\n      }\n      return HAVE_TRIGGER_TYPES.indexOf(this.type) !== -1;\n    },\n    displayValue: function displayValue() {\n      var formattedValue = formatAsFormatAndType(this.parsedValue, this.format, this.type, this.rangeSeparator);\n      if (Array.isArray(this.userInput)) {\n        return [this.userInput[0] || formattedValue && formattedValue[0] || \'\', this.userInput[1] || formattedValue && formattedValue[1] || \'\'];\n      } else if (this.userInput !== null) {\n        return this.userInput;\n      } else if (formattedValue) {\n        return this.type === \'dates\' ? formattedValue.join(\', \') : formattedValue;\n      } else {\n        return \'\';\n      }\n    },\n    parsedValue: function parsedValue() {\n      if (!this.value) return this.value; // component value is not set\n      if (this.type === \'time-select\') return this.value; // time-select does not require parsing, this might change in next major version\n\n      var valueIsDateObject = Object(date_util_["isDateObject"])(this.value) || Array.isArray(this.value) && this.value.every(date_util_["isDateObject"]);\n      if (valueIsDateObject) {\n        return this.value;\n      }\n\n      if (this.valueFormat) {\n        return parseAsFormatAndType(this.value, this.valueFormat, this.type, this.rangeSeparator) || this.value;\n      }\n\n      // NOTE: deal with common but incorrect usage, should remove in next major version\n      // user might provide string / timestamp without value-format, coerce them into date (or array of date)\n      return Array.isArray(this.value) ? this.value.map(function (val) {\n        return new Date(val);\n      }) : new Date(this.value);\n    },\n    _elFormItemSize: function _elFormItemSize() {\n      return (this.elFormItem || {}).elFormItemSize;\n    },\n    pickerSize: function pickerSize() {\n      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;\n    },\n    pickerDisabled: function pickerDisabled() {\n      return this.disabled || (this.elForm || {}).disabled;\n    },\n    firstInputId: function firstInputId() {\n      var obj = {};\n      var id = void 0;\n      if (this.ranged) {\n        id = this.id && this.id[0];\n      } else {\n        id = this.id;\n      }\n      if (id) obj.id = id;\n      return obj;\n    },\n    secondInputId: function secondInputId() {\n      var obj = {};\n      var id = void 0;\n      if (this.ranged) {\n        id = this.id && this.id[1];\n      }\n      if (id) obj.id = id;\n      return obj;\n    }\n  },\n\n  created: function created() {\n    // vue-popper\n    this.popperOptions = {\n      boundariesPadding: 0,\n      gpuAcceleration: false\n    };\n    this.placement = PLACEMENT_MAP[this.align] || PLACEMENT_MAP.left;\n\n    this.$on(\'fieldReset\', this.handleFieldReset);\n  },\n\n\n  methods: {\n    focus: function focus() {\n      if (!this.ranged) {\n        this.$refs.reference.focus();\n      } else {\n        this.handleFocus();\n      }\n    },\n    blur: function blur() {\n      this.refInput.forEach(function (input) {\n        return input.blur();\n      });\n    },\n\n\n    // {parse, formatTo} Value deals maps component value with internal Date\n    parseValue: function parseValue(value) {\n      var isParsed = Object(date_util_["isDateObject"])(value) || Array.isArray(value) && value.every(date_util_["isDateObject"]);\n      if (this.valueFormat && !isParsed) {\n        return parseAsFormatAndType(value, this.valueFormat, this.type, this.rangeSeparator) || value;\n      } else {\n        return value;\n      }\n    },\n    formatToValue: function formatToValue(date) {\n      var isFormattable = Object(date_util_["isDateObject"])(date) || Array.isArray(date) && date.every(date_util_["isDateObject"]);\n      if (this.valueFormat && isFormattable) {\n        return formatAsFormatAndType(date, this.valueFormat, this.type, this.rangeSeparator);\n      } else {\n        return date;\n      }\n    },\n\n\n    // {parse, formatTo} String deals with user input\n    parseString: function parseString(value) {\n      var type = Array.isArray(value) ? this.type : this.type.replace(\'range\', \'\');\n      return parseAsFormatAndType(value, this.format, type);\n    },\n    formatToString: function formatToString(value) {\n      var type = Array.isArray(value) ? this.type : this.type.replace(\'range\', \'\');\n      return formatAsFormatAndType(value, this.format, type);\n    },\n    handleMouseEnter: function handleMouseEnter() {\n      if (this.readonly || this.pickerDisabled) return;\n      if (!this.valueIsEmpty && this.clearable) {\n        this.showClose = true;\n      }\n    },\n    handleChange: function handleChange() {\n      if (this.userInput) {\n        var value = this.parseString(this.displayValue);\n        if (value) {\n          this.picker.value = value;\n          if (this.isValidValue(value)) {\n            this.emitInput(value);\n            this.userInput = null;\n          }\n        }\n      }\n      if (this.userInput === \'\') {\n        this.emitInput(null);\n        this.emitChange(null);\n        this.userInput = null;\n      }\n    },\n    handleStartInput: function handleStartInput(event) {\n      if (this.userInput) {\n        this.userInput = [event.target.value, this.userInput[1]];\n      } else {\n        this.userInput = [event.target.value, null];\n      }\n    },\n    handleEndInput: function handleEndInput(event) {\n      if (this.userInput) {\n        this.userInput = [this.userInput[0], event.target.value];\n      } else {\n        this.userInput = [null, event.target.value];\n      }\n    },\n    handleStartChange: function handleStartChange(event) {\n      var value = this.parseString(this.userInput && this.userInput[0]);\n      if (value) {\n        this.userInput = [this.formatToString(value), this.displayValue[1]];\n        var newValue = [value, this.picker.value && this.picker.value[1]];\n        this.picker.value = newValue;\n        if (this.isValidValue(newValue)) {\n          this.emitInput(newValue);\n          this.userInput = null;\n        }\n      }\n    },\n    handleEndChange: function handleEndChange(event) {\n      var value = this.parseString(this.userInput && this.userInput[1]);\n      if (value) {\n        this.userInput = [this.displayValue[0], this.formatToString(value)];\n        var newValue = [this.picker.value && this.picker.value[0], value];\n        this.picker.value = newValue;\n        if (this.isValidValue(newValue)) {\n          this.emitInput(newValue);\n          this.userInput = null;\n        }\n      }\n    },\n    handleClickIcon: function handleClickIcon(event) {\n      if (this.readonly || this.pickerDisabled) return;\n      if (this.showClose) {\n        this.valueOnOpen = this.value;\n        event.stopPropagation();\n        this.emitInput(null);\n        this.emitChange(null);\n        this.showClose = false;\n        if (this.picker && typeof this.picker.handleClear === \'function\') {\n          this.picker.handleClear();\n        }\n      } else {\n        this.pickerVisible = !this.pickerVisible;\n      }\n    },\n    handleClose: function handleClose() {\n      if (!this.pickerVisible) return;\n      this.pickerVisible = false;\n\n      if (this.type === \'dates\') {\n        // restore to former value\n        var oldValue = parseAsFormatAndType(this.valueOnOpen, this.valueFormat, this.type, this.rangeSeparator) || this.valueOnOpen;\n        this.emitInput(oldValue);\n      }\n    },\n    handleFieldReset: function handleFieldReset(initialValue) {\n      this.userInput = initialValue === \'\' ? null : initialValue;\n    },\n    handleFocus: function handleFocus() {\n      var type = this.type;\n\n      if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {\n        this.pickerVisible = true;\n      }\n      this.$emit(\'focus\', this);\n    },\n    handleKeydown: function handleKeydown(event) {\n      var _this = this;\n\n      var keyCode = event.keyCode;\n\n      // ESC\n      if (keyCode === 27) {\n        this.pickerVisible = false;\n        event.stopPropagation();\n        return;\n      }\n\n      // Tab\n      if (keyCode === 9) {\n        if (!this.ranged) {\n          this.handleChange();\n          this.pickerVisible = this.picker.visible = false;\n          this.blur();\n          event.stopPropagation();\n        } else {\n          // user may change focus between two input\n          setTimeout(function () {\n            if (_this.refInput.indexOf(document.activeElement) === -1) {\n              _this.pickerVisible = false;\n              _this.blur();\n              event.stopPropagation();\n            }\n          }, 0);\n        }\n        return;\n      }\n\n      // Enter\n      if (keyCode === 13) {\n        if (this.userInput === \'\' || this.isValidValue(this.parseString(this.displayValue))) {\n          this.handleChange();\n          this.pickerVisible = this.picker.visible = false;\n          this.blur();\n        }\n        event.stopPropagation();\n        return;\n      }\n\n      // if user is typing, do not let picker handle key input\n      if (this.userInput) {\n        event.stopPropagation();\n        return;\n      }\n\n      // delegate other keys to panel\n      if (this.picker && this.picker.handleKeydown) {\n        this.picker.handleKeydown(event);\n      }\n    },\n    handleRangeClick: function handleRangeClick() {\n      var type = this.type;\n\n      if (HAVE_TRIGGER_TYPES.indexOf(type) !== -1 && !this.pickerVisible) {\n        this.pickerVisible = true;\n      }\n      this.$emit(\'focus\', this);\n    },\n    hidePicker: function hidePicker() {\n      if (this.picker) {\n        this.picker.resetView && this.picker.resetView();\n        this.pickerVisible = this.picker.visible = false;\n        this.destroyPopper();\n      }\n    },\n    showPicker: function showPicker() {\n      var _this2 = this;\n\n      if (this.$isServer) return;\n      if (!this.picker) {\n        this.mountPicker();\n      }\n      this.pickerVisible = this.picker.visible = true;\n\n      this.updatePopper();\n\n      this.picker.value = this.parsedValue;\n      this.picker.resetView && this.picker.resetView();\n\n      this.$nextTick(function () {\n        _this2.picker.adjustSpinners && _this2.picker.adjustSpinners();\n      });\n    },\n    mountPicker: function mountPicker() {\n      var _this3 = this;\n\n      this.picker = new external_vue_default.a(this.panel).$mount();\n      this.picker.defaultValue = this.defaultValue;\n      this.picker.defaultTime = this.defaultTime;\n      this.picker.popperClass = this.popperClass;\n      this.popperElm = this.picker.$el;\n      this.picker.width = this.reference.getBoundingClientRect().width;\n      this.picker.showTime = this.type === \'datetime\' || this.type === \'datetimerange\';\n      this.picker.selectionMode = this.selectionMode;\n      this.picker.unlinkPanels = this.unlinkPanels;\n      this.picker.arrowControl = this.arrowControl || this.timeArrowControl || false;\n      this.$watch(\'format\', function (format) {\n        _this3.picker.format = format;\n      });\n\n      var updateOptions = function updateOptions() {\n        var options = _this3.pickerOptions;\n\n        if (options && options.selectableRange) {\n          var ranges = options.selectableRange;\n          var parser = TYPE_VALUE_RESOLVER_MAP.datetimerange.parser;\n          var format = DEFAULT_FORMATS.timerange;\n\n          ranges = Array.isArray(ranges) ? ranges : [ranges];\n          _this3.picker.selectableRange = ranges.map(function (range) {\n            return parser(range, format, _this3.rangeSeparator);\n          });\n        }\n\n        for (var option in options) {\n          if (options.hasOwnProperty(option) &&\n          // 忽略 time-picker 的该配置项\n          option !== \'selectableRange\') {\n            _this3.picker[option] = options[option];\n          }\n        }\n\n        // main format must prevail over undocumented pickerOptions.format\n        if (_this3.format) {\n          _this3.picker.format = _this3.format;\n        }\n      };\n      updateOptions();\n      this.unwatchPickerOptions = this.$watch(\'pickerOptions\', function () {\n        return updateOptions();\n      }, { deep: true });\n      this.$el.appendChild(this.picker.$el);\n      this.picker.resetView && this.picker.resetView();\n\n      this.picker.$on(\'dodestroy\', this.doDestroy);\n      this.picker.$on(\'pick\', function () {\n        var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'\';\n        var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        _this3.userInput = null;\n        _this3.pickerVisible = _this3.picker.visible = visible;\n        _this3.emitInput(date);\n        _this3.picker.resetView && _this3.picker.resetView();\n      });\n\n      this.picker.$on(\'select-range\', function (start, end, pos) {\n        if (_this3.refInput.length === 0) return;\n        if (!pos || pos === \'min\') {\n          _this3.refInput[0].setSelectionRange(start, end);\n          _this3.refInput[0].focus();\n        } else if (pos === \'max\') {\n          _this3.refInput[1].setSelectionRange(start, end);\n          _this3.refInput[1].focus();\n        }\n      });\n    },\n    unmountPicker: function unmountPicker() {\n      if (this.picker) {\n        this.picker.$destroy();\n        this.picker.$off();\n        if (typeof this.unwatchPickerOptions === \'function\') {\n          this.unwatchPickerOptions();\n        }\n        this.picker.$el.parentNode.removeChild(this.picker.$el);\n      }\n    },\n    emitChange: function emitChange(val) {\n      // determine user real change only\n      if (!valueEquals(val, this.valueOnOpen)) {\n        this.$emit(\'change\', val);\n        this.valueOnOpen = val;\n        if (this.validateEvent) {\n          this.dispatch(\'ElFormItem\', \'el.form.change\', val);\n        }\n      }\n    },\n    emitInput: function emitInput(val) {\n      var formatted = this.formatToValue(val);\n      if (!valueEquals(this.value, formatted)) {\n        this.$emit(\'input\', formatted);\n      }\n    },\n    isValidValue: function isValidValue(value) {\n      if (!this.picker) {\n        this.mountPicker();\n      }\n      if (this.picker.isValidValue) {\n        return value && this.picker.isValidValue(value);\n      } else {\n        return true;\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/picker.vue?vue&type=script&lang=js&\n /* harmony default export */ var src_pickervue_type_script_lang_js_ = (pickervue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/date-picker/src/picker.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  src_pickervue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "packages/date-picker/src/picker.vue"\n/* harmony default export */ var picker = __webpack_exports__["a"] = (component.exports);\n\n/***/ }),\n/* 33 */,\n/* 34 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/time-spinner.vue?vue&type=template&id=1facadeb&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "div",\n    {\n      staticClass: "el-time-spinner",\n      class: { "has-seconds": _vm.showSeconds }\n    },\n    [\n      !_vm.arrowControl\n        ? [\n            _c(\n              "el-scrollbar",\n              {\n                ref: "hours",\n                staticClass: "el-time-spinner__wrapper",\n                attrs: {\n                  "wrap-style": "max-height: inherit;",\n                  "view-class": "el-time-spinner__list",\n                  noresize: "",\n                  tag: "ul"\n                },\n                nativeOn: {\n                  mouseenter: function($event) {\n                    _vm.emitSelectRange("hours")\n                  },\n                  mousemove: function($event) {\n                    _vm.adjustCurrentSpinner("hours")\n                  }\n                }\n              },\n              _vm._l(_vm.hoursList, function(disabled, hour) {\n                return _c(\n                  "li",\n                  {\n                    key: hour,\n                    staticClass: "el-time-spinner__item",\n                    class: { active: hour === _vm.hours, disabled: disabled },\n                    on: {\n                      click: function($event) {\n                        _vm.handleClick("hours", {\n                          value: hour,\n                          disabled: disabled\n                        })\n                      }\n                    }\n                  },\n                  [\n                    _vm._v(\n                      _vm._s(\n                        ("0" + (_vm.amPmMode ? hour % 12 || 12 : hour)).slice(\n                          -2\n                        )\n                      ) + _vm._s(_vm.amPm(hour))\n                    )\n                  ]\n                )\n              }),\n              0\n            ),\n            _c(\n              "el-scrollbar",\n              {\n                ref: "minutes",\n                staticClass: "el-time-spinner__wrapper",\n                attrs: {\n                  "wrap-style": "max-height: inherit;",\n                  "view-class": "el-time-spinner__list",\n                  noresize: "",\n                  tag: "ul"\n                },\n                nativeOn: {\n                  mouseenter: function($event) {\n                    _vm.emitSelectRange("minutes")\n                  },\n                  mousemove: function($event) {\n                    _vm.adjustCurrentSpinner("minutes")\n                  }\n                }\n              },\n              _vm._l(_vm.minutesList, function(enabled, key) {\n                return _c(\n                  "li",\n                  {\n                    key: key,\n                    staticClass: "el-time-spinner__item",\n                    class: { active: key === _vm.minutes, disabled: !enabled },\n                    on: {\n                      click: function($event) {\n                        _vm.handleClick("minutes", {\n                          value: key,\n                          disabled: false\n                        })\n                      }\n                    }\n                  },\n                  [_vm._v(_vm._s(("0" + key).slice(-2)))]\n                )\n              }),\n              0\n            ),\n            _c(\n              "el-scrollbar",\n              {\n                directives: [\n                  {\n                    name: "show",\n                    rawName: "v-show",\n                    value: _vm.showSeconds,\n                    expression: "showSeconds"\n                  }\n                ],\n                ref: "seconds",\n                staticClass: "el-time-spinner__wrapper",\n                attrs: {\n                  "wrap-style": "max-height: inherit;",\n                  "view-class": "el-time-spinner__list",\n                  noresize: "",\n                  tag: "ul"\n                },\n                nativeOn: {\n                  mouseenter: function($event) {\n                    _vm.emitSelectRange("seconds")\n                  },\n                  mousemove: function($event) {\n                    _vm.adjustCurrentSpinner("seconds")\n                  }\n                }\n              },\n              _vm._l(60, function(second, key) {\n                return _c(\n                  "li",\n                  {\n                    key: key,\n                    staticClass: "el-time-spinner__item",\n                    class: { active: key === _vm.seconds },\n                    on: {\n                      click: function($event) {\n                        _vm.handleClick("seconds", {\n                          value: key,\n                          disabled: false\n                        })\n                      }\n                    }\n                  },\n                  [_vm._v(_vm._s(("0" + key).slice(-2)))]\n                )\n              }),\n              0\n            )\n          ]\n        : _vm._e(),\n      _vm.arrowControl\n        ? [\n            _c(\n              "div",\n              {\n                staticClass: "el-time-spinner__wrapper is-arrow",\n                on: {\n                  mouseenter: function($event) {\n                    _vm.emitSelectRange("hours")\n                  }\n                }\n              },\n              [\n                _c("i", {\n                  directives: [\n                    {\n                      name: "repeat-click",\n                      rawName: "v-repeat-click",\n                      value: _vm.decrease,\n                      expression: "decrease"\n                    }\n                  ],\n                  staticClass: "el-time-spinner__arrow el-icon-arrow-up"\n                }),\n                _c("i", {\n                  directives: [\n                    {\n                      name: "repeat-click",\n                      rawName: "v-repeat-click",\n                      value: _vm.increase,\n                      expression: "increase"\n                    }\n                  ],\n                  staticClass: "el-time-spinner__arrow el-icon-arrow-down"\n                }),\n                _c(\n                  "ul",\n                  { ref: "hours", staticClass: "el-time-spinner__list" },\n                  _vm._l(_vm.arrowHourList, function(hour, key) {\n                    return _c(\n                      "li",\n                      {\n                        key: key,\n                        staticClass: "el-time-spinner__item",\n                        class: {\n                          active: hour === _vm.hours,\n                          disabled: _vm.hoursList[hour]\n                        }\n                      },\n                      [\n                        _vm._v(\n                          _vm._s(\n                            hour === undefined\n                              ? ""\n                              : (\n                                  "0" + (_vm.amPmMode ? hour % 12 || 12 : hour)\n                                ).slice(-2) + _vm.amPm(hour)\n                          )\n                        )\n                      ]\n                    )\n                  }),\n                  0\n                )\n              ]\n            ),\n            _c(\n              "div",\n              {\n                staticClass: "el-time-spinner__wrapper is-arrow",\n                on: {\n                  mouseenter: function($event) {\n                    _vm.emitSelectRange("minutes")\n                  }\n                }\n              },\n              [\n                _c("i", {\n                  directives: [\n                    {\n                      name: "repeat-click",\n                      rawName: "v-repeat-click",\n                      value: _vm.decrease,\n                      expression: "decrease"\n                    }\n                  ],\n                  staticClass: "el-time-spinner__arrow el-icon-arrow-up"\n                }),\n                _c("i", {\n                  directives: [\n                    {\n                      name: "repeat-click",\n                      rawName: "v-repeat-click",\n                      value: _vm.increase,\n                      expression: "increase"\n                    }\n                  ],\n                  staticClass: "el-time-spinner__arrow el-icon-arrow-down"\n                }),\n                _c(\n                  "ul",\n                  { ref: "minutes", staticClass: "el-time-spinner__list" },\n                  _vm._l(_vm.arrowMinuteList, function(minute, key) {\n                    return _c(\n                      "li",\n                      {\n                        key: key,\n                        staticClass: "el-time-spinner__item",\n                        class: { active: minute === _vm.minutes }\n                      },\n                      [\n                        _vm._v(\n                          "\\n          " +\n                            _vm._s(\n                              minute === undefined\n                                ? ""\n                                : ("0" + minute).slice(-2)\n                            ) +\n                            "\\n        "\n                        )\n                      ]\n                    )\n                  }),\n                  0\n                )\n              ]\n            ),\n            _vm.showSeconds\n              ? _c(\n                  "div",\n                  {\n                    staticClass: "el-time-spinner__wrapper is-arrow",\n                    on: {\n                      mouseenter: function($event) {\n                        _vm.emitSelectRange("seconds")\n                      }\n                    }\n                  },\n                  [\n                    _c("i", {\n                      directives: [\n                        {\n                          name: "repeat-click",\n                          rawName: "v-repeat-click",\n                          value: _vm.decrease,\n                          expression: "decrease"\n                        }\n                      ],\n                      staticClass: "el-time-spinner__arrow el-icon-arrow-up"\n                    }),\n                    _c("i", {\n                      directives: [\n                        {\n                          name: "repeat-click",\n                          rawName: "v-repeat-click",\n                          value: _vm.increase,\n                          expression: "increase"\n                        }\n                      ],\n                      staticClass: "el-time-spinner__arrow el-icon-arrow-down"\n                    }),\n                    _c(\n                      "ul",\n                      { ref: "seconds", staticClass: "el-time-spinner__list" },\n                      _vm._l(_vm.arrowSecondList, function(second, key) {\n                        return _c(\n                          "li",\n                          {\n                            key: key,\n                            staticClass: "el-time-spinner__item",\n                            class: { active: second === _vm.seconds }\n                          },\n                          [\n                            _vm._v(\n                              "\\n          " +\n                                _vm._s(\n                                  second === undefined\n                                    ? ""\n                                    : ("0" + second).slice(-2)\n                                ) +\n                                "\\n        "\n                            )\n                          ]\n                        )\n                      }),\n                      0\n                    )\n                  ]\n                )\n              : _vm._e()\n          ]\n        : _vm._e()\n    ],\n    2\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue?vue&type=template&id=1facadeb&\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/date-util"\nvar date_util_ = __webpack_require__(1);\n\n// EXTERNAL MODULE: external "element-ui/lib/scrollbar"\nvar scrollbar_ = __webpack_require__(15);\nvar scrollbar_default = /*#__PURE__*/__webpack_require__.n(scrollbar_);\n\n// EXTERNAL MODULE: ./src/directives/repeat-click.js\nvar repeat_click = __webpack_require__(30);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/time-spinner.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ var time_spinnervue_type_script_lang_js_ = ({\n  components: { ElScrollbar: scrollbar_default.a },\n\n  directives: {\n    repeatClick: repeat_click["a" /* default */]\n  },\n\n  props: {\n    date: {},\n    defaultValue: {}, // reserved for future use\n    showSeconds: {\n      type: Boolean,\n      default: true\n    },\n    arrowControl: Boolean,\n    amPmMode: {\n      type: String,\n      default: \'\' // \'a\': am/pm; \'A\': AM/PM\n    }\n  },\n\n  computed: {\n    hours: function hours() {\n      return this.date.getHours();\n    },\n    minutes: function minutes() {\n      return this.date.getMinutes();\n    },\n    seconds: function seconds() {\n      return this.date.getSeconds();\n    },\n    hoursList: function hoursList() {\n      return Object(date_util_["getRangeHours"])(this.selectableRange);\n    },\n    minutesList: function minutesList() {\n      return Object(date_util_["getRangeMinutes"])(this.selectableRange, this.hours);\n    },\n    arrowHourList: function arrowHourList() {\n      var hours = this.hours;\n      return [hours > 0 ? hours - 1 : undefined, hours, hours < 23 ? hours + 1 : undefined];\n    },\n    arrowMinuteList: function arrowMinuteList() {\n      var minutes = this.minutes;\n      return [minutes > 0 ? minutes - 1 : undefined, minutes, minutes < 59 ? minutes + 1 : undefined];\n    },\n    arrowSecondList: function arrowSecondList() {\n      var seconds = this.seconds;\n      return [seconds > 0 ? seconds - 1 : undefined, seconds, seconds < 59 ? seconds + 1 : undefined];\n    }\n  },\n\n  data: function data() {\n    return {\n      selectableRange: [],\n      currentScrollbar: null\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      !_this.arrowControl && _this.bindScrollEvent();\n    });\n  },\n\n\n  methods: {\n    increase: function increase() {\n      this.scrollDown(1);\n    },\n    decrease: function decrease() {\n      this.scrollDown(-1);\n    },\n    modifyDateField: function modifyDateField(type, value) {\n      switch (type) {\n        case \'hours\':\n          this.$emit(\'change\', Object(date_util_["modifyTime"])(this.date, value, this.minutes, this.seconds));break;\n        case \'minutes\':\n          this.$emit(\'change\', Object(date_util_["modifyTime"])(this.date, this.hours, value, this.seconds));break;\n        case \'seconds\':\n          this.$emit(\'change\', Object(date_util_["modifyTime"])(this.date, this.hours, this.minutes, value));break;\n      }\n    },\n    handleClick: function handleClick(type, _ref) {\n      var value = _ref.value,\n          disabled = _ref.disabled;\n\n      if (!disabled) {\n        this.modifyDateField(type, value);\n        this.emitSelectRange(type);\n        this.adjustSpinner(type, value);\n      }\n    },\n    emitSelectRange: function emitSelectRange(type) {\n      if (type === \'hours\') {\n        this.$emit(\'select-range\', 0, 2);\n      } else if (type === \'minutes\') {\n        this.$emit(\'select-range\', 3, 5);\n      } else if (type === \'seconds\') {\n        this.$emit(\'select-range\', 6, 8);\n      }\n      this.currentScrollbar = type;\n    },\n    bindScrollEvent: function bindScrollEvent() {\n      var _this2 = this;\n\n      var bindFuntion = function bindFuntion(type) {\n        _this2.$refs[type].wrap.onscroll = function (e) {\n          // TODO: scroll is emitted when set scrollTop programatically\n          // should find better solutions in the future!\n          _this2.handleScroll(type, e);\n        };\n      };\n      bindFuntion(\'hours\');\n      bindFuntion(\'minutes\');\n      bindFuntion(\'seconds\');\n    },\n    handleScroll: function handleScroll(type) {\n      var value = Math.min(Math.round((this.$refs[type].wrap.scrollTop - (this.scrollBarHeight(type) * 0.5 - 10) / this.typeItemHeight(type) + 3) / this.typeItemHeight(type)), type === \'hours\' ? 23 : 59);\n      this.modifyDateField(type, value);\n    },\n\n\n    // NOTE: used by datetime / date-range panel\n    //       renamed from adjustScrollTop\n    //       should try to refactory it\n    adjustSpinners: function adjustSpinners() {\n      this.adjustSpinner(\'hours\', this.hours);\n      this.adjustSpinner(\'minutes\', this.minutes);\n      this.adjustSpinner(\'seconds\', this.seconds);\n    },\n    adjustCurrentSpinner: function adjustCurrentSpinner(type) {\n      this.adjustSpinner(type, this[type]);\n    },\n    adjustSpinner: function adjustSpinner(type, value) {\n      if (this.arrowControl) return;\n      var el = this.$refs[type].wrap;\n      if (el) {\n        el.scrollTop = Math.max(0, value * this.typeItemHeight(type));\n      }\n    },\n    scrollDown: function scrollDown(step) {\n      var _this3 = this;\n\n      if (!this.currentScrollbar) {\n        this.emitSelectRange(\'hours\');\n      }\n\n      var label = this.currentScrollbar;\n      var hoursList = this.hoursList;\n      var now = this[label];\n\n      if (this.currentScrollbar === \'hours\') {\n        var total = Math.abs(step);\n        step = step > 0 ? 1 : -1;\n        var length = hoursList.length;\n        while (length-- && total) {\n          now = (now + step + hoursList.length) % hoursList.length;\n          if (hoursList[now]) {\n            continue;\n          }\n          total--;\n        }\n        if (hoursList[now]) return;\n      } else {\n        now = (now + step + 60) % 60;\n      }\n\n      this.modifyDateField(label, now);\n      this.adjustSpinner(label, now);\n      this.$nextTick(function () {\n        return _this3.emitSelectRange(_this3.currentScrollbar);\n      });\n    },\n    amPm: function amPm(hour) {\n      var shouldShowAmPm = this.amPmMode.toLowerCase() === \'a\';\n      if (!shouldShowAmPm) return \'\';\n      var isCapital = this.amPmMode === \'A\';\n      var content = hour < 12 ? \' am\' : \' pm\';\n      if (isCapital) content = content.toUpperCase();\n      return content;\n    },\n    typeItemHeight: function typeItemHeight(type) {\n      return this.$refs[type].$el.querySelector(\'li\').offsetHeight;\n    },\n    scrollBarHeight: function scrollBarHeight(type) {\n      return this.$refs[type].$el.offsetHeight;\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue?vue&type=script&lang=js&\n /* harmony default export */ var basic_time_spinnervue_type_script_lang_js_ = (time_spinnervue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/time-spinner.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  basic_time_spinnervue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "packages/date-picker/src/basic/time-spinner.vue"\n/* harmony default export */ var time_spinner = __webpack_exports__["a"] = (component.exports);\n\n/***/ }),\n/* 35 */,\n/* 36 */,\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */,\n/* 41 */,\n/* 42 */,\n/* 43 */,\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */,\n/* 48 */,\n/* 49 */,\n/* 50 */,\n/* 51 */,\n/* 52 */,\n/* 53 */,\n/* 54 */,\n/* 55 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n"use strict";\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./packages/date-picker/src/picker.vue + 4 modules\nvar picker = __webpack_require__(32);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date.vue?vue&type=template&id=2440d4ea&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "transition",\n    {\n      attrs: { name: "el-zoom-in-top" },\n      on: { "after-enter": _vm.handleEnter, "after-leave": _vm.handleLeave }\n    },\n    [\n      _c(\n        "div",\n        {\n          directives: [\n            {\n              name: "show",\n              rawName: "v-show",\n              value: _vm.visible,\n              expression: "visible"\n            }\n          ],\n          staticClass: "el-picker-panel el-date-picker el-popper",\n          class: [\n            {\n              "has-sidebar": _vm.$slots.sidebar || _vm.shortcuts,\n              "has-time": _vm.showTime\n            },\n            _vm.popperClass\n          ]\n        },\n        [\n          _c(\n            "div",\n            { staticClass: "el-picker-panel__body-wrapper" },\n            [\n              _vm._t("sidebar"),\n              _vm.shortcuts\n                ? _c(\n                    "div",\n                    { staticClass: "el-picker-panel__sidebar" },\n                    _vm._l(_vm.shortcuts, function(shortcut, key) {\n                      return _c(\n                        "button",\n                        {\n                          key: key,\n                          staticClass: "el-picker-panel__shortcut",\n                          attrs: { type: "button" },\n                          on: {\n                            click: function($event) {\n                              _vm.handleShortcutClick(shortcut)\n                            }\n                          }\n                        },\n                        [_vm._v(_vm._s(shortcut.text))]\n                      )\n                    }),\n                    0\n                  )\n                : _vm._e(),\n              _c("div", { staticClass: "el-picker-panel__body" }, [\n                _vm.showTime\n                  ? _c("div", { staticClass: "el-date-picker__time-header" }, [\n                      _c(\n                        "span",\n                        { staticClass: "el-date-picker__editor-wrap" },\n                        [\n                          _c("el-input", {\n                            attrs: {\n                              placeholder: _vm.t("el.datepicker.selectDate"),\n                              value: _vm.visibleDate,\n                              size: "small"\n                            },\n                            on: {\n                              input: function(val) {\n                                return (_vm.userInputDate = val)\n                              },\n                              change: _vm.handleVisibleDateChange\n                            }\n                          })\n                        ],\n                        1\n                      ),\n                      _c(\n                        "span",\n                        {\n                          directives: [\n                            {\n                              name: "clickoutside",\n                              rawName: "v-clickoutside",\n                              value: _vm.handleTimePickClose,\n                              expression: "handleTimePickClose"\n                            }\n                          ],\n                          staticClass: "el-date-picker__editor-wrap"\n                        },\n                        [\n                          _c("el-input", {\n                            ref: "input",\n                            attrs: {\n                              placeholder: _vm.t("el.datepicker.selectTime"),\n                              value: _vm.visibleTime,\n                              size: "small"\n                            },\n                            on: {\n                              focus: function($event) {\n                                _vm.timePickerVisible = true\n                              },\n                              input: function(val) {\n                                return (_vm.userInputTime = val)\n                              },\n                              change: _vm.handleVisibleTimeChange\n                            }\n                          }),\n                          _c("time-picker", {\n                            ref: "timepicker",\n                            attrs: {\n                              "time-arrow-control": _vm.arrowControl,\n                              visible: _vm.timePickerVisible\n                            },\n                            on: {\n                              pick: _vm.handleTimePick,\n                              mounted: _vm.proxyTimePickerDataProperties\n                            }\n                          })\n                        ],\n                        1\n                      )\n                    ])\n                  : _vm._e(),\n                _c(\n                  "div",\n                  {\n                    directives: [\n                      {\n                        name: "show",\n                        rawName: "v-show",\n                        value: _vm.currentView !== "time",\n                        expression: "currentView !== \'time\'"\n                      }\n                    ],\n                    staticClass: "el-date-picker__header",\n                    class: {\n                      "el-date-picker__header--bordered":\n                        _vm.currentView === "year" ||\n                        _vm.currentView === "month"\n                    }\n                  },\n                  [\n                    _c("button", {\n                      staticClass:\n                        "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-d-arrow-left",\n                      attrs: {\n                        type: "button",\n                        "aria-label": _vm.t("el.datepicker.prevYear")\n                      },\n                      on: { click: _vm.prevYear }\n                    }),\n                    _c("button", {\n                      directives: [\n                        {\n                          name: "show",\n                          rawName: "v-show",\n                          value: _vm.currentView === "date",\n                          expression: "currentView === \'date\'"\n                        }\n                      ],\n                      staticClass:\n                        "el-picker-panel__icon-btn el-date-picker__prev-btn el-icon-arrow-left",\n                      attrs: {\n                        type: "button",\n                        "aria-label": _vm.t("el.datepicker.prevMonth")\n                      },\n                      on: { click: _vm.prevMonth }\n                    }),\n                    _c(\n                      "span",\n                      {\n                        staticClass: "el-date-picker__header-label",\n                        attrs: { role: "button" },\n                        on: { click: _vm.showYearPicker }\n                      },\n                      [_vm._v(_vm._s(_vm.yearLabel))]\n                    ),\n                    _c(\n                      "span",\n                      {\n                        directives: [\n                          {\n                            name: "show",\n                            rawName: "v-show",\n                            value: _vm.currentView === "date",\n                            expression: "currentView === \'date\'"\n                          }\n                        ],\n                        staticClass: "el-date-picker__header-label",\n                        class: { active: _vm.currentView === "month" },\n                        attrs: { role: "button" },\n                        on: { click: _vm.showMonthPicker }\n                      },\n                      [\n                        _vm._v(\n                          _vm._s(_vm.t("el.datepicker.month" + (_vm.month + 1)))\n                        )\n                      ]\n                    ),\n                    _c("button", {\n                      staticClass:\n                        "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-d-arrow-right",\n                      attrs: {\n                        type: "button",\n                        "aria-label": _vm.t("el.datepicker.nextYear")\n                      },\n                      on: { click: _vm.nextYear }\n                    }),\n                    _c("button", {\n                      directives: [\n                        {\n                          name: "show",\n                          rawName: "v-show",\n                          value: _vm.currentView === "date",\n                          expression: "currentView === \'date\'"\n                        }\n                      ],\n                      staticClass:\n                        "el-picker-panel__icon-btn el-date-picker__next-btn el-icon-arrow-right",\n                      attrs: {\n                        type: "button",\n                        "aria-label": _vm.t("el.datepicker.nextMonth")\n                      },\n                      on: { click: _vm.nextMonth }\n                    })\n                  ]\n                ),\n                _c(\n                  "div",\n                  { staticClass: "el-picker-panel__content" },\n                  [\n                    _c("date-table", {\n                      directives: [\n                        {\n                          name: "show",\n                          rawName: "v-show",\n                          value: _vm.currentView === "date",\n                          expression: "currentView === \'date\'"\n                        }\n                      ],\n                      attrs: {\n                        "selection-mode": _vm.selectionMode,\n                        "first-day-of-week": _vm.firstDayOfWeek,\n                        value: _vm.value,\n                        "default-value": _vm.defaultValue\n                          ? new Date(_vm.defaultValue)\n                          : null,\n                        date: _vm.date,\n                        "cell-class-name": _vm.cellClassName,\n                        "disabled-date": _vm.disabledDate\n                      },\n                      on: { pick: _vm.handleDatePick }\n                    }),\n                    _c("year-table", {\n                      directives: [\n                        {\n                          name: "show",\n                          rawName: "v-show",\n                          value: _vm.currentView === "year",\n                          expression: "currentView === \'year\'"\n                        }\n                      ],\n                      attrs: {\n                        value: _vm.value,\n                        "default-value": _vm.defaultValue\n                          ? new Date(_vm.defaultValue)\n                          : null,\n                        date: _vm.date,\n                        "disabled-date": _vm.disabledDate\n                      },\n                      on: { pick: _vm.handleYearPick }\n                    }),\n                    _c("month-table", {\n                      directives: [\n                        {\n                          name: "show",\n                          rawName: "v-show",\n                          value: _vm.currentView === "month",\n                          expression: "currentView === \'month\'"\n                        }\n                      ],\n                      attrs: {\n                        value: _vm.value,\n                        "default-value": _vm.defaultValue\n                          ? new Date(_vm.defaultValue)\n                          : null,\n                        date: _vm.date,\n                        "disabled-date": _vm.disabledDate\n                      },\n                      on: { pick: _vm.handleMonthPick }\n                    })\n                  ],\n                  1\n                )\n              ])\n            ],\n            2\n          ),\n          _c(\n            "div",\n            {\n              directives: [\n                {\n                  name: "show",\n                  rawName: "v-show",\n                  value: _vm.footerVisible && _vm.currentView === "date",\n                  expression: "footerVisible && currentView === \'date\'"\n                }\n              ],\n              staticClass: "el-picker-panel__footer"\n            },\n            [\n              _c(\n                "el-button",\n                {\n                  directives: [\n                    {\n                      name: "show",\n                      rawName: "v-show",\n                      value: _vm.selectionMode !== "dates",\n                      expression: "selectionMode !== \'dates\'"\n                    }\n                  ],\n                  staticClass: "el-picker-panel__link-btn",\n                  attrs: { size: "mini", type: "text" },\n                  on: { click: _vm.changeToNow }\n                },\n                [\n                  _vm._v(\n                    "\\n        " +\n                      _vm._s(_vm.t("el.datepicker.now")) +\n                      "\\n      "\n                  )\n                ]\n              ),\n              _c(\n                "el-button",\n                {\n                  staticClass: "el-picker-panel__link-btn",\n                  attrs: { plain: "", size: "mini" },\n                  on: { click: _vm.confirm }\n                },\n                [\n                  _vm._v(\n                    "\\n        " +\n                      _vm._s(_vm.t("el.datepicker.confirm")) +\n                      "\\n      "\n                  )\n                ]\n              )\n            ],\n            1\n          )\n        ]\n      )\n    ]\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue?vue&type=template&id=2440d4ea&\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/date-util"\nvar date_util_ = __webpack_require__(1);\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/clickoutside"\nvar clickoutside_ = __webpack_require__(12);\nvar clickoutside_default = /*#__PURE__*/__webpack_require__.n(clickoutside_);\n\n// EXTERNAL MODULE: external "element-ui/lib/mixins/locale"\nvar locale_ = __webpack_require__(6);\nvar locale_default = /*#__PURE__*/__webpack_require__.n(locale_);\n\n// EXTERNAL MODULE: external "element-ui/lib/input"\nvar input_ = __webpack_require__(10);\nvar input_default = /*#__PURE__*/__webpack_require__.n(input_);\n\n// EXTERNAL MODULE: external "element-ui/lib/button"\nvar button_ = __webpack_require__(14);\nvar button_default = /*#__PURE__*/__webpack_require__.n(button_);\n\n// EXTERNAL MODULE: ./packages/date-picker/src/panel/time.vue + 4 modules\nvar panel_time = __webpack_require__(27);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/year-table.vue?vue&type=template&id=c86ab5e0&\nvar year_tablevue_type_template_id_c86ab5e0_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "table",\n    { staticClass: "el-year-table", on: { click: _vm.handleYearTableClick } },\n    [\n      _c("tbody", [\n        _c("tr", [\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 0)\n            },\n            [_c("a", { staticClass: "cell" }, [_vm._v(_vm._s(_vm.startYear))])]\n          ),\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 1)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 1))\n              ])\n            ]\n          ),\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 2)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 2))\n              ])\n            ]\n          ),\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 3)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 3))\n              ])\n            ]\n          )\n        ]),\n        _c("tr", [\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 4)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 4))\n              ])\n            ]\n          ),\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 5)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 5))\n              ])\n            ]\n          ),\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 6)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 6))\n              ])\n            ]\n          ),\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 7)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 7))\n              ])\n            ]\n          )\n        ]),\n        _c("tr", [\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 8)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 8))\n              ])\n            ]\n          ),\n          _c(\n            "td",\n            {\n              staticClass: "available",\n              class: _vm.getCellStyle(_vm.startYear + 9)\n            },\n            [\n              _c("a", { staticClass: "cell" }, [\n                _vm._v(_vm._s(_vm.startYear + 9))\n              ])\n            ]\n          ),\n          _c("td"),\n          _c("td")\n        ])\n      ])\n    ]\n  )\n}\nvar year_tablevue_type_template_id_c86ab5e0_staticRenderFns = []\nyear_tablevue_type_template_id_c86ab5e0_render._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue?vue&type=template&id=c86ab5e0&\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/dom"\nvar dom_ = __webpack_require__(2);\n\n// EXTERNAL MODULE: external "element-ui/lib/utils/util"\nvar util_ = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/year-table.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\nvar year_tablevue_type_script_lang_js_datesInYear = function datesInYear(year) {\n  var numOfDays = Object(date_util_["getDayCountOfYear"])(year);\n  var firstDay = new Date(year, 0, 1);\n  return Object(date_util_["range"])(numOfDays).map(function (n) {\n    return Object(date_util_["nextDate"])(firstDay, n);\n  });\n};\n\n/* harmony default export */ var year_tablevue_type_script_lang_js_ = ({\n  props: {\n    disabledDate: {},\n    value: {},\n    defaultValue: {\n      validator: function validator(val) {\n        // null or valid Date Object\n        return val === null || val instanceof Date && Object(date_util_["isDate"])(val);\n      }\n    },\n    date: {}\n  },\n\n  computed: {\n    startYear: function startYear() {\n      return Math.floor(this.date.getFullYear() / 10) * 10;\n    }\n  },\n\n  methods: {\n    getCellStyle: function getCellStyle(year) {\n      var style = {};\n      var today = new Date();\n\n      style.disabled = typeof this.disabledDate === \'function\' ? year_tablevue_type_script_lang_js_datesInYear(year).every(this.disabledDate) : false;\n      style.current = Object(util_["arrayFindIndex"])(Object(util_["coerceTruthyValueToArray"])(this.value), function (date) {\n        return date.getFullYear() === year;\n      }) >= 0;\n      style.today = today.getFullYear() === year;\n      style.default = this.defaultValue && this.defaultValue.getFullYear() === year;\n\n      return style;\n    },\n    handleYearTableClick: function handleYearTableClick(event) {\n      var target = event.target;\n      if (target.tagName === \'A\') {\n        if (Object(dom_["hasClass"])(target.parentNode, \'disabled\')) return;\n        var year = target.textContent || target.innerText;\n        this.$emit(\'pick\', Number(year));\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue?vue&type=script&lang=js&\n /* harmony default export */ var basic_year_tablevue_type_script_lang_js_ = (year_tablevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/year-table.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  basic_year_tablevue_type_script_lang_js_,\n  year_tablevue_type_template_id_c86ab5e0_render,\n  year_tablevue_type_template_id_c86ab5e0_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "packages/date-picker/src/basic/year-table.vue"\n/* harmony default export */ var year_table = (component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/month-table.vue?vue&type=template&id=654d4f42&\nvar month_tablevue_type_template_id_654d4f42_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "table",\n    {\n      staticClass: "el-month-table",\n      on: { click: _vm.handleMonthTableClick, mousemove: _vm.handleMouseMove }\n    },\n    [\n      _c(\n        "tbody",\n        _vm._l(_vm.rows, function(row, key) {\n          return _c(\n            "tr",\n            { key: key },\n            _vm._l(row, function(cell, key) {\n              return _c("td", { key: key, class: _vm.getCellStyle(cell) }, [\n                _c("div", [\n                  _c("a", { staticClass: "cell" }, [\n                    _vm._v(\n                      _vm._s(\n                        _vm.t("el.datepicker.months." + _vm.months[cell.text])\n                      )\n                    )\n                  ])\n                ])\n              ])\n            }),\n            0\n          )\n        }),\n        0\n      )\n    ]\n  )\n}\nvar month_tablevue_type_template_id_654d4f42_staticRenderFns = []\nmonth_tablevue_type_template_id_654d4f42_render._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue?vue&type=template&id=654d4f42&\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/month-table.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\nvar month_tablevue_type_script_lang_js_datesInMonth = function datesInMonth(year, month) {\n  var numOfDays = Object(date_util_["getDayCountOfMonth"])(year, month);\n  var firstDay = new Date(year, month, 1);\n  return Object(date_util_["range"])(numOfDays).map(function (n) {\n    return Object(date_util_["nextDate"])(firstDay, n);\n  });\n};\n\nvar clearDate = function clearDate(date) {\n  return new Date(date.getFullYear(), date.getMonth());\n};\n\nvar getMonthTimestamp = function getMonthTimestamp(time) {\n  if (typeof time === \'number\' || typeof time === \'string\') {\n    return clearDate(new Date(time)).getTime();\n  } else if (time instanceof Date) {\n    return clearDate(time).getTime();\n  } else {\n    return NaN;\n  }\n};\n/* harmony default export */ var month_tablevue_type_script_lang_js_ = ({\n  props: {\n    disabledDate: {},\n    value: {},\n    selectionMode: {\n      default: \'month\'\n    },\n    minDate: {},\n\n    maxDate: {},\n    defaultValue: {\n      validator: function validator(val) {\n        // null or valid Date Object\n        return val === null || Object(date_util_["isDate"])(val) || Array.isArray(val) && val.every(date_util_["isDate"]);\n      }\n    },\n    date: {},\n    rangeState: {\n      default: function _default() {\n        return {\n          endDate: null,\n          selecting: false\n        };\n      }\n    }\n  },\n\n  mixins: [locale_default.a],\n\n  watch: {\n    \'rangeState.endDate\': function rangeStateEndDate(newVal) {\n      this.markRange(this.minDate, newVal);\n    },\n    minDate: function minDate(newVal, oldVal) {\n      if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {\n        this.markRange(this.minDate, this.maxDate);\n      }\n    },\n    maxDate: function maxDate(newVal, oldVal) {\n      if (getMonthTimestamp(newVal) !== getMonthTimestamp(oldVal)) {\n        this.markRange(this.minDate, this.maxDate);\n      }\n    }\n  },\n\n  data: function data() {\n    return {\n      months: [\'jan\', \'feb\', \'mar\', \'apr\', \'may\', \'jun\', \'jul\', \'aug\', \'sep\', \'oct\', \'nov\', \'dec\'],\n      tableRows: [[], [], []],\n      lastRow: null,\n      lastColumn: null\n    };\n  },\n\n\n  methods: {\n    cellMatchesDate: function cellMatchesDate(cell, date) {\n      var value = new Date(date);\n      return this.date.getFullYear() === value.getFullYear() && Number(cell.text) === value.getMonth();\n    },\n    getCellStyle: function getCellStyle(cell) {\n      var _this = this;\n\n      var style = {};\n      var year = this.date.getFullYear();\n      var today = new Date();\n      var month = cell.text;\n      var defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];\n      style.disabled = typeof this.disabledDate === \'function\' ? month_tablevue_type_script_lang_js_datesInMonth(year, month).every(this.disabledDate) : false;\n      style.current = Object(util_["arrayFindIndex"])(Object(util_["coerceTruthyValueToArray"])(this.value), function (date) {\n        return date.getFullYear() === year && date.getMonth() === month;\n      }) >= 0;\n      style.today = today.getFullYear() === year && today.getMonth() === month;\n      style.default = defaultValue.some(function (date) {\n        return _this.cellMatchesDate(cell, date);\n      });\n\n      if (cell.inRange) {\n        style[\'in-range\'] = true;\n\n        if (cell.start) {\n          style[\'start-date\'] = true;\n        }\n\n        if (cell.end) {\n          style[\'end-date\'] = true;\n        }\n      }\n      return style;\n    },\n    getMonthOfCell: function getMonthOfCell(month) {\n      var year = this.date.getFullYear();\n      return new Date(year, month, 1);\n    },\n    markRange: function markRange(minDate, maxDate) {\n      minDate = getMonthTimestamp(minDate);\n      maxDate = getMonthTimestamp(maxDate) || minDate;\n      var _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];\n      minDate = _ref[0];\n      maxDate = _ref[1];\n\n      var rows = this.rows;\n      for (var i = 0, k = rows.length; i < k; i++) {\n        var row = rows[i];\n        for (var j = 0, l = row.length; j < l; j++) {\n\n          var cell = row[j];\n          var index = i * 4 + j;\n          var time = new Date(this.date.getFullYear(), index).getTime();\n\n          cell.inRange = minDate && time >= minDate && time <= maxDate;\n          cell.start = minDate && time === minDate;\n          cell.end = maxDate && time === maxDate;\n        }\n      }\n    },\n    handleMouseMove: function handleMouseMove(event) {\n      if (!this.rangeState.selecting) return;\n\n      var target = event.target;\n      if (target.tagName === \'A\') {\n        target = target.parentNode.parentNode;\n      }\n      if (target.tagName === \'DIV\') {\n        target = target.parentNode;\n      }\n      if (target.tagName !== \'TD\') return;\n\n      var row = target.parentNode.rowIndex;\n      var column = target.cellIndex;\n      // can not select disabled date\n      if (this.rows[row][column].disabled) return;\n\n      // only update rangeState when mouse moves to a new cell\n      // this avoids frequent Date object creation and improves performance\n      if (row !== this.lastRow || column !== this.lastColumn) {\n        this.lastRow = row;\n        this.lastColumn = column;\n        this.$emit(\'changerange\', {\n          minDate: this.minDate,\n          maxDate: this.maxDate,\n          rangeState: {\n            selecting: true,\n            endDate: this.getMonthOfCell(row * 4 + column)\n          }\n        });\n      }\n    },\n    handleMonthTableClick: function handleMonthTableClick(event) {\n      var target = event.target;\n      if (target.tagName === \'A\') {\n        target = target.parentNode.parentNode;\n      }\n      if (target.tagName === \'DIV\') {\n        target = target.parentNode;\n      }\n      if (target.tagName !== \'TD\') return;\n      if (Object(dom_["hasClass"])(target, \'disabled\')) return;\n      var column = target.cellIndex;\n      var row = target.parentNode.rowIndex;\n      var month = row * 4 + column;\n      var newDate = this.getMonthOfCell(month);\n      if (this.selectionMode === \'range\') {\n        if (!this.rangeState.selecting) {\n          this.$emit(\'pick\', { minDate: newDate, maxDate: null });\n          this.rangeState.selecting = true;\n        } else {\n          if (newDate >= this.minDate) {\n            this.$emit(\'pick\', { minDate: this.minDate, maxDate: newDate });\n          } else {\n            this.$emit(\'pick\', { minDate: newDate, maxDate: this.minDate });\n          }\n          this.rangeState.selecting = false;\n        }\n      } else {\n        this.$emit(\'pick\', month);\n      }\n    }\n  },\n\n  computed: {\n    rows: function rows() {\n      var _this2 = this;\n\n      // TODO: refactory rows / getCellClasses\n      var rows = this.tableRows;\n      var disabledDate = this.disabledDate;\n      var selectedDate = [];\n      var now = getMonthTimestamp(new Date());\n\n      for (var i = 0; i < 3; i++) {\n        var row = rows[i];\n\n        var _loop = function _loop(j) {\n          var cell = row[j];\n          if (!cell) {\n            cell = { row: i, column: j, type: \'normal\', inRange: false, start: false, end: false };\n          }\n\n          cell.type = \'normal\';\n\n          var index = i * 4 + j;\n          var time = new Date(_this2.date.getFullYear(), index).getTime();\n          cell.inRange = time >= getMonthTimestamp(_this2.minDate) && time <= getMonthTimestamp(_this2.maxDate);\n          cell.start = _this2.minDate && time === getMonthTimestamp(_this2.minDate);\n          cell.end = _this2.maxDate && time === getMonthTimestamp(_this2.maxDate);\n          var isToday = time === now;\n\n          if (isToday) {\n            cell.type = \'today\';\n          }\n          cell.text = index;\n          var cellDate = new Date(time);\n          cell.disabled = typeof disabledDate === \'function\' && disabledDate(cellDate);\n          cell.selected = Object(util_["arrayFind"])(selectedDate, function (date) {\n            return date.getTime() === cellDate.getTime();\n          });\n\n          _this2.$set(row, j, cell);\n        };\n\n        for (var j = 0; j < 4; j++) {\n          _loop(j);\n        }\n      }\n      return rows;\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue?vue&type=script&lang=js&\n /* harmony default export */ var basic_month_tablevue_type_script_lang_js_ = (month_tablevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/date-picker/src/basic/month-table.vue\n\n\n\n\n\n/* normalize component */\n\nvar month_table_component = Object(componentNormalizer["a" /* default */])(\n  basic_month_tablevue_type_script_lang_js_,\n  month_tablevue_type_template_id_654d4f42_render,\n  month_tablevue_type_template_id_654d4f42_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var month_table_api; }\nmonth_table_component.options.__file = "packages/date-picker/src/basic/month-table.vue"\n/* harmony default export */ var month_table = (month_table_component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/date-table.vue?vue&type=template&id=5d1f3341&\nvar date_tablevue_type_template_id_5d1f3341_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "table",\n    {\n      staticClass: "el-date-table",\n      class: { "is-week-mode": _vm.selectionMode === "week" },\n      attrs: { cellspacing: "0", cellpadding: "0" },\n      on: { click: _vm.handleClick, mousemove: _vm.handleMouseMove }\n    },\n    [\n      _c(\n        "tbody",\n        [\n          _c(\n            "tr",\n            [\n              _vm.showWeekNumber\n                ? _c("th", [_vm._v(_vm._s(_vm.t("el.datepicker.week")))])\n                : _vm._e(),\n              _vm._l(_vm.WEEKS, function(week, key) {\n                return _c("th", { key: key }, [\n                  _vm._v(_vm._s(_vm.t("el.datepicker.weeks." + week)))\n                ])\n              })\n            ],\n            2\n          ),\n          _vm._l(_vm.rows, function(row, key) {\n            return _c(\n              "tr",\n              {\n                key: key,\n                staticClass: "el-date-table__row",\n                class: { current: _vm.isWeekActive(row[1]) }\n              },\n              _vm._l(row, function(cell, key) {\n                return _c("td", { key: key, class: _vm.getCellClasses(cell) }, [\n                  _c("div", [\n                    _c("span", [\n                      _vm._v("\\n          " + _vm._s(cell.text) + "\\n        ")\n                    ])\n                  ])\n                ])\n              }),\n              0\n            )\n          })\n        ],\n        2\n      )\n    ]\n  )\n}\nvar date_tablevue_type_template_id_5d1f3341_staticRenderFns = []\ndate_tablevue_type_template_id_5d1f3341_render._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue?vue&type=template&id=5d1f3341&\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/basic/date-table.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\nvar _WEEKS = [\'sun\', \'mon\', \'tue\', \'wed\', \'thu\', \'fri\', \'sat\'];\nvar date_tablevue_type_script_lang_js_getDateTimestamp = function getDateTimestamp(time) {\n  if (typeof time === \'number\' || typeof time === \'string\') {\n    return Object(date_util_["clearTime"])(new Date(time)).getTime();\n  } else if (time instanceof Date) {\n    return Object(date_util_["clearTime"])(time).getTime();\n  } else {\n    return NaN;\n  }\n};\n\n// remove the first element that satisfies `pred` from arr\n// return a new array if modification occurs\n// return the original array otherwise\nvar date_tablevue_type_script_lang_js_removeFromArray = function removeFromArray(arr, pred) {\n  var idx = typeof pred === \'function\' ? Object(util_["arrayFindIndex"])(arr, pred) : arr.indexOf(pred);\n  return idx >= 0 ? [].concat(arr.slice(0, idx), arr.slice(idx + 1)) : arr;\n};\n\n/* harmony default export */ var date_tablevue_type_script_lang_js_ = ({\n  mixins: [locale_default.a],\n\n  props: {\n    firstDayOfWeek: {\n      default: 7,\n      type: Number,\n      validator: function validator(val) {\n        return val >= 1 && val <= 7;\n      }\n    },\n\n    value: {},\n\n    defaultValue: {\n      validator: function validator(val) {\n        // either: null, valid Date object, Array of valid Date objects\n        return val === null || Object(date_util_["isDate"])(val) || Array.isArray(val) && val.every(date_util_["isDate"]);\n      }\n    },\n\n    date: {},\n\n    selectionMode: {\n      default: \'day\'\n    },\n\n    showWeekNumber: {\n      type: Boolean,\n      default: false\n    },\n\n    disabledDate: {},\n\n    cellClassName: {},\n\n    minDate: {},\n\n    maxDate: {},\n\n    rangeState: {\n      default: function _default() {\n        return {\n          endDate: null,\n          selecting: false\n        };\n      }\n    }\n  },\n\n  computed: {\n    offsetDay: function offsetDay() {\n      var week = this.firstDayOfWeek;\n      // 周日为界限，左右偏移的天数，3217654 例如周一就是 -1，目的是调整前两行日期的位置\n      return week > 3 ? 7 - week : -week;\n    },\n    WEEKS: function WEEKS() {\n      var week = this.firstDayOfWeek;\n      return _WEEKS.concat(_WEEKS).slice(week, week + 7);\n    },\n    year: function year() {\n      return this.date.getFullYear();\n    },\n    month: function month() {\n      return this.date.getMonth();\n    },\n    startDate: function startDate() {\n      return Object(date_util_["getStartDateOfMonth"])(this.year, this.month);\n    },\n    rows: function rows() {\n      var _this = this;\n\n      // TODO: refactory rows / getCellClasses\n      var date = new Date(this.year, this.month, 1);\n      var day = Object(date_util_["getFirstDayOfMonth"])(date); // day of first day\n      var dateCountOfMonth = Object(date_util_["getDayCountOfMonth"])(date.getFullYear(), date.getMonth());\n      var dateCountOfLastMonth = Object(date_util_["getDayCountOfMonth"])(date.getFullYear(), date.getMonth() === 0 ? 11 : date.getMonth() - 1);\n\n      day = day === 0 ? 7 : day;\n\n      var offset = this.offsetDay;\n      var rows = this.tableRows;\n      var count = 1;\n\n      var startDate = this.startDate;\n      var disabledDate = this.disabledDate;\n      var cellClassName = this.cellClassName;\n      var selectedDate = this.selectionMode === \'dates\' ? Object(util_["coerceTruthyValueToArray"])(this.value) : [];\n      var now = date_tablevue_type_script_lang_js_getDateTimestamp(new Date());\n\n      for (var i = 0; i < 6; i++) {\n        var row = rows[i];\n\n        if (this.showWeekNumber) {\n          if (!row[0]) {\n            row[0] = { type: \'week\', text: Object(date_util_["getWeekNumber"])(Object(date_util_["nextDate"])(startDate, i * 7 + 1)) };\n          }\n        }\n\n        var _loop = function _loop(j) {\n          var cell = row[_this.showWeekNumber ? j + 1 : j];\n          if (!cell) {\n            cell = { row: i, column: j, type: \'normal\', inRange: false, start: false, end: false };\n          }\n\n          cell.type = \'normal\';\n\n          var index = i * 7 + j;\n          var time = Object(date_util_["nextDate"])(startDate, index - offset).getTime();\n          cell.inRange = time >= date_tablevue_type_script_lang_js_getDateTimestamp(_this.minDate) && time <= date_tablevue_type_script_lang_js_getDateTimestamp(_this.maxDate);\n          cell.start = _this.minDate && time === date_tablevue_type_script_lang_js_getDateTimestamp(_this.minDate);\n          cell.end = _this.maxDate && time === date_tablevue_type_script_lang_js_getDateTimestamp(_this.maxDate);\n          var isToday = time === now;\n\n          if (isToday) {\n            cell.type = \'today\';\n          }\n\n          if (i >= 0 && i <= 1) {\n            var numberOfDaysFromPreviousMonth = day + offset < 0 ? 7 + day + offset : day + offset;\n\n            if (j + i * 7 >= numberOfDaysFromPreviousMonth) {\n              cell.text = count++;\n            } else {\n              cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - j % 7) + 1 + i * 7;\n              cell.type = \'prev-month\';\n            }\n          } else {\n            if (count <= dateCountOfMonth) {\n              cell.text = count++;\n            } else {\n              cell.text = count++ - dateCountOfMonth;\n              cell.type = \'next-month\';\n            }\n          }\n\n          var cellDate = new Date(time);\n          cell.disabled = typeof disabledDate === \'function\' && disabledDate(cellDate);\n          cell.selected = Object(util_["arrayFind"])(selectedDate, function (date) {\n            return date.getTime() === cellDate.getTime();\n          });\n          cell.customClass = typeof cellClassName === \'function\' && cellClassName(cellDate);\n          _this.$set(row, _this.showWeekNumber ? j + 1 : j, cell);\n        };\n\n        for (var j = 0; j < 7; j++) {\n          _loop(j);\n        }\n\n        if (this.selectionMode === \'week\') {\n          var start = this.showWeekNumber ? 1 : 0;\n          var end = this.showWeekNumber ? 7 : 6;\n          var isWeekActive = this.isWeekActive(row[start + 1]);\n\n          row[start].inRange = isWeekActive;\n          row[start].start = isWeekActive;\n          row[end].inRange = isWeekActive;\n          row[end].end = isWeekActive;\n        }\n      }\n\n      return rows;\n    }\n  },\n\n  watch: {\n    \'rangeState.endDate\': function rangeStateEndDate(newVal) {\n      this.markRange(this.minDate, newVal);\n    },\n    minDate: function minDate(newVal, oldVal) {\n      if (date_tablevue_type_script_lang_js_getDateTimestamp(newVal) !== date_tablevue_type_script_lang_js_getDateTimestamp(oldVal)) {\n        this.markRange(this.minDate, this.maxDate);\n      }\n    },\n    maxDate: function maxDate(newVal, oldVal) {\n      if (date_tablevue_type_script_lang_js_getDateTimestamp(newVal) !== date_tablevue_type_script_lang_js_getDateTimestamp(oldVal)) {\n        this.markRange(this.minDate, this.maxDate);\n      }\n    }\n  },\n\n  data: function data() {\n    return {\n      tableRows: [[], [], [], [], [], []],\n      lastRow: null,\n      lastColumn: null\n    };\n  },\n\n\n  methods: {\n    cellMatchesDate: function cellMatchesDate(cell, date) {\n      var value = new Date(date);\n      return this.year === value.getFullYear() && this.month === value.getMonth() && Number(cell.text) === value.getDate();\n    },\n    getCellClasses: function getCellClasses(cell) {\n      var _this2 = this;\n\n      var selectionMode = this.selectionMode;\n      var defaultValue = this.defaultValue ? Array.isArray(this.defaultValue) ? this.defaultValue : [this.defaultValue] : [];\n\n      var classes = [];\n      if ((cell.type === \'normal\' || cell.type === \'today\') && !cell.disabled) {\n        classes.push(\'available\');\n        if (cell.type === \'today\') {\n          classes.push(\'today\');\n        }\n      } else {\n        classes.push(cell.type);\n      }\n\n      if (cell.type === \'normal\' && defaultValue.some(function (date) {\n        return _this2.cellMatchesDate(cell, date);\n      })) {\n        classes.push(\'default\');\n      }\n\n      if (selectionMode === \'day\' && (cell.type === \'normal\' || cell.type === \'today\') && this.cellMatchesDate(cell, this.value)) {\n        classes.push(\'current\');\n      }\n\n      if (cell.inRange && (cell.type === \'normal\' || cell.type === \'today\' || this.selectionMode === \'week\')) {\n        classes.push(\'in-range\');\n\n        if (cell.start) {\n          classes.push(\'start-date\');\n        }\n\n        if (cell.end) {\n          classes.push(\'end-date\');\n        }\n      }\n\n      if (cell.disabled) {\n        classes.push(\'disabled\');\n      }\n\n      if (cell.selected) {\n        classes.push(\'selected\');\n      }\n\n      if (cell.customClass) {\n        classes.push(cell.customClass);\n      }\n\n      return classes.join(\' \');\n    },\n    getDateOfCell: function getDateOfCell(row, column) {\n      var offsetFromStart = row * 7 + (column - (this.showWeekNumber ? 1 : 0)) - this.offsetDay;\n      return Object(date_util_["nextDate"])(this.startDate, offsetFromStart);\n    },\n    isWeekActive: function isWeekActive(cell) {\n      if (this.selectionMode !== \'week\') return false;\n      var newDate = new Date(this.year, this.month, 1);\n      var year = newDate.getFullYear();\n      var month = newDate.getMonth();\n\n      if (cell.type === \'prev-month\') {\n        newDate.setMonth(month === 0 ? 11 : month - 1);\n        newDate.setFullYear(month === 0 ? year - 1 : year);\n      }\n\n      if (cell.type === \'next-month\') {\n        newDate.setMonth(month === 11 ? 0 : month + 1);\n        newDate.setFullYear(month === 11 ? year + 1 : year);\n      }\n\n      newDate.setDate(parseInt(cell.text, 10));\n\n      if (Object(date_util_["isDate"])(this.value)) {\n        var dayOffset = (this.value.getDay() - this.firstDayOfWeek + 7) % 7 - 1;\n        var weekDate = Object(date_util_["prevDate"])(this.value, dayOffset);\n        return weekDate.getTime() === newDate.getTime();\n      }\n      return false;\n    },\n    markRange: function markRange(minDate, maxDate) {\n      minDate = date_tablevue_type_script_lang_js_getDateTimestamp(minDate);\n      maxDate = date_tablevue_type_script_lang_js_getDateTimestamp(maxDate) || minDate;\n      var _ref = [Math.min(minDate, maxDate), Math.max(minDate, maxDate)];\n      minDate = _ref[0];\n      maxDate = _ref[1];\n\n\n      var startDate = this.startDate;\n      var rows = this.rows;\n      for (var i = 0, k = rows.length; i < k; i++) {\n        var row = rows[i];\n        for (var j = 0, l = row.length; j < l; j++) {\n          if (this.showWeekNumber && j === 0) continue;\n\n          var _cell = row[j];\n          var index = i * 7 + j + (this.showWeekNumber ? -1 : 0);\n          var time = Object(date_util_["nextDate"])(startDate, index - this.offsetDay).getTime();\n\n          _cell.inRange = minDate && time >= minDate && time <= maxDate;\n          _cell.start = minDate && time === minDate;\n          _cell.end = maxDate && time === maxDate;\n        }\n      }\n    },\n    handleMouseMove: function handleMouseMove(event) {\n      if (!this.rangeState.selecting) return;\n\n      var target = event.target;\n      if (target.tagName === \'SPAN\') {\n        target = target.parentNode.parentNode;\n      }\n      if (target.tagName === \'DIV\') {\n        target = target.parentNode;\n      }\n      if (target.tagName !== \'TD\') return;\n\n      var row = target.parentNode.rowIndex - 1;\n      var column = target.cellIndex;\n\n      // can not select disabled date\n      if (this.rows[row][column].disabled) return;\n\n      // only update rangeState when mouse moves to a new cell\n      // this avoids frequent Date object creation and improves performance\n      if (row !== this.lastRow || column !== this.lastColumn) {\n        this.lastRow = row;\n        this.lastColumn = column;\n        this.$emit(\'changerange\', {\n          minDate: this.minDate,\n          maxDate: this.maxDate,\n          rangeState: {\n            selecting: true,\n            endDate: this.getDateOfCell(row, column)\n          }\n        });\n      }\n    },\n    handleClick: function handleClick(event) {\n      var target = event.target;\n      if (target.tagName === \'SPAN\') {\n        target = target.parentNode.parentNode;\n      }\n      if (target.tagName === \'DIV\') {\n        target = target.parentNode;\n      }\n\n      if (target.tagName !== \'TD\') return;\n\n      var row = target.parentNode.rowIndex - 1;\n      var column = this.selectionMode === \'week\' ? 1 : target.cellIndex;\n      var cell = this.rows[row][column];\n\n      if (cell.disabled || cell.type === \'week\') return;\n\n      var newDate = this.getDateOfCell(row, column);\n\n      if (this.selectionMode === \'range\') {\n        if (!this.rangeState.selecting) {\n          this.$emit(\'pick\', { minDate: newDate, maxDate: null });\n          this.rangeState.selecting = true;\n        } else {\n          if (newDate >= this.minDate) {\n            this.$emit(\'pick\', { minDate: this.minDate, maxDate: newDate });\n          } else {\n            this.$emit(\'pick\', { minDate: newDate, maxDate: this.minDate });\n          }\n          this.rangeState.selecting = false;\n        }\n      } else if (this.selectionMode === \'day\') {\n        this.$emit(\'pick\', newDate);\n      } else if (this.selectionMode === \'week\') {\n        var weekNumber = Object(date_util_["getWeekNumber"])(newDate);\n        var value = newDate.getFullYear() + \'w\' + weekNumber;\n        this.$emit(\'pick\', {\n          year: newDate.getFullYear(),\n          week: weekNumber,\n          value: value,\n          date: newDate\n        });\n      } else if (this.selectionMode === \'dates\') {\n        var _value = this.value || [];\n        var newValue = cell.selected ? date_tablevue_type_script_lang_js_removeFromArray(_value, function (date) {\n          return date.getTime() === newDate.getTime();\n        }) : [].concat(_value, [newDate]);\n        this.$emit(\'pick\', newValue);\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue?vue&type=script&lang=js&\n /* harmony default export */ var basic_date_tablevue_type_script_lang_js_ = (date_tablevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/date-picker/src/basic/date-table.vue\n\n\n\n\n\n/* normalize component */\n\nvar date_table_component = Object(componentNormalizer["a" /* default */])(\n  basic_date_tablevue_type_script_lang_js_,\n  date_tablevue_type_template_id_5d1f3341_render,\n  date_tablevue_type_template_id_5d1f3341_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var date_table_api; }\ndate_table_component.options.__file = "packages/date-picker/src/basic/date-table.vue"\n/* harmony default export */ var date_table = (date_table_component.exports);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var datevue_type_script_lang_js_ = ({\n  mixins: [locale_default.a],\n\n  directives: { Clickoutside: clickoutside_default.a },\n\n  watch: {\n    showTime: function showTime(val) {\n      var _this = this;\n\n      /* istanbul ignore if */\n      if (!val) return;\n      this.$nextTick(function (_) {\n        var inputElm = _this.$refs.input.$el;\n        if (inputElm) {\n          _this.pickerWidth = inputElm.getBoundingClientRect().width + 10;\n        }\n      });\n    },\n    value: function value(val) {\n      if (this.selectionMode === \'dates\' && this.value) return;\n      if (Object(date_util_["isDate"])(val)) {\n        this.date = new Date(val);\n      } else {\n        this.date = this.getDefaultValue();\n      }\n    },\n    defaultValue: function defaultValue(val) {\n      if (!Object(date_util_["isDate"])(this.value)) {\n        this.date = val ? new Date(val) : new Date();\n      }\n    },\n    timePickerVisible: function timePickerVisible(val) {\n      var _this2 = this;\n\n      if (val) this.$nextTick(function () {\n        return _this2.$refs.timepicker.adjustSpinners();\n      });\n    },\n    selectionMode: function selectionMode(newVal) {\n      if (newVal === \'month\') {\n        /* istanbul ignore next */\n        if (this.currentView !== \'year\' || this.currentView !== \'month\') {\n          this.currentView = \'month\';\n        }\n      } else if (newVal === \'dates\') {\n        this.currentView = \'date\';\n      }\n    }\n  },\n\n  methods: {\n    proxyTimePickerDataProperties: function proxyTimePickerDataProperties() {\n      var _this3 = this;\n\n      var format = function format(timeFormat) {\n        _this3.$refs.timepicker.format = timeFormat;\n      };\n      var value = function value(_value) {\n        _this3.$refs.timepicker.value = _value;\n      };\n      var date = function date(_date) {\n        _this3.$refs.timepicker.date = _date;\n      };\n      var selectableRange = function selectableRange(_selectableRange) {\n        _this3.$refs.timepicker.selectableRange = _selectableRange;\n      };\n\n      this.$watch(\'value\', value);\n      this.$watch(\'date\', date);\n      this.$watch(\'selectableRange\', selectableRange);\n\n      format(this.timeFormat);\n      value(this.value);\n      date(this.date);\n      selectableRange(this.selectableRange);\n    },\n    handleClear: function handleClear() {\n      this.date = this.getDefaultValue();\n      this.$emit(\'pick\', null);\n    },\n    emit: function emit(value) {\n      var _this4 = this;\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (!value) {\n        this.$emit.apply(this, [\'pick\', value].concat(args));\n      } else if (Array.isArray(value)) {\n        var dates = value.map(function (date) {\n          return _this4.showTime ? Object(date_util_["clearMilliseconds"])(date) : Object(date_util_["clearTime"])(date);\n        });\n        this.$emit.apply(this, [\'pick\', dates].concat(args));\n      } else {\n        this.$emit.apply(this, [\'pick\', this.showTime ? Object(date_util_["clearMilliseconds"])(value) : Object(date_util_["clearTime"])(value)].concat(args));\n      }\n      this.userInputDate = null;\n      this.userInputTime = null;\n    },\n\n\n    // resetDate() {\n    //   this.date = new Date(this.date);\n    // },\n\n    showMonthPicker: function showMonthPicker() {\n      this.currentView = \'month\';\n    },\n    showYearPicker: function showYearPicker() {\n      this.currentView = \'year\';\n    },\n\n\n    // XXX: 没用到\n    // handleLabelClick() {\n    //   if (this.currentView === \'date\') {\n    //     this.showMonthPicker();\n    //   } else if (this.currentView === \'month\') {\n    //     this.showYearPicker();\n    //   }\n    // },\n\n    prevMonth: function prevMonth() {\n      this.date = Object(date_util_["prevMonth"])(this.date);\n    },\n    nextMonth: function nextMonth() {\n      this.date = Object(date_util_["nextMonth"])(this.date);\n    },\n    prevYear: function prevYear() {\n      if (this.currentView === \'year\') {\n        this.date = Object(date_util_["prevYear"])(this.date, 10);\n      } else {\n        this.date = Object(date_util_["prevYear"])(this.date);\n      }\n    },\n    nextYear: function nextYear() {\n      if (this.currentView === \'year\') {\n        this.date = Object(date_util_["nextYear"])(this.date, 10);\n      } else {\n        this.date = Object(date_util_["nextYear"])(this.date);\n      }\n    },\n    handleShortcutClick: function handleShortcutClick(shortcut) {\n      if (shortcut.onClick) {\n        shortcut.onClick(this);\n      }\n    },\n    handleTimePick: function handleTimePick(value, visible, first) {\n      if (Object(date_util_["isDate"])(value)) {\n        var newDate = this.value ? Object(date_util_["modifyTime"])(this.value, value.getHours(), value.getMinutes(), value.getSeconds()) : Object(date_util_["modifyWithTimeString"])(this.getDefaultValue(), this.defaultTime);\n        this.date = newDate;\n        this.emit(this.date, true);\n      } else {\n        this.emit(value, true);\n      }\n      if (!first) {\n        this.timePickerVisible = visible;\n      }\n    },\n    handleTimePickClose: function handleTimePickClose() {\n      this.timePickerVisible = false;\n    },\n    handleMonthPick: function handleMonthPick(month) {\n      if (this.selectionMode === \'month\') {\n        this.date = Object(date_util_["modifyDate"])(this.date, this.year, month, 1);\n        this.emit(this.date);\n      } else {\n        this.date = Object(date_util_["changeYearMonthAndClampDate"])(this.date, this.year, month);\n        // TODO: should emit intermediate value ??\n        // this.emit(this.date);\n        this.currentView = \'date\';\n      }\n    },\n    handleDatePick: function handleDatePick(value) {\n      if (this.selectionMode === \'day\') {\n        var newDate = this.value ? Object(date_util_["modifyDate"])(this.value, value.getFullYear(), value.getMonth(), value.getDate()) : Object(date_util_["modifyWithTimeString"])(value, this.defaultTime);\n        // change default time while out of selectableRange\n        if (!this.checkDateWithinRange(newDate)) {\n          newDate = Object(date_util_["modifyDate"])(this.selectableRange[0][0], value.getFullYear(), value.getMonth(), value.getDate());\n        }\n        this.date = newDate;\n        this.emit(this.date, this.showTime);\n      } else if (this.selectionMode === \'week\') {\n        this.emit(value.date);\n      } else if (this.selectionMode === \'dates\') {\n        this.emit(value, true); // set false to keep panel open\n      }\n    },\n    handleYearPick: function handleYearPick(year) {\n      if (this.selectionMode === \'year\') {\n        this.date = Object(date_util_["modifyDate"])(this.date, year, 0, 1);\n        this.emit(this.date);\n      } else {\n        this.date = Object(date_util_["changeYearMonthAndClampDate"])(this.date, year, this.month);\n        // TODO: should emit intermediate value ??\n        // this.emit(this.date, true);\n        this.currentView = \'month\';\n      }\n    },\n    changeToNow: function changeToNow() {\n      // NOTE: not a permanent solution\n      //       consider disable "now" button in the future\n      if ((!this.disabledDate || !this.disabledDate(new Date())) && this.checkDateWithinRange(new Date())) {\n        this.date = new Date();\n        this.emit(this.date);\n      }\n    },\n    confirm: function confirm() {\n      if (this.selectionMode === \'dates\') {\n        this.emit(this.value);\n      } else {\n        // value were emitted in handle{Date,Time}Pick, nothing to update here\n        // deal with the scenario where: user opens the picker, then confirm without doing anything\n        var value = this.value ? this.value : Object(date_util_["modifyWithTimeString"])(this.getDefaultValue(), this.defaultTime);\n        this.date = new Date(value); // refresh date\n        this.emit(value);\n      }\n    },\n    resetView: function resetView() {\n      if (this.selectionMode === \'month\') {\n        this.currentView = \'month\';\n      } else if (this.selectionMode === \'year\') {\n        this.currentView = \'year\';\n      } else {\n        this.currentView = \'date\';\n      }\n    },\n    handleEnter: function handleEnter() {\n      document.body.addEventListener(\'keydown\', this.handleKeydown);\n    },\n    handleLeave: function handleLeave() {\n      this.$emit(\'dodestroy\');\n      document.body.removeEventListener(\'keydown\', this.handleKeydown);\n    },\n    handleKeydown: function handleKeydown(event) {\n      var keyCode = event.keyCode;\n      var list = [38, 40, 37, 39];\n      if (this.visible && !this.timePickerVisible) {\n        if (list.indexOf(keyCode) !== -1) {\n          this.handleKeyControl(keyCode);\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        if (keyCode === 13 && this.userInputDate === null && this.userInputTime === null) {\n          // Enter\n          this.emit(this.date, false);\n        }\n      }\n    },\n    handleKeyControl: function handleKeyControl(keyCode) {\n      var mapping = {\n        \'year\': {\n          38: -4, 40: 4, 37: -1, 39: 1, offset: function offset(date, step) {\n            return date.setFullYear(date.getFullYear() + step);\n          }\n        },\n        \'month\': {\n          38: -4, 40: 4, 37: -1, 39: 1, offset: function offset(date, step) {\n            return date.setMonth(date.getMonth() + step);\n          }\n        },\n        \'week\': {\n          38: -1, 40: 1, 37: -1, 39: 1, offset: function offset(date, step) {\n            return date.setDate(date.getDate() + step * 7);\n          }\n        },\n        \'day\': {\n          38: -7, 40: 7, 37: -1, 39: 1, offset: function offset(date, step) {\n            return date.setDate(date.getDate() + step);\n          }\n        }\n      };\n      var mode = this.selectionMode;\n      var year = 3.1536e10;\n      var now = this.date.getTime();\n      var newDate = new Date(this.date.getTime());\n      while (Math.abs(now - newDate.getTime()) <= year) {\n        var map = mapping[mode];\n        map.offset(newDate, map[keyCode]);\n        if (typeof this.disabledDate === \'function\' && this.disabledDate(newDate)) {\n          continue;\n        }\n        this.date = newDate;\n        this.$emit(\'pick\', newDate, true);\n        break;\n      }\n    },\n    handleVisibleTimeChange: function handleVisibleTimeChange(value) {\n      var time = Object(date_util_["parseDate"])(value, this.timeFormat);\n      if (time && this.checkDateWithinRange(time)) {\n        this.date = Object(date_util_["modifyDate"])(time, this.year, this.month, this.monthDate);\n        this.userInputTime = null;\n        this.$refs.timepicker.value = this.date;\n        this.timePickerVisible = false;\n        this.emit(this.date, true);\n      }\n    },\n    handleVisibleDateChange: function handleVisibleDateChange(value) {\n      var date = Object(date_util_["parseDate"])(value, this.dateFormat);\n      if (date) {\n        if (typeof this.disabledDate === \'function\' && this.disabledDate(date)) {\n          return;\n        }\n        this.date = Object(date_util_["modifyTime"])(date, this.date.getHours(), this.date.getMinutes(), this.date.getSeconds());\n        this.userInputDate = null;\n        this.resetView();\n        this.emit(this.date, true);\n      }\n    },\n    isValidValue: function isValidValue(value) {\n      return value && !isNaN(value) && (typeof this.disabledDate === \'function\' ? !this.disabledDate(value) : true) && this.checkDateWithinRange(value);\n    },\n    getDefaultValue: function getDefaultValue() {\n      // if default-value is set, return it\n      // otherwise, return now (the moment this method gets called)\n      return this.defaultValue ? new Date(this.defaultValue) : new Date();\n    },\n    checkDateWithinRange: function checkDateWithinRange(date) {\n      return this.selectableRange.length > 0 ? Object(date_util_["timeWithinRange"])(date, this.selectableRange, this.format || \'HH:mm:ss\') : true;\n    }\n  },\n\n  components: {\n    TimePicker: panel_time["a" /* default */], YearTable: year_table, MonthTable: month_table, DateTable: date_table, ElInput: input_default.a, ElButton: button_default.a\n  },\n\n  data: function data() {\n    return {\n      popperClass: \'\',\n      date: new Date(),\n      value: \'\',\n      defaultValue: null, // use getDefaultValue() for time computation\n      defaultTime: null,\n      showTime: false,\n      selectionMode: \'day\',\n      shortcuts: \'\',\n      visible: false,\n      currentView: \'date\',\n      disabledDate: \'\',\n      cellClassName: \'\',\n      selectableRange: [],\n      firstDayOfWeek: 7,\n      showWeekNumber: false,\n      timePickerVisible: false,\n      format: \'\',\n      arrowControl: false,\n      userInputDate: null,\n      userInputTime: null\n    };\n  },\n\n\n  computed: {\n    year: function year() {\n      return this.date.getFullYear();\n    },\n    month: function month() {\n      return this.date.getMonth();\n    },\n    week: function week() {\n      return Object(date_util_["getWeekNumber"])(this.date);\n    },\n    monthDate: function monthDate() {\n      return this.date.getDate();\n    },\n    footerVisible: function footerVisible() {\n      return this.showTime || this.selectionMode === \'dates\';\n    },\n    visibleTime: function visibleTime() {\n      if (this.userInputTime !== null) {\n        return this.userInputTime;\n      } else {\n        return Object(date_util_["formatDate"])(this.value || this.defaultValue, this.timeFormat);\n      }\n    },\n    visibleDate: function visibleDate() {\n      if (this.userInputDate !== null) {\n        return this.userInputDate;\n      } else {\n        return Object(date_util_["formatDate"])(this.value || this.defaultValue, this.dateFormat);\n      }\n    },\n    yearLabel: function yearLabel() {\n      var yearTranslation = this.t(\'el.datepicker.year\');\n      if (this.currentView === \'year\') {\n        var startYear = Math.floor(this.year / 10) * 10;\n        if (yearTranslation) {\n          return startYear + \' \' + yearTranslation + \' - \' + (startYear + 9) + \' \' + yearTranslation;\n        }\n        return startYear + \' - \' + (startYear + 9);\n      }\n      return this.year + \' \' + yearTranslation;\n    },\n    timeFormat: function timeFormat() {\n      if (this.format) {\n        return Object(date_util_["extractTimeFormat"])(this.format);\n      } else {\n        return \'HH:mm:ss\';\n      }\n    },\n    dateFormat: function dateFormat() {\n      if (this.format) {\n        return Object(date_util_["extractDateFormat"])(this.format);\n      } else {\n        return \'yyyy-MM-dd\';\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue?vue&type=script&lang=js&\n /* harmony default export */ var panel_datevue_type_script_lang_js_ = (datevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/date-picker/src/panel/date.vue\n\n\n\n\n\n/* normalize component */\n\nvar date_component = Object(componentNormalizer["a" /* default */])(\n  panel_datevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var date_api; }\ndate_component.options.__file = "packages/date-picker/src/panel/date.vue"\n/* harmony default export */ var panel_date = (date_component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date-range.vue?vue&type=template&id=2652849a&\nvar date_rangevue_type_template_id_2652849a_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "transition",\n    {\n      attrs: { name: "el-zoom-in-top" },\n      on: {\n        "after-leave": function($event) {\n          _vm.$emit("dodestroy")\n        }\n      }\n    },\n    [\n      _c(\n        "div",\n        {\n          directives: [\n            {\n              name: "show",\n              rawName: "v-show",\n              value: _vm.visible,\n              expression: "visible"\n            }\n          ],\n          staticClass: "el-picker-panel el-date-range-picker el-popper",\n          class: [\n            {\n              "has-sidebar": _vm.$slots.sidebar || _vm.shortcuts,\n              "has-time": _vm.showTime\n            },\n            _vm.popperClass\n          ]\n        },\n        [\n          _c(\n            "div",\n            { staticClass: "el-picker-panel__body-wrapper" },\n            [\n              _vm._t("sidebar"),\n              _vm.shortcuts\n                ? _c(\n                    "div",\n                    { staticClass: "el-picker-panel__sidebar" },\n                    _vm._l(_vm.shortcuts, function(shortcut, key) {\n                      return _c(\n                        "button",\n                        {\n                          key: key,\n                          staticClass: "el-picker-panel__shortcut",\n                          attrs: { type: "button" },\n                          on: {\n                            click: function($event) {\n                              _vm.handleShortcutClick(shortcut)\n                            }\n                          }\n                        },\n                        [_vm._v(_vm._s(shortcut.text))]\n                      )\n                    }),\n                    0\n                  )\n                : _vm._e(),\n              _c("div", { staticClass: "el-picker-panel__body" }, [\n                _vm.showTime\n                  ? _c(\n                      "div",\n                      { staticClass: "el-date-range-picker__time-header" },\n                      [\n                        _c(\n                          "span",\n                          { staticClass: "el-date-range-picker__editors-wrap" },\n                          [\n                            _c(\n                              "span",\n                              {\n                                staticClass:\n                                  "el-date-range-picker__time-picker-wrap"\n                              },\n                              [\n                                _c("el-input", {\n                                  ref: "minInput",\n                                  staticClass: "el-date-range-picker__editor",\n                                  attrs: {\n                                    size: "small",\n                                    disabled: _vm.rangeState.selecting,\n                                    placeholder: _vm.t(\n                                      "el.datepicker.startDate"\n                                    ),\n                                    value: _vm.minVisibleDate\n                                  },\n                                  on: {\n                                    input: function(val) {\n                                      return _vm.handleDateInput(val, "min")\n                                    },\n                                    change: function(val) {\n                                      return _vm.handleDateChange(val, "min")\n                                    }\n                                  }\n                                })\n                              ],\n                              1\n                            ),\n                            _c(\n                              "span",\n                              {\n                                directives: [\n                                  {\n                                    name: "clickoutside",\n                                    rawName: "v-clickoutside",\n                                    value: _vm.handleMinTimeClose,\n                                    expression: "handleMinTimeClose"\n                                  }\n                                ],\n                                staticClass:\n                                  "el-date-range-picker__time-picker-wrap"\n                              },\n                              [\n                                _c("el-input", {\n                                  staticClass: "el-date-range-picker__editor",\n                                  attrs: {\n                                    size: "small",\n                                    disabled: _vm.rangeState.selecting,\n                                    placeholder: _vm.t(\n                                      "el.datepicker.startTime"\n                                    ),\n                                    value: _vm.minVisibleTime\n                                  },\n                                  on: {\n                                    focus: function($event) {\n                                      _vm.minTimePickerVisible = true\n                                    },\n                                    input: function(val) {\n                                      return _vm.handleTimeInput(val, "min")\n                                    },\n                                    change: function(val) {\n                                      return _vm.handleTimeChange(val, "min")\n                                    }\n                                  }\n                                }),\n                                _c("time-picker", {\n                                  ref: "minTimePicker",\n                                  attrs: {\n                                    "time-arrow-control": _vm.arrowControl,\n                                    visible: _vm.minTimePickerVisible\n                                  },\n                                  on: {\n                                    pick: _vm.handleMinTimePick,\n                                    mounted: function($event) {\n                                      _vm.$refs.minTimePicker.format =\n                                        _vm.timeFormat\n                                    }\n                                  }\n                                })\n                              ],\n                              1\n                            )\n                          ]\n                        ),\n                        _c("span", { staticClass: "el-icon-arrow-right" }),\n                        _c(\n                          "span",\n                          {\n                            staticClass:\n                              "el-date-range-picker__editors-wrap is-right"\n                          },\n                          [\n                            _c(\n                              "span",\n                              {\n                                staticClass:\n                                  "el-date-range-picker__time-picker-wrap"\n                              },\n                              [\n                                _c("el-input", {\n                                  staticClass: "el-date-range-picker__editor",\n                                  attrs: {\n                                    size: "small",\n                                    disabled: _vm.rangeState.selecting,\n                                    placeholder: _vm.t("el.datepicker.endDate"),\n                                    value: _vm.maxVisibleDate,\n                                    readonly: !_vm.minDate\n                                  },\n                                  on: {\n                                    input: function(val) {\n                                      return _vm.handleDateInput(val, "max")\n                                    },\n                                    change: function(val) {\n                                      return _vm.handleDateChange(val, "max")\n                                    }\n                                  }\n                                })\n                              ],\n                              1\n                            ),\n                            _c(\n                              "span",\n                              {\n                                directives: [\n                                  {\n                                    name: "clickoutside",\n                                    rawName: "v-clickoutside",\n                                    value: _vm.handleMaxTimeClose,\n                                    expression: "handleMaxTimeClose"\n                                  }\n                                ],\n                                staticClass:\n                                  "el-date-range-picker__time-picker-wrap"\n                              },\n                              [\n                                _c("el-input", {\n                                  staticClass: "el-date-range-picker__editor",\n                                  attrs: {\n                                    size: "small",\n                                    disabled: _vm.rangeState.selecting,\n                                    placeholder: _vm.t("el.datepicker.endTime"),\n                                    value: _vm.maxVisibleTime,\n                                    readonly: !_vm.minDate\n                                  },\n                                  on: {\n                                    focus: function($event) {\n                                      _vm.minDate &&\n                                        (_vm.maxTimePickerVisible = true)\n                                    },\n                                    input: function(val) {\n                                      return _vm.handleTimeInput(val, "max")\n                                    },\n                                    change: function(val) {\n                                      return _vm.handleTimeChange(val, "max")\n                                    }\n                                  }\n                                }),\n                                _c("time-picker", {\n                                  ref: "maxTimePicker",\n                                  attrs: {\n                                    "time-arrow-control": _vm.arrowControl,\n                                    visible: _vm.maxTimePickerVisible\n                                  },\n                                  on: {\n                                    pick: _vm.handleMaxTimePick,\n                                    mounted: function($event) {\n                                      _vm.$refs.maxTimePicker.format =\n                                        _vm.timeFormat\n                                    }\n                                  }\n                                })\n                              ],\n                              1\n                            )\n                          ]\n                        )\n                      ]\n                    )\n                  : _vm._e(),\n                _c(\n                  "div",\n                  {\n                    staticClass:\n                      "el-picker-panel__content el-date-range-picker__content is-left"\n                  },\n                  [\n                    _c("div", { staticClass: "el-date-range-picker__header" }, [\n                      _c("button", {\n                        staticClass:\n                          "el-picker-panel__icon-btn el-icon-d-arrow-left",\n                        attrs: { type: "button" },\n                        on: { click: _vm.leftPrevYear }\n                      }),\n                      _c("button", {\n                        staticClass:\n                          "el-picker-panel__icon-btn el-icon-arrow-left",\n                        attrs: { type: "button" },\n                        on: { click: _vm.leftPrevMonth }\n                      }),\n                      _vm.unlinkPanels\n                        ? _c("button", {\n                            staticClass:\n                              "el-picker-panel__icon-btn el-icon-d-arrow-right",\n                            class: { "is-disabled": !_vm.enableYearArrow },\n                            attrs: {\n                              type: "button",\n                              disabled: !_vm.enableYearArrow\n                            },\n                            on: { click: _vm.leftNextYear }\n                          })\n                        : _vm._e(),\n                      _vm.unlinkPanels\n                        ? _c("button", {\n                            staticClass:\n                              "el-picker-panel__icon-btn el-icon-arrow-right",\n                            class: { "is-disabled": !_vm.enableMonthArrow },\n                            attrs: {\n                              type: "button",\n                              disabled: !_vm.enableMonthArrow\n                            },\n                            on: { click: _vm.leftNextMonth }\n                          })\n                        : _vm._e(),\n                      _c("div", [_vm._v(_vm._s(_vm.leftLabel))])\n                    ]),\n                    _c("date-table", {\n                      attrs: {\n                        "selection-mode": "range",\n                        date: _vm.leftDate,\n                        "default-value": _vm.defaultValue,\n                        "min-date": _vm.minDate,\n                        "max-date": _vm.maxDate,\n                        "range-state": _vm.rangeState,\n                        "disabled-date": _vm.disabledDate,\n                        "cell-class-name": _vm.cellClassName,\n                        "first-day-of-week": _vm.firstDayOfWeek\n                      },\n                      on: {\n                        changerange: _vm.handleChangeRange,\n                        pick: _vm.handleRangePick\n                      }\n                    })\n                  ],\n                  1\n                ),\n                _c(\n                  "div",\n                  {\n                    staticClass:\n                      "el-picker-panel__content el-date-range-picker__content is-right"\n                  },\n                  [\n                    _c("div", { staticClass: "el-date-range-picker__header" }, [\n                      _vm.unlinkPanels\n                        ? _c("button", {\n                            staticClass:\n                              "el-picker-panel__icon-btn el-icon-d-arrow-left",\n                            class: { "is-disabled": !_vm.enableYearArrow },\n                            attrs: {\n                              type: "button",\n                              disabled: !_vm.enableYearArrow\n                            },\n                            on: { click: _vm.rightPrevYear }\n                          })\n                        : _vm._e(),\n                      _vm.unlinkPanels\n                        ? _c("button", {\n                            staticClass:\n                              "el-picker-panel__icon-btn el-icon-arrow-left",\n                            class: { "is-disabled": !_vm.enableMonthArrow },\n                            attrs: {\n                              type: "button",\n                              disabled: !_vm.enableMonthArrow\n                            },\n                            on: { click: _vm.rightPrevMonth }\n                          })\n                        : _vm._e(),\n                      _c("button", {\n                        staticClass:\n                          "el-picker-panel__icon-btn el-icon-d-arrow-right",\n                        attrs: { type: "button" },\n                        on: { click: _vm.rightNextYear }\n                      }),\n                      _c("button", {\n                        staticClass:\n                          "el-picker-panel__icon-btn el-icon-arrow-right",\n                        attrs: { type: "button" },\n                        on: { click: _vm.rightNextMonth }\n                      }),\n                      _c("div", [_vm._v(_vm._s(_vm.rightLabel))])\n                    ]),\n                    _c("date-table", {\n                      attrs: {\n                        "selection-mode": "range",\n                        date: _vm.rightDate,\n                        "default-value": _vm.defaultValue,\n                        "min-date": _vm.minDate,\n                        "max-date": _vm.maxDate,\n                        "range-state": _vm.rangeState,\n                        "disabled-date": _vm.disabledDate,\n                        "cell-class-name": _vm.cellClassName,\n                        "first-day-of-week": _vm.firstDayOfWeek\n                      },\n                      on: {\n                        changerange: _vm.handleChangeRange,\n                        pick: _vm.handleRangePick\n                      }\n                    })\n                  ],\n                  1\n                )\n              ])\n            ],\n            2\n          ),\n          _vm.showTime\n            ? _c(\n                "div",\n                { staticClass: "el-picker-panel__footer" },\n                [\n                  _c(\n                    "el-button",\n                    {\n                      staticClass: "el-picker-panel__link-btn",\n                      attrs: { size: "mini", type: "text" },\n                      on: { click: _vm.handleClear }\n                    },\n                    [\n                      _vm._v(\n                        "\\n        " +\n                          _vm._s(_vm.t("el.datepicker.clear")) +\n                          "\\n      "\n                      )\n                    ]\n                  ),\n                  _c(\n                    "el-button",\n                    {\n                      staticClass: "el-picker-panel__link-btn",\n                      attrs: {\n                        plain: "",\n                        size: "mini",\n                        disabled: _vm.btnDisabled\n                      },\n                      on: {\n                        click: function($event) {\n                          _vm.handleConfirm(false)\n                        }\n                      }\n                    },\n                    [\n                      _vm._v(\n                        "\\n        " +\n                          _vm._s(_vm.t("el.datepicker.confirm")) +\n                          "\\n      "\n                      )\n                    ]\n                  )\n                ],\n                1\n              )\n            : _vm._e()\n        ]\n      )\n    ]\n  )\n}\nvar date_rangevue_type_template_id_2652849a_staticRenderFns = []\ndate_rangevue_type_template_id_2652849a_render._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue?vue&type=template&id=2652849a&\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/date-range.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\nvar date_rangevue_type_script_lang_js_calcDefaultValue = function calcDefaultValue(defaultValue) {\n  if (Array.isArray(defaultValue)) {\n    return [new Date(defaultValue[0]), new Date(defaultValue[1])];\n  } else if (defaultValue) {\n    return [new Date(defaultValue), Object(date_util_["nextDate"])(new Date(defaultValue), 1)];\n  } else {\n    return [new Date(), Object(date_util_["nextDate"])(new Date(), 1)];\n  }\n};\n\n/* harmony default export */ var date_rangevue_type_script_lang_js_ = ({\n  mixins: [locale_default.a],\n\n  directives: { Clickoutside: clickoutside_default.a },\n\n  computed: {\n    btnDisabled: function btnDisabled() {\n      return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));\n    },\n    leftLabel: function leftLabel() {\n      return this.leftDate.getFullYear() + \' \' + this.t(\'el.datepicker.year\') + \' \' + this.t(\'el.datepicker.month\' + (this.leftDate.getMonth() + 1));\n    },\n    rightLabel: function rightLabel() {\n      return this.rightDate.getFullYear() + \' \' + this.t(\'el.datepicker.year\') + \' \' + this.t(\'el.datepicker.month\' + (this.rightDate.getMonth() + 1));\n    },\n    leftYear: function leftYear() {\n      return this.leftDate.getFullYear();\n    },\n    leftMonth: function leftMonth() {\n      return this.leftDate.getMonth();\n    },\n    leftMonthDate: function leftMonthDate() {\n      return this.leftDate.getDate();\n    },\n    rightYear: function rightYear() {\n      return this.rightDate.getFullYear();\n    },\n    rightMonth: function rightMonth() {\n      return this.rightDate.getMonth();\n    },\n    rightMonthDate: function rightMonthDate() {\n      return this.rightDate.getDate();\n    },\n    minVisibleDate: function minVisibleDate() {\n      if (this.dateUserInput.min !== null) return this.dateUserInput.min;\n      if (this.minDate) return Object(date_util_["formatDate"])(this.minDate, this.dateFormat);\n      return \'\';\n    },\n    maxVisibleDate: function maxVisibleDate() {\n      if (this.dateUserInput.max !== null) return this.dateUserInput.max;\n      if (this.maxDate || this.minDate) return Object(date_util_["formatDate"])(this.maxDate || this.minDate, this.dateFormat);\n      return \'\';\n    },\n    minVisibleTime: function minVisibleTime() {\n      if (this.timeUserInput.min !== null) return this.timeUserInput.min;\n      if (this.minDate) return Object(date_util_["formatDate"])(this.minDate, this.timeFormat);\n      return \'\';\n    },\n    maxVisibleTime: function maxVisibleTime() {\n      if (this.timeUserInput.max !== null) return this.timeUserInput.max;\n      if (this.maxDate || this.minDate) return Object(date_util_["formatDate"])(this.maxDate || this.minDate, this.timeFormat);\n      return \'\';\n    },\n    timeFormat: function timeFormat() {\n      if (this.format) {\n        return Object(date_util_["extractTimeFormat"])(this.format);\n      } else {\n        return \'HH:mm:ss\';\n      }\n    },\n    dateFormat: function dateFormat() {\n      if (this.format) {\n        return Object(date_util_["extractDateFormat"])(this.format);\n      } else {\n        return \'yyyy-MM-dd\';\n      }\n    },\n    enableMonthArrow: function enableMonthArrow() {\n      var nextMonth = (this.leftMonth + 1) % 12;\n      var yearOffset = this.leftMonth + 1 >= 12 ? 1 : 0;\n      return this.unlinkPanels && new Date(this.leftYear + yearOffset, nextMonth) < new Date(this.rightYear, this.rightMonth);\n    },\n    enableYearArrow: function enableYearArrow() {\n      return this.unlinkPanels && this.rightYear * 12 + this.rightMonth - (this.leftYear * 12 + this.leftMonth + 1) >= 12;\n    }\n  },\n\n  data: function data() {\n    return {\n      popperClass: \'\',\n      value: [],\n      defaultValue: null,\n      defaultTime: null,\n      minDate: \'\',\n      maxDate: \'\',\n      leftDate: new Date(),\n      rightDate: Object(date_util_["nextMonth"])(new Date()),\n      rangeState: {\n        endDate: null,\n        selecting: false,\n        row: null,\n        column: null\n      },\n      showTime: false,\n      shortcuts: \'\',\n      visible: \'\',\n      disabledDate: \'\',\n      cellClassName: \'\',\n      firstDayOfWeek: 7,\n      minTimePickerVisible: false,\n      maxTimePickerVisible: false,\n      format: \'\',\n      arrowControl: false,\n      unlinkPanels: false,\n      dateUserInput: {\n        min: null,\n        max: null\n      },\n      timeUserInput: {\n        min: null,\n        max: null\n      }\n    };\n  },\n\n\n  watch: {\n    minDate: function minDate(val) {\n      var _this = this;\n\n      this.dateUserInput.min = null;\n      this.timeUserInput.min = null;\n      this.$nextTick(function () {\n        if (_this.$refs.maxTimePicker && _this.maxDate && _this.maxDate < _this.minDate) {\n          var format = \'HH:mm:ss\';\n          _this.$refs.maxTimePicker.selectableRange = [[Object(date_util_["parseDate"])(Object(date_util_["formatDate"])(_this.minDate, format), format), Object(date_util_["parseDate"])(\'23:59:59\', format)]];\n        }\n      });\n      if (val && this.$refs.minTimePicker) {\n        this.$refs.minTimePicker.date = val;\n        this.$refs.minTimePicker.value = val;\n      }\n    },\n    maxDate: function maxDate(val) {\n      this.dateUserInput.max = null;\n      this.timeUserInput.max = null;\n      if (val && this.$refs.maxTimePicker) {\n        this.$refs.maxTimePicker.date = val;\n        this.$refs.maxTimePicker.value = val;\n      }\n    },\n    minTimePickerVisible: function minTimePickerVisible(val) {\n      var _this2 = this;\n\n      if (val) {\n        this.$nextTick(function () {\n          _this2.$refs.minTimePicker.date = _this2.minDate;\n          _this2.$refs.minTimePicker.value = _this2.minDate;\n          _this2.$refs.minTimePicker.adjustSpinners();\n        });\n      }\n    },\n    maxTimePickerVisible: function maxTimePickerVisible(val) {\n      var _this3 = this;\n\n      if (val) {\n        this.$nextTick(function () {\n          _this3.$refs.maxTimePicker.date = _this3.maxDate;\n          _this3.$refs.maxTimePicker.value = _this3.maxDate;\n          _this3.$refs.maxTimePicker.adjustSpinners();\n        });\n      }\n    },\n    value: function value(newVal) {\n      if (!newVal) {\n        this.minDate = null;\n        this.maxDate = null;\n      } else if (Array.isArray(newVal)) {\n        this.minDate = Object(date_util_["isDate"])(newVal[0]) ? new Date(newVal[0]) : null;\n        this.maxDate = Object(date_util_["isDate"])(newVal[1]) ? new Date(newVal[1]) : null;\n        if (this.minDate) {\n          this.leftDate = this.minDate;\n          if (this.unlinkPanels && this.maxDate) {\n            var minDateYear = this.minDate.getFullYear();\n            var minDateMonth = this.minDate.getMonth();\n            var maxDateYear = this.maxDate.getFullYear();\n            var maxDateMonth = this.maxDate.getMonth();\n            this.rightDate = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? Object(date_util_["nextMonth"])(this.maxDate) : this.maxDate;\n          } else {\n            this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n          }\n        } else {\n          this.leftDate = date_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];\n          this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n        }\n      }\n    },\n    defaultValue: function defaultValue(val) {\n      if (!Array.isArray(this.value)) {\n        var _calcDefaultValue = date_rangevue_type_script_lang_js_calcDefaultValue(val),\n            left = _calcDefaultValue[0],\n            right = _calcDefaultValue[1];\n\n        this.leftDate = left;\n        this.rightDate = val && val[1] && this.unlinkPanels ? right : Object(date_util_["nextMonth"])(this.leftDate);\n      }\n    }\n  },\n\n  methods: {\n    handleClear: function handleClear() {\n      this.minDate = null;\n      this.maxDate = null;\n      this.leftDate = date_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];\n      this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n      this.$emit(\'pick\', null);\n    },\n    handleChangeRange: function handleChangeRange(val) {\n      this.minDate = val.minDate;\n      this.maxDate = val.maxDate;\n      this.rangeState = val.rangeState;\n    },\n    handleDateInput: function handleDateInput(value, type) {\n      this.dateUserInput[type] = value;\n      if (value.length !== this.dateFormat.length) return;\n      var parsedValue = Object(date_util_["parseDate"])(value, this.dateFormat);\n\n      if (parsedValue) {\n        if (typeof this.disabledDate === \'function\' && this.disabledDate(new Date(parsedValue))) {\n          return;\n        }\n        if (type === \'min\') {\n          this.minDate = Object(date_util_["modifyDate"])(this.minDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());\n          this.leftDate = new Date(parsedValue);\n          if (!this.unlinkPanels) {\n            this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n          }\n        } else {\n          this.maxDate = Object(date_util_["modifyDate"])(this.maxDate || new Date(), parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());\n          this.rightDate = new Date(parsedValue);\n          if (!this.unlinkPanels) {\n            this.leftDate = Object(date_util_["prevMonth"])(parsedValue);\n          }\n        }\n      }\n    },\n    handleDateChange: function handleDateChange(value, type) {\n      var parsedValue = Object(date_util_["parseDate"])(value, this.dateFormat);\n      if (parsedValue) {\n        if (type === \'min\') {\n          this.minDate = Object(date_util_["modifyDate"])(this.minDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());\n          if (this.minDate > this.maxDate) {\n            this.maxDate = this.minDate;\n          }\n        } else {\n          this.maxDate = Object(date_util_["modifyDate"])(this.maxDate, parsedValue.getFullYear(), parsedValue.getMonth(), parsedValue.getDate());\n          if (this.maxDate < this.minDate) {\n            this.minDate = this.maxDate;\n          }\n        }\n      }\n    },\n    handleTimeInput: function handleTimeInput(value, type) {\n      var _this4 = this;\n\n      this.timeUserInput[type] = value;\n      if (value.length !== this.timeFormat.length) return;\n      var parsedValue = Object(date_util_["parseDate"])(value, this.timeFormat);\n\n      if (parsedValue) {\n        if (type === \'min\') {\n          this.minDate = Object(date_util_["modifyTime"])(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());\n          this.$nextTick(function (_) {\n            return _this4.$refs.minTimePicker.adjustSpinners();\n          });\n        } else {\n          this.maxDate = Object(date_util_["modifyTime"])(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());\n          this.$nextTick(function (_) {\n            return _this4.$refs.maxTimePicker.adjustSpinners();\n          });\n        }\n      }\n    },\n    handleTimeChange: function handleTimeChange(value, type) {\n      var parsedValue = Object(date_util_["parseDate"])(value, this.timeFormat);\n      if (parsedValue) {\n        if (type === \'min\') {\n          this.minDate = Object(date_util_["modifyTime"])(this.minDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());\n          if (this.minDate > this.maxDate) {\n            this.maxDate = this.minDate;\n          }\n          this.$refs.minTimePicker.value = this.minDate;\n          this.minTimePickerVisible = false;\n        } else {\n          this.maxDate = Object(date_util_["modifyTime"])(this.maxDate, parsedValue.getHours(), parsedValue.getMinutes(), parsedValue.getSeconds());\n          if (this.maxDate < this.minDate) {\n            this.minDate = this.maxDate;\n          }\n          this.$refs.maxTimePicker.value = this.minDate;\n          this.maxTimePickerVisible = false;\n        }\n      }\n    },\n    handleRangePick: function handleRangePick(val) {\n      var _this5 = this;\n\n      var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var defaultTime = this.defaultTime || [];\n      var minDate = Object(date_util_["modifyWithTimeString"])(val.minDate, defaultTime[0]);\n      var maxDate = Object(date_util_["modifyWithTimeString"])(val.maxDate, defaultTime[1]);\n\n      if (this.maxDate === maxDate && this.minDate === minDate) {\n        return;\n      }\n      this.onPick && this.onPick(val);\n      this.maxDate = maxDate;\n      this.minDate = minDate;\n\n      // workaround for https://github.com/ElemeFE/element/issues/7539, should remove this block when we don\'t have to care about Chromium 55 - 57\n      setTimeout(function () {\n        _this5.maxDate = maxDate;\n        _this5.minDate = minDate;\n      }, 10);\n      if (!close || this.showTime) return;\n      this.handleConfirm();\n    },\n    handleShortcutClick: function handleShortcutClick(shortcut) {\n      if (shortcut.onClick) {\n        shortcut.onClick(this);\n      }\n    },\n    handleMinTimePick: function handleMinTimePick(value, visible, first) {\n      this.minDate = this.minDate || new Date();\n      if (value) {\n        this.minDate = Object(date_util_["modifyTime"])(this.minDate, value.getHours(), value.getMinutes(), value.getSeconds());\n      }\n\n      if (!first) {\n        this.minTimePickerVisible = visible;\n      }\n\n      if (!this.maxDate || this.maxDate && this.maxDate.getTime() < this.minDate.getTime()) {\n        this.maxDate = new Date(this.minDate);\n      }\n    },\n    handleMinTimeClose: function handleMinTimeClose() {\n      this.minTimePickerVisible = false;\n    },\n    handleMaxTimePick: function handleMaxTimePick(value, visible, first) {\n      if (this.maxDate && value) {\n        this.maxDate = Object(date_util_["modifyTime"])(this.maxDate, value.getHours(), value.getMinutes(), value.getSeconds());\n      }\n\n      if (!first) {\n        this.maxTimePickerVisible = visible;\n      }\n\n      if (this.maxDate && this.minDate && this.minDate.getTime() > this.maxDate.getTime()) {\n        this.minDate = new Date(this.maxDate);\n      }\n    },\n    handleMaxTimeClose: function handleMaxTimeClose() {\n      this.maxTimePickerVisible = false;\n    },\n\n\n    // leftPrev*, rightNext* need to take care of `unlinkPanels`\n    leftPrevYear: function leftPrevYear() {\n      this.leftDate = Object(date_util_["prevYear"])(this.leftDate);\n      if (!this.unlinkPanels) {\n        this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n      }\n    },\n    leftPrevMonth: function leftPrevMonth() {\n      this.leftDate = Object(date_util_["prevMonth"])(this.leftDate);\n      if (!this.unlinkPanels) {\n        this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n      }\n    },\n    rightNextYear: function rightNextYear() {\n      if (!this.unlinkPanels) {\n        this.leftDate = Object(date_util_["nextYear"])(this.leftDate);\n        this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n      } else {\n        this.rightDate = Object(date_util_["nextYear"])(this.rightDate);\n      }\n    },\n    rightNextMonth: function rightNextMonth() {\n      if (!this.unlinkPanels) {\n        this.leftDate = Object(date_util_["nextMonth"])(this.leftDate);\n        this.rightDate = Object(date_util_["nextMonth"])(this.leftDate);\n      } else {\n        this.rightDate = Object(date_util_["nextMonth"])(this.rightDate);\n      }\n    },\n\n\n    // leftNext*, rightPrev* are called when `unlinkPanels` is true\n    leftNextYear: function leftNextYear() {\n      this.leftDate = Object(date_util_["nextYear"])(this.leftDate);\n    },\n    leftNextMonth: function leftNextMonth() {\n      this.leftDate = Object(date_util_["nextMonth"])(this.leftDate);\n    },\n    rightPrevYear: function rightPrevYear() {\n      this.rightDate = Object(date_util_["prevYear"])(this.rightDate);\n    },\n    rightPrevMonth: function rightPrevMonth() {\n      this.rightDate = Object(date_util_["prevMonth"])(this.rightDate);\n    },\n    handleConfirm: function handleConfirm() {\n      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.isValidValue([this.minDate, this.maxDate])) {\n        this.$emit(\'pick\', [this.minDate, this.maxDate], visible);\n      }\n    },\n    isValidValue: function isValidValue(value) {\n      return Array.isArray(value) && value && value[0] && value[1] && Object(date_util_["isDate"])(value[0]) && Object(date_util_["isDate"])(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === \'function\' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);\n    },\n    resetView: function resetView() {\n      // NOTE: this is a hack to reset {min, max}Date on picker open.\n      // TODO: correct way of doing so is to refactor {min, max}Date to be dependent on value and internal selection state\n      //       an alternative would be resetView whenever picker becomes visible, should also investigate date-panel\'s resetView\n      if (this.minDate && this.maxDate == null) this.rangeState.selecting = false;\n      this.minDate = this.value && Object(date_util_["isDate"])(this.value[0]) ? new Date(this.value[0]) : null;\n      this.maxDate = this.value && Object(date_util_["isDate"])(this.value[0]) ? new Date(this.value[1]) : null;\n    }\n  },\n\n  components: { TimePicker: panel_time["a" /* default */], DateTable: date_table, ElInput: input_default.a, ElButton: button_default.a }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue?vue&type=script&lang=js&\n /* harmony default export */ var panel_date_rangevue_type_script_lang_js_ = (date_rangevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/date-picker/src/panel/date-range.vue\n\n\n\n\n\n/* normalize component */\n\nvar date_range_component = Object(componentNormalizer["a" /* default */])(\n  panel_date_rangevue_type_script_lang_js_,\n  date_rangevue_type_template_id_2652849a_render,\n  date_rangevue_type_template_id_2652849a_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var date_range_api; }\ndate_range_component.options.__file = "packages/date-picker/src/panel/date-range.vue"\n/* harmony default export */ var date_range = (date_range_component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/month-range.vue?vue&type=template&id=f2645fb8&\nvar month_rangevue_type_template_id_f2645fb8_render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "transition",\n    {\n      attrs: { name: "el-zoom-in-top" },\n      on: {\n        "after-leave": function($event) {\n          _vm.$emit("dodestroy")\n        }\n      }\n    },\n    [\n      _c(\n        "div",\n        {\n          directives: [\n            {\n              name: "show",\n              rawName: "v-show",\n              value: _vm.visible,\n              expression: "visible"\n            }\n          ],\n          staticClass: "el-picker-panel el-date-range-picker el-popper",\n          class: [\n            {\n              "has-sidebar": _vm.$slots.sidebar || _vm.shortcuts\n            },\n            _vm.popperClass\n          ]\n        },\n        [\n          _c(\n            "div",\n            { staticClass: "el-picker-panel__body-wrapper" },\n            [\n              _vm._t("sidebar"),\n              _vm.shortcuts\n                ? _c(\n                    "div",\n                    { staticClass: "el-picker-panel__sidebar" },\n                    _vm._l(_vm.shortcuts, function(shortcut, key) {\n                      return _c(\n                        "button",\n                        {\n                          key: key,\n                          staticClass: "el-picker-panel__shortcut",\n                          attrs: { type: "button" },\n                          on: {\n                            click: function($event) {\n                              _vm.handleShortcutClick(shortcut)\n                            }\n                          }\n                        },\n                        [_vm._v(_vm._s(shortcut.text))]\n                      )\n                    }),\n                    0\n                  )\n                : _vm._e(),\n              _c("div", { staticClass: "el-picker-panel__body" }, [\n                _c(\n                  "div",\n                  {\n                    staticClass:\n                      "el-picker-panel__content el-date-range-picker__content is-left"\n                  },\n                  [\n                    _c("div", { staticClass: "el-date-range-picker__header" }, [\n                      _c("button", {\n                        staticClass:\n                          "el-picker-panel__icon-btn el-icon-d-arrow-left",\n                        attrs: { type: "button" },\n                        on: { click: _vm.leftPrevYear }\n                      }),\n                      _vm.unlinkPanels\n                        ? _c("button", {\n                            staticClass:\n                              "el-picker-panel__icon-btn el-icon-d-arrow-right",\n                            class: { "is-disabled": !_vm.enableYearArrow },\n                            attrs: {\n                              type: "button",\n                              disabled: !_vm.enableYearArrow\n                            },\n                            on: { click: _vm.leftNextYear }\n                          })\n                        : _vm._e(),\n                      _c("div", [_vm._v(_vm._s(_vm.leftLabel))])\n                    ]),\n                    _c("month-table", {\n                      attrs: {\n                        "selection-mode": "range",\n                        date: _vm.leftDate,\n                        "default-value": _vm.defaultValue,\n                        "min-date": _vm.minDate,\n                        "max-date": _vm.maxDate,\n                        "range-state": _vm.rangeState,\n                        "disabled-date": _vm.disabledDate\n                      },\n                      on: {\n                        changerange: _vm.handleChangeRange,\n                        pick: _vm.handleRangePick\n                      }\n                    })\n                  ],\n                  1\n                ),\n                _c(\n                  "div",\n                  {\n                    staticClass:\n                      "el-picker-panel__content el-date-range-picker__content is-right"\n                  },\n                  [\n                    _c("div", { staticClass: "el-date-range-picker__header" }, [\n                      _vm.unlinkPanels\n                        ? _c("button", {\n                            staticClass:\n                              "el-picker-panel__icon-btn el-icon-d-arrow-left",\n                            class: { "is-disabled": !_vm.enableYearArrow },\n                            attrs: {\n                              type: "button",\n                              disabled: !_vm.enableYearArrow\n                            },\n                            on: { click: _vm.rightPrevYear }\n                          })\n                        : _vm._e(),\n                      _c("button", {\n                        staticClass:\n                          "el-picker-panel__icon-btn el-icon-d-arrow-right",\n                        attrs: { type: "button" },\n                        on: { click: _vm.rightNextYear }\n                      }),\n                      _c("div", [_vm._v(_vm._s(_vm.rightLabel))])\n                    ]),\n                    _c("month-table", {\n                      attrs: {\n                        "selection-mode": "range",\n                        date: _vm.rightDate,\n                        "default-value": _vm.defaultValue,\n                        "min-date": _vm.minDate,\n                        "max-date": _vm.maxDate,\n                        "range-state": _vm.rangeState,\n                        "disabled-date": _vm.disabledDate\n                      },\n                      on: {\n                        changerange: _vm.handleChangeRange,\n                        pick: _vm.handleRangePick\n                      }\n                    })\n                  ],\n                  1\n                )\n              ])\n            ],\n            2\n          )\n        ]\n      )\n    ]\n  )\n}\nvar month_rangevue_type_template_id_f2645fb8_staticRenderFns = []\nmonth_rangevue_type_template_id_f2645fb8_render._withStripped = true\n\n\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue?vue&type=template&id=f2645fb8&\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/date-picker/src/panel/month-range.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\nvar month_rangevue_type_script_lang_js_calcDefaultValue = function calcDefaultValue(defaultValue) {\n  if (Array.isArray(defaultValue)) {\n    return [new Date(defaultValue[0]), new Date(defaultValue[1])];\n  } else if (defaultValue) {\n    return [new Date(defaultValue), Object(date_util_["nextMonth"])(new Date(defaultValue))];\n  } else {\n    return [new Date(), Object(date_util_["nextMonth"])(new Date())];\n  }\n};\n/* harmony default export */ var month_rangevue_type_script_lang_js_ = ({\n  mixins: [locale_default.a],\n\n  directives: { Clickoutside: clickoutside_default.a },\n\n  computed: {\n    btnDisabled: function btnDisabled() {\n      return !(this.minDate && this.maxDate && !this.selecting && this.isValidValue([this.minDate, this.maxDate]));\n    },\n    leftLabel: function leftLabel() {\n      return this.leftDate.getFullYear() + \' \' + this.t(\'el.datepicker.year\');\n    },\n    rightLabel: function rightLabel() {\n      return this.rightDate.getFullYear() + \' \' + this.t(\'el.datepicker.year\');\n    },\n    leftYear: function leftYear() {\n      return this.leftDate.getFullYear();\n    },\n    rightYear: function rightYear() {\n      return this.rightDate.getFullYear() === this.leftDate.getFullYear() ? this.leftDate.getFullYear() + 1 : this.rightDate.getFullYear();\n    },\n    enableYearArrow: function enableYearArrow() {\n      return this.unlinkPanels && this.rightYear > this.leftYear + 1;\n    }\n  },\n\n  data: function data() {\n    return {\n      popperClass: \'\',\n      value: [],\n      defaultValue: null,\n      defaultTime: null,\n      minDate: \'\',\n      maxDate: \'\',\n      leftDate: new Date(),\n      rightDate: Object(date_util_["nextYear"])(new Date()),\n      rangeState: {\n        endDate: null,\n        selecting: false,\n        row: null,\n        column: null\n      },\n      shortcuts: \'\',\n      visible: \'\',\n      disabledDate: \'\',\n      format: \'\',\n      arrowControl: false,\n      unlinkPanels: false\n    };\n  },\n\n\n  watch: {\n    value: function value(newVal) {\n      if (!newVal) {\n        this.minDate = null;\n        this.maxDate = null;\n      } else if (Array.isArray(newVal)) {\n        this.minDate = Object(date_util_["isDate"])(newVal[0]) ? new Date(newVal[0]) : null;\n        this.maxDate = Object(date_util_["isDate"])(newVal[1]) ? new Date(newVal[1]) : null;\n        if (this.minDate) {\n          this.leftDate = this.minDate;\n          if (this.unlinkPanels && this.maxDate) {\n            var minDateYear = this.minDate.getFullYear();\n            var maxDateYear = this.maxDate.getFullYear();\n            this.rightDate = minDateYear === maxDateYear ? Object(date_util_["nextYear"])(this.maxDate) : this.maxDate;\n          } else {\n            this.rightDate = Object(date_util_["nextYear"])(this.leftDate);\n          }\n        } else {\n          this.leftDate = month_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];\n          this.rightDate = Object(date_util_["nextYear"])(this.leftDate);\n        }\n      }\n    },\n    defaultValue: function defaultValue(val) {\n      if (!Array.isArray(this.value)) {\n        var _calcDefaultValue = month_rangevue_type_script_lang_js_calcDefaultValue(val),\n            left = _calcDefaultValue[0],\n            right = _calcDefaultValue[1];\n\n        this.leftDate = left;\n        this.rightDate = val && val[1] && left.getFullYear() !== right.getFullYear() && this.unlinkPanels ? right : Object(date_util_["nextYear"])(this.leftDate);\n      }\n    }\n  },\n\n  methods: {\n    handleClear: function handleClear() {\n      this.minDate = null;\n      this.maxDate = null;\n      this.leftDate = month_rangevue_type_script_lang_js_calcDefaultValue(this.defaultValue)[0];\n      this.rightDate = Object(date_util_["nextYear"])(this.leftDate);\n      this.$emit(\'pick\', null);\n    },\n    handleChangeRange: function handleChangeRange(val) {\n      this.minDate = val.minDate;\n      this.maxDate = val.maxDate;\n      this.rangeState = val.rangeState;\n    },\n    handleRangePick: function handleRangePick(val) {\n      var _this = this;\n\n      var close = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var defaultTime = this.defaultTime || [];\n      var minDate = Object(date_util_["modifyWithTimeString"])(val.minDate, defaultTime[0]);\n      var maxDate = Object(date_util_["modifyWithTimeString"])(val.maxDate, defaultTime[1]);\n      if (this.maxDate === maxDate && this.minDate === minDate) {\n        return;\n      }\n      this.onPick && this.onPick(val);\n      this.maxDate = maxDate;\n      this.minDate = minDate;\n\n      // workaround for https://github.com/ElemeFE/element/issues/7539, should remove this block when we don\'t have to care about Chromium 55 - 57\n      setTimeout(function () {\n        _this.maxDate = maxDate;\n        _this.minDate = minDate;\n      }, 10);\n      if (!close) return;\n      this.handleConfirm();\n    },\n    handleShortcutClick: function handleShortcutClick(shortcut) {\n      if (shortcut.onClick) {\n        shortcut.onClick(this);\n      }\n    },\n\n\n    // leftPrev*, rightNext* need to take care of `unlinkPanels`\n    leftPrevYear: function leftPrevYear() {\n      this.leftDate = Object(date_util_["prevYear"])(this.leftDate);\n      if (!this.unlinkPanels) {\n        this.rightDate = Object(date_util_["prevYear"])(this.rightDate);\n      }\n    },\n    rightNextYear: function rightNextYear() {\n      if (!this.unlinkPanels) {\n        this.leftDate = Object(date_util_["nextYear"])(this.leftDate);\n      }\n      this.rightDate = Object(date_util_["nextYear"])(this.rightDate);\n    },\n\n\n    // leftNext*, rightPrev* are called when `unlinkPanels` is true\n    leftNextYear: function leftNextYear() {\n      this.leftDate = Object(date_util_["nextYear"])(this.leftDate);\n    },\n    rightPrevYear: function rightPrevYear() {\n      this.rightDate = Object(date_util_["prevYear"])(this.rightDate);\n    },\n    handleConfirm: function handleConfirm() {\n      var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.isValidValue([this.minDate, this.maxDate])) {\n        this.$emit(\'pick\', [this.minDate, this.maxDate], visible);\n      }\n    },\n    isValidValue: function isValidValue(value) {\n      return Array.isArray(value) && value && value[0] && value[1] && Object(date_util_["isDate"])(value[0]) && Object(date_util_["isDate"])(value[1]) && value[0].getTime() <= value[1].getTime() && (typeof this.disabledDate === \'function\' ? !this.disabledDate(value[0]) && !this.disabledDate(value[1]) : true);\n    },\n    resetView: function resetView() {\n      // NOTE: this is a hack to reset {min, max}Date on picker open.\n      // TODO: correct way of doing so is to refactor {min, max}Date to be dependent on value and internal selection state\n      //       an alternative would be resetView whenever picker becomes visible, should also investigate date-panel\'s resetView\n      this.minDate = this.value && Object(date_util_["isDate"])(this.value[0]) ? new Date(this.value[0]) : null;\n      this.maxDate = this.value && Object(date_util_["isDate"])(this.value[0]) ? new Date(this.value[1]) : null;\n    }\n  },\n\n  components: { MonthTable: month_table, ElInput: input_default.a, ElButton: button_default.a }\n});\n// CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue?vue&type=script&lang=js&\n /* harmony default export */ var panel_month_rangevue_type_script_lang_js_ = (month_rangevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./packages/date-picker/src/panel/month-range.vue\n\n\n\n\n\n/* normalize component */\n\nvar month_range_component = Object(componentNormalizer["a" /* default */])(\n  panel_month_rangevue_type_script_lang_js_,\n  month_rangevue_type_template_id_f2645fb8_render,\n  month_rangevue_type_template_id_f2645fb8_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var month_range_api; }\nmonth_range_component.options.__file = "packages/date-picker/src/panel/month-range.vue"\n/* harmony default export */ var month_range = (month_range_component.exports);\n// CONCATENATED MODULE: ./packages/date-picker/src/picker/date-picker.js\n\n\n\n\n\nvar date_picker_getPanel = function getPanel(type) {\n  if (type === \'daterange\' || type === \'datetimerange\') {\n    return date_range;\n  } else if (type === \'monthrange\') {\n    return month_range;\n  }\n  return panel_date;\n};\n\n/* harmony default export */ var date_picker = ({\n  mixins: [picker["a" /* default */]],\n\n  name: \'ElDatePicker\',\n\n  props: {\n    type: {\n      type: String,\n      default: \'date\'\n    },\n    timeArrowControl: Boolean\n  },\n\n  watch: {\n    type: function type(_type) {\n      if (this.picker) {\n        this.unmountPicker();\n        this.panel = date_picker_getPanel(_type);\n        this.mountPicker();\n      } else {\n        this.panel = date_picker_getPanel(_type);\n      }\n    }\n  },\n\n  created: function created() {\n    this.panel = date_picker_getPanel(this.type);\n  }\n});\n// CONCATENATED MODULE: ./packages/date-picker/index.js\n\n\n/* istanbul ignore next */\ndate_picker.install = function install(Vue) {\n  Vue.component(date_picker.name, date_picker);\n};\n\n/* harmony default export */ var packages_date_picker = __webpack_exports__["default"] = (date_picker);\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvZGF0ZS1waWNrZXIuanM/YzI2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkZBQTJGLDJCQUEyQixFQUFFO0FBQ3hIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzRztBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FB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O0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRyxhQUFhO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxnQ0FBZ0MsMENBQTBDO0FBQzFFLFdBQVc7QUFDWCxnQ0FBZ0MsMENBQTBDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0g7QUFDQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTs7QUFFQSxlQUFlLHVDQUF1Qzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsd0ZBQXdGLGFBQWE7QUFDckc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esc0c7QUFDQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVC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QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNELDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSx1Q0FBdUM7O0FBRXREO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztB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LEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUNBQXVDOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRCx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsZUFBZTtBQUNmLENBQUM7QUFDRDtBQUNBLG9IO0FBQ0E7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUCIsImZpbGUiOiIxNjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDU1KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbGl6ZUNvbXBvbmVudDsgfSk7XG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy9kYXRlLXV0aWxcIik7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy9kb21cIik7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy91dGlsXCIpO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvbWl4aW5zL2VtaXR0ZXJcIik7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy92dWUtcG9wcGVyXCIpO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWxlbWVudC11aS9saWIvbWl4aW5zL2xvY2FsZVwiKTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInZ1ZVwiKTtcblxuLyoqKi8gfSksXG4vKiA4ICovLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy9tZXJnZVwiKTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi9pbnB1dFwiKTtcblxuLyoqKi8gfSksXG4vKiAxMSAqLyxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL3V0aWxzL2NsaWNrb3V0c2lkZVwiKTtcblxuLyoqKi8gfSksXG4vKiAxMyAqLyxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL2J1dHRvblwiKTtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi9zY3JvbGxiYXJcIik7XG5cbi8qKiovIH0pLFxuLyogMTYgKi8sXG4vKiAxNyAqLyxcbi8qIDE4ICovLFxuLyogMTkgKi8sXG4vKiAyMCAqLyxcbi8qIDIxICovLFxuLyogMjIgKi8sXG4vKiAyMyAqLyxcbi8qIDI0ICovLFxuLyogMjUgKi8sXG4vKiAyNiAqLyxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC90aW1lLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zZDkzOTA4OSZcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAge1xuICAgICAgYXR0cnM6IHsgbmFtZTogXCJlbC16b29tLWluLXRvcFwiIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcImFmdGVyLWxlYXZlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIF92bS4kZW1pdChcImRvZGVzdHJveVwiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdm0udmlzaWJsZSxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJ2aXNpYmxlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXRpbWUtcGFuZWwgZWwtcG9wcGVyXCIsXG4gICAgICAgICAgY2xhc3M6IF92bS5wb3BwZXJDbGFzc1xuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXBhbmVsX19jb250ZW50XCIsXG4gICAgICAgICAgICAgIGNsYXNzOiB7IFwiaGFzLXNlY29uZHNcIjogX3ZtLnNob3dTZWNvbmRzIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwidGltZS1zcGlubmVyXCIsIHtcbiAgICAgICAgICAgICAgICByZWY6IFwic3Bpbm5lclwiLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICBcImFycm93LWNvbnRyb2xcIjogX3ZtLnVzZUFycm93LFxuICAgICAgICAgICAgICAgICAgXCJzaG93LXNlY29uZHNcIjogX3ZtLnNob3dTZWNvbmRzLFxuICAgICAgICAgICAgICAgICAgXCJhbS1wbS1tb2RlXCI6IF92bS5hbVBtTW9kZSxcbiAgICAgICAgICAgICAgICAgIGRhdGU6IF92bS5kYXRlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlOiBfdm0uaGFuZGxlQ2hhbmdlLFxuICAgICAgICAgICAgICAgICAgXCJzZWxlY3QtcmFuZ2VcIjogX3ZtLnNldFNlbGVjdGlvblJhbmdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1wYW5lbF9fZm9vdGVyXCIgfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXBhbmVsX19idG4gY2FuY2VsXCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlQ2FuY2VsIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLnQoXCJlbC5kYXRlcGlja2VyLmNhbmNlbFwiKSkpXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1wYW5lbF9fYnRuXCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHsgY29uZmlybTogIV92bS5kaXNhYmxlZCB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdm0uaGFuZGxlQ29uZmlybSgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhfdm0udChcImVsLmRhdGVwaWNrZXIuY29uZmlybVwiKSkpXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pXG4gICAgICAgIF1cbiAgICAgIClcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvdGltZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9M2Q5MzkwODkmXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy9kYXRlLXV0aWxcIlxudmFyIGRhdGVfdXRpbF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvbWl4aW5zL2xvY2FsZVwiXG52YXIgbG9jYWxlXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgbG9jYWxlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGxvY2FsZV8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL2Jhc2ljL3RpbWUtc3Bpbm5lci52dWUgKyA0IG1vZHVsZXNcbnZhciB0aW1lX3NwaW5uZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BhbmVsL3RpbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG1peGluczogW2xvY2FsZV9kZWZhdWx0LmFdLFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBUaW1lU3Bpbm5lcjogdGltZV9zcGlubmVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dXG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICB2aXNpYmxlOiBCb29sZWFuLFxuICAgIHRpbWVBcnJvd0NvbnRyb2w6IEJvb2xlYW5cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIHZpc2libGU6IGZ1bmN0aW9uIHZpc2libGUodmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLiRyZWZzLnNwaW5uZXIuZW1pdFNlbGVjdFJhbmdlKCdob3VycycpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmVlZEluaXRBZGp1c3QgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG5ld1ZhbCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBkYXRlID0gdm9pZCAwO1xuICAgICAgaWYgKG5ld1ZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgZGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibGltaXRUaW1lUmFuZ2VcIl0pKG5ld1ZhbCwgdGhpcy5zZWxlY3RhYmxlUmFuZ2UsIHRoaXMuZm9ybWF0KTtcbiAgICAgIH0gZWxzZSBpZiAoIW5ld1ZhbCkge1xuICAgICAgICBkYXRlID0gdGhpcy5kZWZhdWx0VmFsdWUgPyBuZXcgRGF0ZSh0aGlzLmRlZmF1bHRWYWx1ZSkgOiBuZXcgRGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICAgICAgaWYgKHRoaXMudmlzaWJsZSAmJiB0aGlzLm5lZWRJbml0QWRqdXN0KSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5hZGp1c3RTcGlubmVycygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uZWVkSW5pdEFkanVzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0YWJsZVJhbmdlOiBmdW5jdGlvbiBzZWxlY3RhYmxlUmFuZ2UodmFsKSB7XG4gICAgICB0aGlzLiRyZWZzLnNwaW5uZXIuc2VsZWN0YWJsZVJhbmdlID0gdmFsO1xuICAgIH0sXG4gICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0VmFsdWUodmFsKSB7XG4gICAgICBpZiAoIU9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlXCJdKSh0aGlzLnZhbHVlKSkge1xuICAgICAgICB0aGlzLmRhdGUgPSB2YWwgPyBuZXcgRGF0ZSh2YWwpIDogbmV3IERhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9wcGVyQ2xhc3M6ICcnLFxuICAgICAgZm9ybWF0OiAnSEg6bW06c3MnLFxuICAgICAgdmFsdWU6ICcnLFxuICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICAgIG9sZFZhbHVlOiBuZXcgRGF0ZSgpLFxuICAgICAgc2VsZWN0YWJsZVJhbmdlOiBbXSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOiBbMCwgMl0sXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICBhcnJvd0NvbnRyb2w6IGZhbHNlLFxuICAgICAgbmVlZEluaXRBZGp1c3Q6IHRydWVcbiAgICB9O1xuICB9LFxuXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBzaG93U2Vjb25kczogZnVuY3Rpb24gc2hvd1NlY29uZHMoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZm9ybWF0IHx8ICcnKS5pbmRleE9mKCdzcycpICE9PSAtMTtcbiAgICB9LFxuICAgIHVzZUFycm93OiBmdW5jdGlvbiB1c2VBcnJvdygpIHtcbiAgICAgIHJldHVybiB0aGlzLmFycm93Q29udHJvbCB8fCB0aGlzLnRpbWVBcnJvd0NvbnRyb2wgfHwgZmFsc2U7XG4gICAgfSxcbiAgICBhbVBtTW9kZTogZnVuY3Rpb24gYW1QbU1vZGUoKSB7XG4gICAgICBpZiAoKHRoaXMuZm9ybWF0IHx8ICcnKS5pbmRleE9mKCdBJykgIT09IC0xKSByZXR1cm4gJ0EnO1xuICAgICAgaWYgKCh0aGlzLmZvcm1hdCB8fCAnJykuaW5kZXhPZignYScpICE9PSAtMSkgcmV0dXJuICdhJztcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZUNhbmNlbDogZnVuY3Rpb24gaGFuZGxlQ2FuY2VsKCkge1xuICAgICAgdGhpcy4kZW1pdCgncGljaycsIHRoaXMub2xkVmFsdWUsIGZhbHNlKTtcbiAgICB9LFxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGRhdGUpIHtcbiAgICAgIC8vIHRoaXMudmlzaWJsZSBhdm9pZHMgZWRnZSBjYXNlcywgd2hlbiB1c2Ugc2Nyb2xscyBkdXJpbmcgcGFuZWwgY2xvc2luZyBhbmltYXRpb25cbiAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJjbGVhck1pbGxpc2Vjb25kc1wiXSkoZGF0ZSk7XG4gICAgICAgIC8vIGlmIGRhdGUgaXMgb3V0IG9mIHJhbmdlLCBkbyBub3QgZW1pdFxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUodGhpcy5kYXRlKSkge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3BpY2snLCB0aGlzLmRhdGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRTZWxlY3Rpb25SYW5nZTogZnVuY3Rpb24gc2V0U2VsZWN0aW9uUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgdGhpcy4kZW1pdCgnc2VsZWN0LXJhbmdlJywgc3RhcnQsIGVuZCk7XG4gICAgICB0aGlzLnNlbGVjdGlvblJhbmdlID0gW3N0YXJ0LCBlbmRdO1xuICAgIH0sXG4gICAgaGFuZGxlQ29uZmlybTogZnVuY3Rpb24gaGFuZGxlQ29uZmlybSgpIHtcbiAgICAgIHZhciB2aXNpYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBmaXJzdCA9IGFyZ3VtZW50c1sxXTtcblxuICAgICAgaWYgKGZpcnN0KSByZXR1cm47XG4gICAgICB2YXIgZGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wiY2xlYXJNaWxsaXNlY29uZHNcIl0pKE9iamVjdChkYXRlX3V0aWxfW1wibGltaXRUaW1lUmFuZ2VcIl0pKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RhYmxlUmFuZ2UsIHRoaXMuZm9ybWF0KSk7XG4gICAgICB0aGlzLiRlbWl0KCdwaWNrJywgZGF0ZSwgdmlzaWJsZSwgZmlyc3QpO1xuICAgIH0sXG4gICAgaGFuZGxlS2V5ZG93bjogZnVuY3Rpb24gaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgdmFyIG1hcHBpbmcgPSB7IDM4OiAtMSwgNDA6IDEsIDM3OiAtMSwgMzk6IDEgfTtcblxuICAgICAgLy8gTGVmdCBvciBSaWdodFxuICAgICAgaWYgKGtleUNvZGUgPT09IDM3IHx8IGtleUNvZGUgPT09IDM5KSB7XG4gICAgICAgIHZhciBzdGVwID0gbWFwcGluZ1trZXlDb2RlXTtcbiAgICAgICAgdGhpcy5jaGFuZ2VTZWxlY3Rpb25SYW5nZShzdGVwKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBVcCBvciBEb3duXG4gICAgICBpZiAoa2V5Q29kZSA9PT0gMzggfHwga2V5Q29kZSA9PT0gNDApIHtcbiAgICAgICAgdmFyIF9zdGVwID0gbWFwcGluZ1trZXlDb2RlXTtcbiAgICAgICAgdGhpcy4kcmVmcy5zcGlubmVyLnNjcm9sbERvd24oX3N0ZXApO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1ZhbGlkVmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRWYWx1ZShkYXRlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJ0aW1lV2l0aGluUmFuZ2VcIl0pKGRhdGUsIHRoaXMuc2VsZWN0YWJsZVJhbmdlLCB0aGlzLmZvcm1hdCk7XG4gICAgfSxcbiAgICBhZGp1c3RTcGlubmVyczogZnVuY3Rpb24gYWRqdXN0U3Bpbm5lcnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmcy5zcGlubmVyLmFkanVzdFNwaW5uZXJzKCk7XG4gICAgfSxcbiAgICBjaGFuZ2VTZWxlY3Rpb25SYW5nZTogZnVuY3Rpb24gY2hhbmdlU2VsZWN0aW9uUmFuZ2Uoc3RlcCkge1xuICAgICAgdmFyIGxpc3QgPSBbMCwgM10uY29uY2F0KHRoaXMuc2hvd1NlY29uZHMgPyBbNl0gOiBbXSk7XG4gICAgICB2YXIgbWFwcGluZyA9IFsnaG91cnMnLCAnbWludXRlcyddLmNvbmNhdCh0aGlzLnNob3dTZWNvbmRzID8gWydzZWNvbmRzJ10gOiBbXSk7XG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2YodGhpcy5zZWxlY3Rpb25SYW5nZVswXSk7XG4gICAgICB2YXIgbmV4dCA9IChpbmRleCArIHN0ZXAgKyBsaXN0Lmxlbmd0aCkgJSBsaXN0Lmxlbmd0aDtcbiAgICAgIHRoaXMuJHJlZnMuc3Bpbm5lci5lbWl0U2VsZWN0UmFuZ2UobWFwcGluZ1tuZXh0XSk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLmhhbmRsZUNvbmZpcm0odHJ1ZSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy4kZW1pdCgnbW91bnRlZCcpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BhbmVsL3RpbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBhbmVsX3RpbWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAodGltZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbnZhciBjb21wb25lbnROb3JtYWxpemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvdGltZS52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBjb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIHBhbmVsX3RpbWV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BhbmVsL3RpbWUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRpbWUgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChjb21wb25lbnQuZXhwb3J0cyk7XG5cbi8qKiovIH0pLFxuLyogMjggKi8sXG4vKiAyOSAqLyxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGVsZW1lbnRfdWlfc3JjX3V0aWxzX2RvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBlbGVtZW50X3VpX3NyY191dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihlbGVtZW50X3VpX3NyY191dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9ICh7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgdmFyIGludGVydmFsID0gbnVsbDtcbiAgICB2YXIgc3RhcnRUaW1lID0gdm9pZCAwO1xuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgIHJldHVybiB2bm9kZS5jb250ZXh0W2JpbmRpbmcuZXhwcmVzc2lvbl0uYXBwbHkoKTtcbiAgICB9O1xuICAgIHZhciBjbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCAxMDApIHtcbiAgICAgICAgaGFuZGxlcigpO1xuICAgICAgfVxuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBpbnRlcnZhbCA9IG51bGw7XG4gICAgfTtcblxuICAgIE9iamVjdChlbGVtZW50X3VpX3NyY191dGlsc19kb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIm9uXCJdKShlbCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5idXR0b24gIT09IDApIHJldHVybjtcbiAgICAgIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBPYmplY3QoZWxlbWVudF91aV9zcmNfdXRpbHNfZG9tX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJvbmNlXCJdKShkb2N1bWVudCwgJ21vdXNldXAnLCBjbGVhcik7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoaGFuZGxlciwgMTAwKTtcbiAgICB9KTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMzEgKi8sXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGlja2VyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03OWFlMDY5ZiZcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gIV92bS5yYW5nZWRcbiAgICA/IF9jKFxuICAgICAgICBcImVsLWlucHV0XCIsXG4gICAgICAgIF92bS5fYihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImNsaWNrb3V0c2lkZVwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1jbGlja291dHNpZGVcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmhhbmRsZUNsb3NlLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiaGFuZGxlQ2xvc2VcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVmOiBcInJlZmVyZW5jZVwiLFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtZGF0ZS1lZGl0b3JcIixcbiAgICAgICAgICAgIGNsYXNzOiBcImVsLWRhdGUtZWRpdG9yLS1cIiArIF92bS50eXBlLFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgcmVhZG9ubHk6XG4gICAgICAgICAgICAgICAgIV92bS5lZGl0YWJsZSB8fFxuICAgICAgICAgICAgICAgIF92bS5yZWFkb25seSB8fFxuICAgICAgICAgICAgICAgIF92bS50eXBlID09PSBcImRhdGVzXCIgfHxcbiAgICAgICAgICAgICAgICBfdm0udHlwZSA9PT0gXCJ3ZWVrXCIsXG4gICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0ucGlja2VyRGlzYWJsZWQsXG4gICAgICAgICAgICAgIHNpemU6IF92bS5waWNrZXJTaXplLFxuICAgICAgICAgICAgICBuYW1lOiBfdm0ubmFtZSxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF92bS5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5kaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgIHZhbGlkYXRlRXZlbnQ6IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgZm9jdXM6IF92bS5oYW5kbGVGb2N1cyxcbiAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfdm0udXNlcklucHV0ID0gdmFsdWUpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNoYW5nZTogX3ZtLmhhbmRsZUNoYW5nZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hdGl2ZU9uOiB7XG4gICAgICAgICAgICAgIGtleWRvd246IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uaGFuZGxlS2V5ZG93bigkZXZlbnQpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uaGFuZGxlTW91c2VFbnRlcigkZXZlbnQpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1vdXNlbGVhdmU6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIF92bS5zaG93Q2xvc2UgPSBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImVsLWlucHV0XCIsXG4gICAgICAgICAgX3ZtLmZpcnN0SW5wdXRJZCxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApLFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLWlucHV0X19pY29uXCIsXG4gICAgICAgICAgICBjbGFzczogX3ZtLnRyaWdnZXJDbGFzcyxcbiAgICAgICAgICAgIGF0dHJzOiB7IHNsb3Q6IFwicHJlZml4XCIgfSxcbiAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlRm9jdXMgfSxcbiAgICAgICAgICAgIHNsb3Q6IFwicHJlZml4XCJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uaGF2ZVRyaWdnZXJcbiAgICAgICAgICAgID8gX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1pbnB1dF9faWNvblwiLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBbX3ZtLnNob3dDbG9zZSA/IFwiXCIgKyBfdm0uY2xlYXJJY29uIDogXCJcIl0sXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgc2xvdDogXCJzdWZmaXhcIiB9LFxuICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlQ2xpY2tJY29uIH0sXG4gICAgICAgICAgICAgICAgc2xvdDogXCJzdWZmaXhcIlxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICBdXG4gICAgICApXG4gICAgOiBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJjbGlja291dHNpZGVcIixcbiAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LWNsaWNrb3V0c2lkZVwiLFxuICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmhhbmRsZUNsb3NlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImhhbmRsZUNsb3NlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHJlZjogXCJyZWZlcmVuY2VcIixcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1kYXRlLWVkaXRvciBlbC1yYW5nZS1lZGl0b3IgZWwtaW5wdXRfX2lubmVyXCIsXG4gICAgICAgICAgY2xhc3M6IFtcbiAgICAgICAgICAgIFwiZWwtZGF0ZS1lZGl0b3ItLVwiICsgX3ZtLnR5cGUsXG4gICAgICAgICAgICBfdm0ucGlja2VyU2l6ZSA/IFwiZWwtcmFuZ2UtZWRpdG9yLS1cIiArIF92bS5waWNrZXJTaXplIDogXCJcIixcbiAgICAgICAgICAgIF92bS5waWNrZXJEaXNhYmxlZCA/IFwiaXMtZGlzYWJsZWRcIiA6IFwiXCIsXG4gICAgICAgICAgICBfdm0ucGlja2VyVmlzaWJsZSA/IFwiaXMtYWN0aXZlXCIgOiBcIlwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgY2xpY2s6IF92bS5oYW5kbGVSYW5nZUNsaWNrLFxuICAgICAgICAgICAgbW91c2VlbnRlcjogX3ZtLmhhbmRsZU1vdXNlRW50ZXIsXG4gICAgICAgICAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgX3ZtLnNob3dDbG9zZSA9IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5ZG93bjogX3ZtLmhhbmRsZUtleWRvd25cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcImlcIiwge1xuICAgICAgICAgICAgY2xhc3M6IFtcImVsLWlucHV0X19pY29uXCIsIFwiZWwtcmFuZ2VfX2ljb25cIiwgX3ZtLnRyaWdnZXJDbGFzc11cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXJhbmdlLWlucHV0XCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogXCJvZmZcIixcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdm0uc3RhcnRQbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0ucGlja2VyRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICByZWFkb25seTogIV92bS5lZGl0YWJsZSB8fCBfdm0ucmVhZG9ubHksXG4gICAgICAgICAgICAgICAgICBuYW1lOiBfdm0ubmFtZSAmJiBfdm0ubmFtZVswXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5kaXNwbGF5VmFsdWUgJiYgX3ZtLmRpc3BsYXlWYWx1ZVswXSB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogX3ZtLmhhbmRsZVN0YXJ0SW5wdXQsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2U6IF92bS5oYW5kbGVTdGFydENoYW5nZSxcbiAgICAgICAgICAgICAgICAgIGZvY3VzOiBfdm0uaGFuZGxlRm9jdXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgX3ZtLmZpcnN0SW5wdXRJZCxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIF92bS5fdChcInJhbmdlLXNlcGFyYXRvclwiLCBbXG4gICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJlbC1yYW5nZS1zZXBhcmF0b3JcIiB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnJhbmdlU2VwYXJhdG9yKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICAgICBfdm0uX2IoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1yYW5nZS1pbnB1dFwiLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IFwib2ZmXCIsXG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogX3ZtLmVuZFBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IF92bS5waWNrZXJEaXNhYmxlZCxcbiAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiAhX3ZtLmVkaXRhYmxlIHx8IF92bS5yZWFkb25seSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IF92bS5uYW1lICYmIF92bS5uYW1lWzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLmRpc3BsYXlWYWx1ZSAmJiBfdm0uZGlzcGxheVZhbHVlWzFdIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBfdm0uaGFuZGxlRW5kSW5wdXQsXG4gICAgICAgICAgICAgICAgICBjaGFuZ2U6IF92bS5oYW5kbGVFbmRDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICBmb2N1czogX3ZtLmhhbmRsZUZvY3VzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICAgICAgIF92bS5zZWNvbmRJbnB1dElkLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLmhhdmVUcmlnZ2VyXG4gICAgICAgICAgICA/IF9jKFwiaVwiLCB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtaW5wdXRfX2ljb24gZWwtcmFuZ2VfX2Nsb3NlLWljb25cIixcbiAgICAgICAgICAgICAgICBjbGFzczogW192bS5zaG93Q2xvc2UgPyBcIlwiICsgX3ZtLmNsZWFySWNvbiA6IFwiXCJdLFxuICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlQ2xpY2tJY29uIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgXSxcbiAgICAgICAgMlxuICAgICAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9waWNrZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTc5YWUwNjlmJlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwidnVlXCJcbnZhciBleHRlcm5hbF92dWVfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBleHRlcm5hbF92dWVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZXh0ZXJuYWxfdnVlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy9jbGlja291dHNpZGVcIlxudmFyIGNsaWNrb3V0c2lkZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBjbGlja291dHNpZGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2xpY2tvdXRzaWRlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy9kYXRlLXV0aWxcIlxudmFyIGRhdGVfdXRpbF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvdXRpbHMvdnVlLXBvcHBlclwiXG52YXIgdnVlX3BvcHBlcl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHZ1ZV9wb3BwZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX3BvcHBlcl8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvbWl4aW5zL2VtaXR0ZXJcIlxudmFyIGVtaXR0ZXJfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBlbWl0dGVyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGVtaXR0ZXJfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL2lucHV0XCJcbnZhciBpbnB1dF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBpbnB1dF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihpbnB1dF8pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvdXRpbHMvbWVyZ2VcIlxudmFyIG1lcmdlXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG52YXIgbWVyZ2VfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obWVyZ2VfKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BpY2tlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuXG5cblxudmFyIE5ld1BvcHBlciA9IHtcbiAgcHJvcHM6IHtcbiAgICBhcHBlbmRUb0JvZHk6IHZ1ZV9wb3BwZXJfZGVmYXVsdC5hLnByb3BzLmFwcGVuZFRvQm9keSxcbiAgICBvZmZzZXQ6IHZ1ZV9wb3BwZXJfZGVmYXVsdC5hLnByb3BzLm9mZnNldCxcbiAgICBib3VuZGFyaWVzUGFkZGluZzogdnVlX3BvcHBlcl9kZWZhdWx0LmEucHJvcHMuYm91bmRhcmllc1BhZGRpbmcsXG4gICAgYXJyb3dPZmZzZXQ6IHZ1ZV9wb3BwZXJfZGVmYXVsdC5hLnByb3BzLmFycm93T2Zmc2V0XG4gIH0sXG4gIG1ldGhvZHM6IHZ1ZV9wb3BwZXJfZGVmYXVsdC5hLm1ldGhvZHMsXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIG1lcmdlX2RlZmF1bHQoKSh7IHZpc2libGVBcnJvdzogdHJ1ZSB9LCB2dWVfcG9wcGVyX2RlZmF1bHQuYS5kYXRhKTtcbiAgfSxcblxuICBiZWZvcmVEZXN0cm95OiB2dWVfcG9wcGVyX2RlZmF1bHQuYS5iZWZvcmVEZXN0cm95XG59O1xuXG52YXIgREVGQVVMVF9GT1JNQVRTID0ge1xuICBkYXRlOiAneXl5eS1NTS1kZCcsXG4gIG1vbnRoOiAneXl5eS1NTScsXG4gIGRhdGV0aW1lOiAneXl5eS1NTS1kZCBISDptbTpzcycsXG4gIHRpbWU6ICdISDptbTpzcycsXG4gIHdlZWs6ICd5eXl5d1dXJyxcbiAgdGltZXJhbmdlOiAnSEg6bW06c3MnLFxuICBkYXRlcmFuZ2U6ICd5eXl5LU1NLWRkJyxcbiAgbW9udGhyYW5nZTogJ3l5eXktTU0nLFxuICBkYXRldGltZXJhbmdlOiAneXl5eS1NTS1kZCBISDptbTpzcycsXG4gIHllYXI6ICd5eXl5J1xufTtcbnZhciBIQVZFX1RSSUdHRVJfVFlQRVMgPSBbJ2RhdGUnLCAnZGF0ZXRpbWUnLCAndGltZScsICd0aW1lLXNlbGVjdCcsICd3ZWVrJywgJ21vbnRoJywgJ3llYXInLCAnZGF0ZXJhbmdlJywgJ21vbnRocmFuZ2UnLCAndGltZXJhbmdlJywgJ2RhdGV0aW1lcmFuZ2UnLCAnZGF0ZXMnXTtcbnZhciBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX0ZPUk1BVFRFUiA9IGZ1bmN0aW9uIERBVEVfRk9STUFUVEVSKHZhbHVlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCA9PT0gJ3RpbWVzdGFtcCcpIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImZvcm1hdERhdGVcIl0pKHZhbHVlLCBmb3JtYXQpO1xufTtcbnZhciBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX1BBUlNFUiA9IGZ1bmN0aW9uIERBVEVfUEFSU0VSKHRleHQsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ID09PSAndGltZXN0YW1wJykgcmV0dXJuIG5ldyBEYXRlKE51bWJlcih0ZXh0KSk7XG4gIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcInBhcnNlRGF0ZVwiXSkodGV4dCwgZm9ybWF0KTtcbn07XG52YXIgUkFOR0VfRk9STUFUVEVSID0gZnVuY3Rpb24gUkFOR0VfRk9STUFUVEVSKHZhbHVlLCBmb3JtYXQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzdGFydCA9IHZhbHVlWzBdO1xuICAgIHZhciBlbmQgPSB2YWx1ZVsxXTtcblxuICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgIHJldHVybiBbcGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfREFURV9GT1JNQVRURVIoc3RhcnQsIGZvcm1hdCksIHBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX0RBVEVfRk9STUFUVEVSKGVuZCwgZm9ybWF0KV07XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn07XG52YXIgUkFOR0VfUEFSU0VSID0gZnVuY3Rpb24gUkFOR0VfUEFSU0VSKGFycmF5LCBmb3JtYXQsIHNlcGFyYXRvcikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgYXJyYXkgPSBhcnJheS5zcGxpdChzZXBhcmF0b3IpO1xuICB9XG4gIGlmIChhcnJheS5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcmFuZ2UxID0gYXJyYXlbMF07XG4gICAgdmFyIHJhbmdlMiA9IGFycmF5WzFdO1xuXG4gICAgcmV0dXJuIFtwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX1BBUlNFUihyYW5nZTEsIGZvcm1hdCksIHBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX0RBVEVfUEFSU0VSKHJhbmdlMiwgZm9ybWF0KV07XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcbnZhciBUWVBFX1ZBTFVFX1JFU09MVkVSX01BUCA9IHtcbiAgZGVmYXVsdDoge1xuICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgICB9LFxuICAgIHBhcnNlcjogZnVuY3Rpb24gcGFyc2VyKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgfHwgdGV4dCA9PT0gJycpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9LFxuICB3ZWVrOiB7XG4gICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsdWUsIGZvcm1hdCkge1xuICAgICAgdmFyIHdlZWsgPSBPYmplY3QoZGF0ZV91dGlsX1tcImdldFdlZWtOdW1iZXJcIl0pKHZhbHVlKTtcbiAgICAgIHZhciBtb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgICB2YXIgdHJ1ZURhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICBpZiAod2VlayA9PT0gMSAmJiBtb250aCA9PT0gMTEpIHtcbiAgICAgICAgdHJ1ZURhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHRydWVEYXRlLnNldERhdGUodHJ1ZURhdGUuZ2V0RGF0ZSgpICsgMyAtICh0cnVlRGF0ZS5nZXREYXkoKSArIDYpICUgNyk7XG4gICAgICB9XG4gICAgICB2YXIgZGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wiZm9ybWF0RGF0ZVwiXSkodHJ1ZURhdGUsIGZvcm1hdCk7XG5cbiAgICAgIGRhdGUgPSAvV1cvLnRlc3QoZGF0ZSkgPyBkYXRlLnJlcGxhY2UoL1dXLywgd2VlayA8IDEwID8gJzAnICsgd2VlayA6IHdlZWspIDogZGF0ZS5yZXBsYWNlKC9XLywgd2Vlayk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LFxuICAgIHBhcnNlcjogZnVuY3Rpb24gcGFyc2VyKHRleHQsIGZvcm1hdCkge1xuICAgICAgLy8gcGFyc2UgYXMgaWYgYSBub3JtYWwgZGF0ZVxuICAgICAgcmV0dXJuIFRZUEVfVkFMVUVfUkVTT0xWRVJfTUFQLmRhdGUucGFyc2VyKHRleHQsIGZvcm1hdCk7XG4gICAgfVxuICB9LFxuICBkYXRlOiB7XG4gICAgZm9ybWF0dGVyOiBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX0ZPUk1BVFRFUixcbiAgICBwYXJzZXI6IHBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX0RBVEVfUEFSU0VSXG4gIH0sXG4gIGRhdGV0aW1lOiB7XG4gICAgZm9ybWF0dGVyOiBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX0ZPUk1BVFRFUixcbiAgICBwYXJzZXI6IHBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX0RBVEVfUEFSU0VSXG4gIH0sXG4gIGRhdGVyYW5nZToge1xuICAgIGZvcm1hdHRlcjogUkFOR0VfRk9STUFUVEVSLFxuICAgIHBhcnNlcjogUkFOR0VfUEFSU0VSXG4gIH0sXG4gIG1vbnRocmFuZ2U6IHtcbiAgICBmb3JtYXR0ZXI6IFJBTkdFX0ZPUk1BVFRFUixcbiAgICBwYXJzZXI6IFJBTkdFX1BBUlNFUlxuICB9LFxuICBkYXRldGltZXJhbmdlOiB7XG4gICAgZm9ybWF0dGVyOiBSQU5HRV9GT1JNQVRURVIsXG4gICAgcGFyc2VyOiBSQU5HRV9QQVJTRVJcbiAgfSxcbiAgdGltZXJhbmdlOiB7XG4gICAgZm9ybWF0dGVyOiBSQU5HRV9GT1JNQVRURVIsXG4gICAgcGFyc2VyOiBSQU5HRV9QQVJTRVJcbiAgfSxcbiAgdGltZToge1xuICAgIGZvcm1hdHRlcjogcGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfREFURV9GT1JNQVRURVIsXG4gICAgcGFyc2VyOiBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX1BBUlNFUlxuICB9LFxuICBtb250aDoge1xuICAgIGZvcm1hdHRlcjogcGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfREFURV9GT1JNQVRURVIsXG4gICAgcGFyc2VyOiBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX1BBUlNFUlxuICB9LFxuICB5ZWFyOiB7XG4gICAgZm9ybWF0dGVyOiBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX0ZPUk1BVFRFUixcbiAgICBwYXJzZXI6IHBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX0RBVEVfUEFSU0VSXG4gIH0sXG4gIG51bWJlcjoge1xuICAgIGZvcm1hdHRlcjogZnVuY3Rpb24gZm9ybWF0dGVyKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgICB9LFxuICAgIHBhcnNlcjogZnVuY3Rpb24gcGFyc2VyKHRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBOdW1iZXIodGV4dCk7XG5cbiAgICAgIGlmICghaXNOYU4odGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGF0ZXM6IHtcbiAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uIGZvcm1hdHRlcih2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19EQVRFX0ZPUk1BVFRFUihkYXRlLCBmb3JtYXQpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcih2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5zcGxpdCgnLCAnKSA6IHZhbHVlKS5tYXAoZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZSA6IHBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX0RBVEVfUEFSU0VSKGRhdGUsIGZvcm1hdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG52YXIgUExBQ0VNRU5UX01BUCA9IHtcbiAgbGVmdDogJ2JvdHRvbS1zdGFydCcsXG4gIGNlbnRlcjogJ2JvdHRvbScsXG4gIHJpZ2h0OiAnYm90dG9tLWVuZCdcbn07XG5cbnZhciBwYXJzZUFzRm9ybWF0QW5kVHlwZSA9IGZ1bmN0aW9uIHBhcnNlQXNGb3JtYXRBbmRUeXBlKHZhbHVlLCBjdXN0b21Gb3JtYXQsIHR5cGUpIHtcbiAgdmFyIHJhbmdlU2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnLSc7XG5cbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG4gIHZhciBwYXJzZXIgPSAoVFlQRV9WQUxVRV9SRVNPTFZFUl9NQVBbdHlwZV0gfHwgVFlQRV9WQUxVRV9SRVNPTFZFUl9NQVBbJ2RlZmF1bHQnXSkucGFyc2VyO1xuICB2YXIgZm9ybWF0ID0gY3VzdG9tRm9ybWF0IHx8IERFRkFVTFRfRk9STUFUU1t0eXBlXTtcbiAgcmV0dXJuIHBhcnNlcih2YWx1ZSwgZm9ybWF0LCByYW5nZVNlcGFyYXRvcik7XG59O1xuXG52YXIgZm9ybWF0QXNGb3JtYXRBbmRUeXBlID0gZnVuY3Rpb24gZm9ybWF0QXNGb3JtYXRBbmRUeXBlKHZhbHVlLCBjdXN0b21Gb3JtYXQsIHR5cGUpIHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG4gIHZhciBmb3JtYXR0ZXIgPSAoVFlQRV9WQUxVRV9SRVNPTFZFUl9NQVBbdHlwZV0gfHwgVFlQRV9WQUxVRV9SRVNPTFZFUl9NQVBbJ2RlZmF1bHQnXSkuZm9ybWF0dGVyO1xuICB2YXIgZm9ybWF0ID0gY3VzdG9tRm9ybWF0IHx8IERFRkFVTFRfRk9STUFUU1t0eXBlXTtcbiAgcmV0dXJuIGZvcm1hdHRlcih2YWx1ZSwgZm9ybWF0KTtcbn07XG5cbi8qXG4gKiBDb25zaWRlcnM6XG4gKiAgIDEuIERhdGUgb2JqZWN0XG4gKiAgIDIuIGRhdGUgc3RyaW5nXG4gKiAgIDMuIGFycmF5IG9mIDEgb3IgMlxuICovXG52YXIgdmFsdWVFcXVhbHMgPSBmdW5jdGlvbiB2YWx1ZUVxdWFscyhhLCBiKSB7XG4gIC8vIGNvbnNpZGVycyBEYXRlIG9iamVjdCBhbmQgc3RyaW5nXG4gIHZhciBkYXRlRXF1YWxzID0gZnVuY3Rpb24gZGF0ZUVxdWFscyhhLCBiKSB7XG4gICAgdmFyIGFJc0RhdGUgPSBhIGluc3RhbmNlb2YgRGF0ZTtcbiAgICB2YXIgYklzRGF0ZSA9IGIgaW5zdGFuY2VvZiBEYXRlO1xuICAgIGlmIChhSXNEYXRlICYmIGJJc0RhdGUpIHtcbiAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGlmICghYUlzRGF0ZSAmJiAhYklzRGF0ZSkge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgYUlzQXJyYXkgPSBhIGluc3RhbmNlb2YgQXJyYXk7XG4gIHZhciBiSXNBcnJheSA9IGIgaW5zdGFuY2VvZiBBcnJheTtcbiAgaWYgKGFJc0FycmF5ICYmIGJJc0FycmF5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYS5ldmVyeShmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBkYXRlRXF1YWxzKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoIWFJc0FycmF5ICYmICFiSXNBcnJheSkge1xuICAgIHJldHVybiBkYXRlRXF1YWxzKGEsIGIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxudmFyIHZhbGlkYXRvciA9IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgLy8gZWl0aGVyOiBTdHJpbmcsIEFycmF5IG9mIFN0cmluZywgbnVsbCAvIHVuZGVmaW5lZFxuICByZXR1cm4gdmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkIHx8IGlzU3RyaW5nKHZhbCkgfHwgQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDIgJiYgdmFsLmV2ZXJ5KGlzU3RyaW5nKTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG1peGluczogW2VtaXR0ZXJfZGVmYXVsdC5hLCBOZXdQb3BwZXJdLFxuXG4gIGluamVjdDoge1xuICAgIGVsRm9ybToge1xuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIGVsRm9ybUl0ZW06IHtcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfVxuICB9LFxuXG4gIHByb3BzOiB7XG4gICAgc2l6ZTogU3RyaW5nLFxuICAgIGZvcm1hdDogU3RyaW5nLFxuICAgIHZhbHVlRm9ybWF0OiBTdHJpbmcsXG4gICAgcmVhZG9ubHk6IEJvb2xlYW4sXG4gICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICBzdGFydFBsYWNlaG9sZGVyOiBTdHJpbmcsXG4gICAgZW5kUGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICBwcmVmaXhJY29uOiBTdHJpbmcsXG4gICAgY2xlYXJJY29uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZWwtaWNvbi1jaXJjbGUtY2xvc2UnXG4gICAgfSxcbiAgICBuYW1lOiB7XG4gICAgICBkZWZhdWx0OiAnJyxcbiAgICAgIHZhbGlkYXRvcjogdmFsaWRhdG9yXG4gICAgfSxcbiAgICBkaXNhYmxlZDogQm9vbGVhbixcbiAgICBjbGVhcmFibGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgZGVmYXVsdDogJycsXG4gICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvclxuICAgIH0sXG4gICAgcG9wcGVyQ2xhc3M6IFN0cmluZyxcbiAgICBlZGl0YWJsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbGVmdCdcbiAgICB9LFxuICAgIHZhbHVlOiB7fSxcbiAgICBkZWZhdWx0VmFsdWU6IHt9LFxuICAgIGRlZmF1bHRUaW1lOiB7fSxcbiAgICByYW5nZVNlcGFyYXRvcjoge1xuICAgICAgZGVmYXVsdDogJy0nXG4gICAgfSxcbiAgICBwaWNrZXJPcHRpb25zOiB7fSxcbiAgICB1bmxpbmtQYW5lbHM6IEJvb2xlYW4sXG4gICAgdmFsaWRhdGVFdmVudDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50czogeyBFbElucHV0OiBpbnB1dF9kZWZhdWx0LmEgfSxcblxuICBkaXJlY3RpdmVzOiB7IENsaWNrb3V0c2lkZTogY2xpY2tvdXRzaWRlX2RlZmF1bHQuYSB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpY2tlclZpc2libGU6IGZhbHNlLFxuICAgICAgc2hvd0Nsb3NlOiBmYWxzZSxcbiAgICAgIHVzZXJJbnB1dDogbnVsbCxcbiAgICAgIHZhbHVlT25PcGVuOiBudWxsLCAvLyB2YWx1ZSB3aGVuIHBpY2tlciBvcGVucywgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0byBlbWl0IGNoYW5nZVxuICAgICAgdW53YXRjaFBpY2tlck9wdGlvbnM6IG51bGxcbiAgICB9O1xuICB9LFxuXG5cbiAgd2F0Y2g6IHtcbiAgICBwaWNrZXJWaXNpYmxlOiBmdW5jdGlvbiBwaWNrZXJWaXNpYmxlKHZhbCkge1xuICAgICAgaWYgKHRoaXMucmVhZG9ubHkgfHwgdGhpcy5waWNrZXJEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLnNob3dQaWNrZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZU9uT3BlbiA9IEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkgPyBbXS5jb25jYXQodGhpcy52YWx1ZSkgOiB0aGlzLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlUGlja2VyKCk7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy51c2VySW5wdXQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZUV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCgnRWxGb3JtSXRlbScsICdlbC5mb3JtLmJsdXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbWl0KCdibHVyJywgdGhpcyk7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZWRWYWx1ZToge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcih2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyKSB7XG4gICAgICAgICAgdGhpcy5waWNrZXIudmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHZhbCkge1xuICAgICAgLy8gTk9URTogc2hvdWxkIGV2ZW50dWFsbHkgbW92ZSB0byBqc3ggc3R5bGUgcGlja2VyICsgcGFuZWwgP1xuICAgICAgaWYgKHRoaXMucGlja2VyKSB7XG4gICAgICAgIHRoaXMucGlja2VyLmRlZmF1bHRWYWx1ZSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh2YWwsIG9sZFZhbCkge1xuICAgICAgaWYgKCF2YWx1ZUVxdWFscyh2YWwsIG9sZFZhbCkgJiYgIXRoaXMucGlja2VyVmlzaWJsZSAmJiB0aGlzLnZhbGlkYXRlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgnRWxGb3JtSXRlbScsICdlbC5mb3JtLmNoYW5nZScsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgcmFuZ2VkOiBmdW5jdGlvbiByYW5nZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50eXBlLmluZGV4T2YoJ3JhbmdlJykgPiAtMTtcbiAgICB9LFxuICAgIHJlZmVyZW5jZTogZnVuY3Rpb24gcmVmZXJlbmNlKCkge1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMuJHJlZnMucmVmZXJlbmNlO1xuICAgICAgcmV0dXJuIHJlZmVyZW5jZS4kZWwgfHwgcmVmZXJlbmNlO1xuICAgIH0sXG4gICAgcmVmSW5wdXQ6IGZ1bmN0aW9uIHJlZklucHV0KCkge1xuICAgICAgaWYgKHRoaXMucmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHRoaXMucmVmZXJlbmNlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0JykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdmFsdWVJc0VtcHR5OiBmdW5jdGlvbiB2YWx1ZUlzRW1wdHkoKSB7XG4gICAgICB2YXIgdmFsID0gdGhpcy52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh2YWxbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgdHJpZ2dlckNsYXNzOiBmdW5jdGlvbiB0cmlnZ2VyQ2xhc3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVmaXhJY29uIHx8ICh0aGlzLnR5cGUuaW5kZXhPZigndGltZScpICE9PSAtMSA/ICdlbC1pY29uLXRpbWUnIDogJ2VsLWljb24tZGF0ZScpO1xuICAgIH0sXG4gICAgc2VsZWN0aW9uTW9kZTogZnVuY3Rpb24gc2VsZWN0aW9uTW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd3ZWVrJykge1xuICAgICAgICByZXR1cm4gJ3dlZWsnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdtb250aCcpIHtcbiAgICAgICAgcmV0dXJuICdtb250aCc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3llYXInKSB7XG4gICAgICAgIHJldHVybiAneWVhcic7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ2RhdGVzJykge1xuICAgICAgICByZXR1cm4gJ2RhdGVzJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdkYXknO1xuICAgIH0sXG4gICAgaGF2ZVRyaWdnZXI6IGZ1bmN0aW9uIGhhdmVUcmlnZ2VyKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNob3dUcmlnZ2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93VHJpZ2dlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBIQVZFX1RSSUdHRVJfVFlQRVMuaW5kZXhPZih0aGlzLnR5cGUpICE9PSAtMTtcbiAgICB9LFxuICAgIGRpc3BsYXlWYWx1ZTogZnVuY3Rpb24gZGlzcGxheVZhbHVlKCkge1xuICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0QXNGb3JtYXRBbmRUeXBlKHRoaXMucGFyc2VkVmFsdWUsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHRoaXMucmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy51c2VySW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy51c2VySW5wdXRbMF0gfHwgZm9ybWF0dGVkVmFsdWUgJiYgZm9ybWF0dGVkVmFsdWVbMF0gfHwgJycsIHRoaXMudXNlcklucHV0WzFdIHx8IGZvcm1hdHRlZFZhbHVlICYmIGZvcm1hdHRlZFZhbHVlWzFdIHx8ICcnXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51c2VySW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlcklucHV0O1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXR0ZWRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnZGF0ZXMnID8gZm9ybWF0dGVkVmFsdWUuam9pbignLCAnKSA6IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2VkVmFsdWU6IGZ1bmN0aW9uIHBhcnNlZFZhbHVlKCkge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlKSByZXR1cm4gdGhpcy52YWx1ZTsgLy8gY29tcG9uZW50IHZhbHVlIGlzIG5vdCBzZXRcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd0aW1lLXNlbGVjdCcpIHJldHVybiB0aGlzLnZhbHVlOyAvLyB0aW1lLXNlbGVjdCBkb2VzIG5vdCByZXF1aXJlIHBhcnNpbmcsIHRoaXMgbWlnaHQgY2hhbmdlIGluIG5leHQgbWFqb3IgdmVyc2lvblxuXG4gICAgICB2YXIgdmFsdWVJc0RhdGVPYmplY3QgPSBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZU9iamVjdFwiXSkodGhpcy52YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSAmJiB0aGlzLnZhbHVlLmV2ZXJ5KGRhdGVfdXRpbF9bXCJpc0RhdGVPYmplY3RcIl0pO1xuICAgICAgaWYgKHZhbHVlSXNEYXRlT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52YWx1ZUZvcm1hdCkge1xuICAgICAgICByZXR1cm4gcGFyc2VBc0Zvcm1hdEFuZFR5cGUodGhpcy52YWx1ZSwgdGhpcy52YWx1ZUZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLnJhbmdlU2VwYXJhdG9yKSB8fCB0aGlzLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFOiBkZWFsIHdpdGggY29tbW9uIGJ1dCBpbmNvcnJlY3QgdXNhZ2UsIHNob3VsZCByZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICAvLyB1c2VyIG1pZ2h0IHByb3ZpZGUgc3RyaW5nIC8gdGltZXN0YW1wIHdpdGhvdXQgdmFsdWUtZm9ybWF0LCBjb2VyY2UgdGhlbSBpbnRvIGRhdGUgKG9yIGFycmF5IG9mIGRhdGUpXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSA/IHRoaXMudmFsdWUubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbCk7XG4gICAgICB9KSA6IG5ldyBEYXRlKHRoaXMudmFsdWUpO1xuICAgIH0sXG4gICAgX2VsRm9ybUl0ZW1TaXplOiBmdW5jdGlvbiBfZWxGb3JtSXRlbVNpemUoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZWxGb3JtSXRlbSB8fCB7fSkuZWxGb3JtSXRlbVNpemU7XG4gICAgfSxcbiAgICBwaWNrZXJTaXplOiBmdW5jdGlvbiBwaWNrZXJTaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSB8fCB0aGlzLl9lbEZvcm1JdGVtU2l6ZSB8fCAodGhpcy4kRUxFTUVOVCB8fCB7fSkuc2l6ZTtcbiAgICB9LFxuICAgIHBpY2tlckRpc2FibGVkOiBmdW5jdGlvbiBwaWNrZXJEaXNhYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8ICh0aGlzLmVsRm9ybSB8fCB7fSkuZGlzYWJsZWQ7XG4gICAgfSxcbiAgICBmaXJzdElucHV0SWQ6IGZ1bmN0aW9uIGZpcnN0SW5wdXRJZCgpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHZhciBpZCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnJhbmdlZCkge1xuICAgICAgICBpZCA9IHRoaXMuaWQgJiYgdGhpcy5pZFswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gdGhpcy5pZDtcbiAgICAgIH1cbiAgICAgIGlmIChpZCkgb2JqLmlkID0gaWQ7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgc2Vjb25kSW5wdXRJZDogZnVuY3Rpb24gc2Vjb25kSW5wdXRJZCgpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHZhciBpZCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLnJhbmdlZCkge1xuICAgICAgICBpZCA9IHRoaXMuaWQgJiYgdGhpcy5pZFsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChpZCkgb2JqLmlkID0gaWQ7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIC8vIHZ1ZS1wb3BwZXJcbiAgICB0aGlzLnBvcHBlck9wdGlvbnMgPSB7XG4gICAgICBib3VuZGFyaWVzUGFkZGluZzogMCxcbiAgICAgIGdwdUFjY2VsZXJhdGlvbjogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMucGxhY2VtZW50ID0gUExBQ0VNRU5UX01BUFt0aGlzLmFsaWduXSB8fCBQTEFDRU1FTlRfTUFQLmxlZnQ7XG5cbiAgICB0aGlzLiRvbignZmllbGRSZXNldCcsIHRoaXMuaGFuZGxlRmllbGRSZXNldCk7XG4gIH0sXG5cblxuICBtZXRob2RzOiB7XG4gICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgaWYgKCF0aGlzLnJhbmdlZCkge1xuICAgICAgICB0aGlzLiRyZWZzLnJlZmVyZW5jZS5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcbiAgICAgIHRoaXMucmVmSW5wdXQuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmJsdXIoKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIC8vIHtwYXJzZSwgZm9ybWF0VG99IFZhbHVlIGRlYWxzIG1hcHMgY29tcG9uZW50IHZhbHVlIHdpdGggaW50ZXJuYWwgRGF0ZVxuICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBpc1BhcnNlZCA9IE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlT2JqZWN0XCJdKSh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZGF0ZV91dGlsX1tcImlzRGF0ZU9iamVjdFwiXSk7XG4gICAgICBpZiAodGhpcy52YWx1ZUZvcm1hdCAmJiAhaXNQYXJzZWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXNGb3JtYXRBbmRUeXBlKHZhbHVlLCB0aGlzLnZhbHVlRm9ybWF0LCB0aGlzLnR5cGUsIHRoaXMucmFuZ2VTZXBhcmF0b3IpIHx8IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9ybWF0VG9WYWx1ZTogZnVuY3Rpb24gZm9ybWF0VG9WYWx1ZShkYXRlKSB7XG4gICAgICB2YXIgaXNGb3JtYXR0YWJsZSA9IE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlT2JqZWN0XCJdKShkYXRlKSB8fCBBcnJheS5pc0FycmF5KGRhdGUpICYmIGRhdGUuZXZlcnkoZGF0ZV91dGlsX1tcImlzRGF0ZU9iamVjdFwiXSk7XG4gICAgICBpZiAodGhpcy52YWx1ZUZvcm1hdCAmJiBpc0Zvcm1hdHRhYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRBc0Zvcm1hdEFuZFR5cGUoZGF0ZSwgdGhpcy52YWx1ZUZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLnJhbmdlU2VwYXJhdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIHtwYXJzZSwgZm9ybWF0VG99IFN0cmluZyBkZWFscyB3aXRoIHVzZXIgaW5wdXRcbiAgICBwYXJzZVN0cmluZzogZnVuY3Rpb24gcGFyc2VTdHJpbmcodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB0aGlzLnR5cGUgOiB0aGlzLnR5cGUucmVwbGFjZSgncmFuZ2UnLCAnJyk7XG4gICAgICByZXR1cm4gcGFyc2VBc0Zvcm1hdEFuZFR5cGUodmFsdWUsIHRoaXMuZm9ybWF0LCB0eXBlKTtcbiAgICB9LFxuICAgIGZvcm1hdFRvU3RyaW5nOiBmdW5jdGlvbiBmb3JtYXRUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHRoaXMudHlwZSA6IHRoaXMudHlwZS5yZXBsYWNlKCdyYW5nZScsICcnKTtcbiAgICAgIHJldHVybiBmb3JtYXRBc0Zvcm1hdEFuZFR5cGUodmFsdWUsIHRoaXMuZm9ybWF0LCB0eXBlKTtcbiAgICB9LFxuICAgIGhhbmRsZU1vdXNlRW50ZXI6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoKSB7XG4gICAgICBpZiAodGhpcy5yZWFkb25seSB8fCB0aGlzLnBpY2tlckRpc2FibGVkKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMudmFsdWVJc0VtcHR5ICYmIHRoaXMuY2xlYXJhYmxlKSB7XG4gICAgICAgIHRoaXMuc2hvd0Nsb3NlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgaWYgKHRoaXMudXNlcklucHV0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VTdHJpbmcodGhpcy5kaXNwbGF5VmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnBpY2tlci52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdElucHV0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudXNlcklucHV0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVzZXJJbnB1dCA9PT0gJycpIHtcbiAgICAgICAgdGhpcy5lbWl0SW5wdXQobnVsbCk7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZShudWxsKTtcbiAgICAgICAgdGhpcy51c2VySW5wdXQgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlU3RhcnRJbnB1dDogZnVuY3Rpb24gaGFuZGxlU3RhcnRJbnB1dChldmVudCkge1xuICAgICAgaWYgKHRoaXMudXNlcklucHV0KSB7XG4gICAgICAgIHRoaXMudXNlcklucHV0ID0gW2V2ZW50LnRhcmdldC52YWx1ZSwgdGhpcy51c2VySW5wdXRbMV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51c2VySW5wdXQgPSBbZXZlbnQudGFyZ2V0LnZhbHVlLCBudWxsXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUVuZElucHV0OiBmdW5jdGlvbiBoYW5kbGVFbmRJbnB1dChldmVudCkge1xuICAgICAgaWYgKHRoaXMudXNlcklucHV0KSB7XG4gICAgICAgIHRoaXMudXNlcklucHV0ID0gW3RoaXMudXNlcklucHV0WzBdLCBldmVudC50YXJnZXQudmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51c2VySW5wdXQgPSBbbnVsbCwgZXZlbnQudGFyZ2V0LnZhbHVlXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVN0YXJ0Q2hhbmdlOiBmdW5jdGlvbiBoYW5kbGVTdGFydENoYW5nZShldmVudCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZVN0cmluZyh0aGlzLnVzZXJJbnB1dCAmJiB0aGlzLnVzZXJJbnB1dFswXSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy51c2VySW5wdXQgPSBbdGhpcy5mb3JtYXRUb1N0cmluZyh2YWx1ZSksIHRoaXMuZGlzcGxheVZhbHVlWzFdXTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gW3ZhbHVlLCB0aGlzLnBpY2tlci52YWx1ZSAmJiB0aGlzLnBpY2tlci52YWx1ZVsxXV07XG4gICAgICAgIHRoaXMucGlja2VyLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRWYWx1ZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXRJbnB1dChuZXdWYWx1ZSk7XG4gICAgICAgICAgdGhpcy51c2VySW5wdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVFbmRDaGFuZ2U6IGZ1bmN0aW9uIGhhbmRsZUVuZENoYW5nZShldmVudCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZVN0cmluZyh0aGlzLnVzZXJJbnB1dCAmJiB0aGlzLnVzZXJJbnB1dFsxXSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy51c2VySW5wdXQgPSBbdGhpcy5kaXNwbGF5VmFsdWVbMF0sIHRoaXMuZm9ybWF0VG9TdHJpbmcodmFsdWUpXTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gW3RoaXMucGlja2VyLnZhbHVlICYmIHRoaXMucGlja2VyLnZhbHVlWzBdLCB2YWx1ZV07XG4gICAgICAgIHRoaXMucGlja2VyLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRWYWx1ZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICB0aGlzLmVtaXRJbnB1dChuZXdWYWx1ZSk7XG4gICAgICAgICAgdGhpcy51c2VySW5wdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVDbGlja0ljb246IGZ1bmN0aW9uIGhhbmRsZUNsaWNrSWNvbihldmVudCkge1xuICAgICAgaWYgKHRoaXMucmVhZG9ubHkgfHwgdGhpcy5waWNrZXJEaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuc2hvd0Nsb3NlKSB7XG4gICAgICAgIHRoaXMudmFsdWVPbk9wZW4gPSB0aGlzLnZhbHVlO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5lbWl0SW5wdXQobnVsbCk7XG4gICAgICAgIHRoaXMuZW1pdENoYW5nZShudWxsKTtcbiAgICAgICAgdGhpcy5zaG93Q2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucGlja2VyICYmIHR5cGVvZiB0aGlzLnBpY2tlci5oYW5kbGVDbGVhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMucGlja2VyLmhhbmRsZUNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGlja2VyVmlzaWJsZSA9ICF0aGlzLnBpY2tlclZpc2libGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVDbG9zZTogZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgICBpZiAoIXRoaXMucGlja2VyVmlzaWJsZSkgcmV0dXJuO1xuICAgICAgdGhpcy5waWNrZXJWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdkYXRlcycpIHtcbiAgICAgICAgLy8gcmVzdG9yZSB0byBmb3JtZXIgdmFsdWVcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gcGFyc2VBc0Zvcm1hdEFuZFR5cGUodGhpcy52YWx1ZU9uT3BlbiwgdGhpcy52YWx1ZUZvcm1hdCwgdGhpcy50eXBlLCB0aGlzLnJhbmdlU2VwYXJhdG9yKSB8fCB0aGlzLnZhbHVlT25PcGVuO1xuICAgICAgICB0aGlzLmVtaXRJbnB1dChvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVGaWVsZFJlc2V0OiBmdW5jdGlvbiBoYW5kbGVGaWVsZFJlc2V0KGluaXRpYWxWYWx1ZSkge1xuICAgICAgdGhpcy51c2VySW5wdXQgPSBpbml0aWFsVmFsdWUgPT09ICcnID8gbnVsbCA6IGluaXRpYWxWYWx1ZTtcbiAgICB9LFxuICAgIGhhbmRsZUZvY3VzOiBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICBpZiAoSEFWRV9UUklHR0VSX1RZUEVTLmluZGV4T2YodHlwZSkgIT09IC0xICYmICF0aGlzLnBpY2tlclZpc2libGUpIHtcbiAgICAgICAgdGhpcy5waWNrZXJWaXNpYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJywgdGhpcyk7XG4gICAgfSxcbiAgICBoYW5kbGVLZXlkb3duOiBmdW5jdGlvbiBoYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG5cbiAgICAgIC8vIEVTQ1xuICAgICAgaWYgKGtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIHRoaXMucGlja2VyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUYWJcbiAgICAgIGlmIChrZXlDb2RlID09PSA5KSB7XG4gICAgICAgIGlmICghdGhpcy5yYW5nZWQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICAgIHRoaXMucGlja2VyVmlzaWJsZSA9IHRoaXMucGlja2VyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2VyIG1heSBjaGFuZ2UgZm9jdXMgYmV0d2VlbiB0d28gaW5wdXRcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZWZJbnB1dC5pbmRleE9mKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09PSAtMSkge1xuICAgICAgICAgICAgICBfdGhpcy5waWNrZXJWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIF90aGlzLmJsdXIoKTtcbiAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBFbnRlclxuICAgICAgaWYgKGtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXJJbnB1dCA9PT0gJycgfHwgdGhpcy5pc1ZhbGlkVmFsdWUodGhpcy5wYXJzZVN0cmluZyh0aGlzLmRpc3BsYXlWYWx1ZSkpKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoKTtcbiAgICAgICAgICB0aGlzLnBpY2tlclZpc2libGUgPSB0aGlzLnBpY2tlci52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdXNlciBpcyB0eXBpbmcsIGRvIG5vdCBsZXQgcGlja2VyIGhhbmRsZSBrZXkgaW5wdXRcbiAgICAgIGlmICh0aGlzLnVzZXJJbnB1dCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWxlZ2F0ZSBvdGhlciBrZXlzIHRvIHBhbmVsXG4gICAgICBpZiAodGhpcy5waWNrZXIgJiYgdGhpcy5waWNrZXIuaGFuZGxlS2V5ZG93bikge1xuICAgICAgICB0aGlzLnBpY2tlci5oYW5kbGVLZXlkb3duKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVJhbmdlQ2xpY2s6IGZ1bmN0aW9uIGhhbmRsZVJhbmdlQ2xpY2soKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgICAgaWYgKEhBVkVfVFJJR0dFUl9UWVBFUy5pbmRleE9mKHR5cGUpICE9PSAtMSAmJiAhdGhpcy5waWNrZXJWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMucGlja2VyVmlzaWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLiRlbWl0KCdmb2N1cycsIHRoaXMpO1xuICAgIH0sXG4gICAgaGlkZVBpY2tlcjogZnVuY3Rpb24gaGlkZVBpY2tlcigpIHtcbiAgICAgIGlmICh0aGlzLnBpY2tlcikge1xuICAgICAgICB0aGlzLnBpY2tlci5yZXNldFZpZXcgJiYgdGhpcy5waWNrZXIucmVzZXRWaWV3KCk7XG4gICAgICAgIHRoaXMucGlja2VyVmlzaWJsZSA9IHRoaXMucGlja2VyLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95UG9wcGVyKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93UGlja2VyOiBmdW5jdGlvbiBzaG93UGlja2VyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRpc1NlcnZlcikgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnBpY2tlcikge1xuICAgICAgICB0aGlzLm1vdW50UGlja2VyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBpY2tlclZpc2libGUgPSB0aGlzLnBpY2tlci52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgdGhpcy51cGRhdGVQb3BwZXIoKTtcblxuICAgICAgdGhpcy5waWNrZXIudmFsdWUgPSB0aGlzLnBhcnNlZFZhbHVlO1xuICAgICAgdGhpcy5waWNrZXIucmVzZXRWaWV3ICYmIHRoaXMucGlja2VyLnJlc2V0VmlldygpO1xuXG4gICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5waWNrZXIuYWRqdXN0U3Bpbm5lcnMgJiYgX3RoaXMyLnBpY2tlci5hZGp1c3RTcGlubmVycygpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBtb3VudFBpY2tlcjogZnVuY3Rpb24gbW91bnRQaWNrZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5waWNrZXIgPSBuZXcgZXh0ZXJuYWxfdnVlX2RlZmF1bHQuYSh0aGlzLnBhbmVsKS4kbW91bnQoKTtcbiAgICAgIHRoaXMucGlja2VyLmRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICAgICAgdGhpcy5waWNrZXIuZGVmYXVsdFRpbWUgPSB0aGlzLmRlZmF1bHRUaW1lO1xuICAgICAgdGhpcy5waWNrZXIucG9wcGVyQ2xhc3MgPSB0aGlzLnBvcHBlckNsYXNzO1xuICAgICAgdGhpcy5wb3BwZXJFbG0gPSB0aGlzLnBpY2tlci4kZWw7XG4gICAgICB0aGlzLnBpY2tlci53aWR0aCA9IHRoaXMucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgdGhpcy5waWNrZXIuc2hvd1RpbWUgPSB0aGlzLnR5cGUgPT09ICdkYXRldGltZScgfHwgdGhpcy50eXBlID09PSAnZGF0ZXRpbWVyYW5nZSc7XG4gICAgICB0aGlzLnBpY2tlci5zZWxlY3Rpb25Nb2RlID0gdGhpcy5zZWxlY3Rpb25Nb2RlO1xuICAgICAgdGhpcy5waWNrZXIudW5saW5rUGFuZWxzID0gdGhpcy51bmxpbmtQYW5lbHM7XG4gICAgICB0aGlzLnBpY2tlci5hcnJvd0NvbnRyb2wgPSB0aGlzLmFycm93Q29udHJvbCB8fCB0aGlzLnRpbWVBcnJvd0NvbnRyb2wgfHwgZmFsc2U7XG4gICAgICB0aGlzLiR3YXRjaCgnZm9ybWF0JywgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBfdGhpczMucGlja2VyLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMzLnBpY2tlck9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZWxlY3RhYmxlUmFuZ2UpIHtcbiAgICAgICAgICB2YXIgcmFuZ2VzID0gb3B0aW9ucy5zZWxlY3RhYmxlUmFuZ2U7XG4gICAgICAgICAgdmFyIHBhcnNlciA9IFRZUEVfVkFMVUVfUkVTT0xWRVJfTUFQLmRhdGV0aW1lcmFuZ2UucGFyc2VyO1xuICAgICAgICAgIHZhciBmb3JtYXQgPSBERUZBVUxUX0ZPUk1BVFMudGltZXJhbmdlO1xuXG4gICAgICAgICAgcmFuZ2VzID0gQXJyYXkuaXNBcnJheShyYW5nZXMpID8gcmFuZ2VzIDogW3Jhbmdlc107XG4gICAgICAgICAgX3RoaXMzLnBpY2tlci5zZWxlY3RhYmxlUmFuZ2UgPSByYW5nZXMubWFwKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlcihyYW5nZSwgZm9ybWF0LCBfdGhpczMucmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmXG4gICAgICAgICAgLy8g5b+955WlIHRpbWUtcGlja2VyIOeahOivpemFjee9rumhuVxuICAgICAgICAgIG9wdGlvbiAhPT0gJ3NlbGVjdGFibGVSYW5nZScpIHtcbiAgICAgICAgICAgIF90aGlzMy5waWNrZXJbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWluIGZvcm1hdCBtdXN0IHByZXZhaWwgb3ZlciB1bmRvY3VtZW50ZWQgcGlja2VyT3B0aW9ucy5mb3JtYXRcbiAgICAgICAgaWYgKF90aGlzMy5mb3JtYXQpIHtcbiAgICAgICAgICBfdGhpczMucGlja2VyLmZvcm1hdCA9IF90aGlzMy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVPcHRpb25zKCk7XG4gICAgICB0aGlzLnVud2F0Y2hQaWNrZXJPcHRpb25zID0gdGhpcy4kd2F0Y2goJ3BpY2tlck9wdGlvbnMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPcHRpb25zKCk7XG4gICAgICB9LCB7IGRlZXA6IHRydWUgfSk7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZCh0aGlzLnBpY2tlci4kZWwpO1xuICAgICAgdGhpcy5waWNrZXIucmVzZXRWaWV3ICYmIHRoaXMucGlja2VyLnJlc2V0VmlldygpO1xuXG4gICAgICB0aGlzLnBpY2tlci4kb24oJ2RvZGVzdHJveScsIHRoaXMuZG9EZXN0cm95KTtcbiAgICAgIHRoaXMucGlja2VyLiRvbigncGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuICAgICAgICB2YXIgdmlzaWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgX3RoaXMzLnVzZXJJbnB1dCA9IG51bGw7XG4gICAgICAgIF90aGlzMy5waWNrZXJWaXNpYmxlID0gX3RoaXMzLnBpY2tlci52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgX3RoaXMzLmVtaXRJbnB1dChkYXRlKTtcbiAgICAgICAgX3RoaXMzLnBpY2tlci5yZXNldFZpZXcgJiYgX3RoaXMzLnBpY2tlci5yZXNldFZpZXcoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnBpY2tlci4kb24oJ3NlbGVjdC1yYW5nZScsIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwb3MpIHtcbiAgICAgICAgaWYgKF90aGlzMy5yZWZJbnB1dC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgaWYgKCFwb3MgfHwgcG9zID09PSAnbWluJykge1xuICAgICAgICAgIF90aGlzMy5yZWZJbnB1dFswXS5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTtcbiAgICAgICAgICBfdGhpczMucmVmSW5wdXRbMF0uZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3MgPT09ICdtYXgnKSB7XG4gICAgICAgICAgX3RoaXMzLnJlZklucHV0WzFdLnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIF90aGlzMy5yZWZJbnB1dFsxXS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVubW91bnRQaWNrZXI6IGZ1bmN0aW9uIHVubW91bnRQaWNrZXIoKSB7XG4gICAgICBpZiAodGhpcy5waWNrZXIpIHtcbiAgICAgICAgdGhpcy5waWNrZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5waWNrZXIuJG9mZigpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudW53YXRjaFBpY2tlck9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLnVud2F0Y2hQaWNrZXJPcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5waWNrZXIuJGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5waWNrZXIuJGVsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXRDaGFuZ2U6IGZ1bmN0aW9uIGVtaXRDaGFuZ2UodmFsKSB7XG4gICAgICAvLyBkZXRlcm1pbmUgdXNlciByZWFsIGNoYW5nZSBvbmx5XG4gICAgICBpZiAoIXZhbHVlRXF1YWxzKHZhbCwgdGhpcy52YWx1ZU9uT3BlbikpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdmFsKTtcbiAgICAgICAgdGhpcy52YWx1ZU9uT3BlbiA9IHZhbDtcbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdGVFdmVudCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ0VsRm9ybUl0ZW0nLCAnZWwuZm9ybS5jaGFuZ2UnLCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0SW5wdXQ6IGZ1bmN0aW9uIGVtaXRJbnB1dCh2YWwpIHtcbiAgICAgIHZhciBmb3JtYXR0ZWQgPSB0aGlzLmZvcm1hdFRvVmFsdWUodmFsKTtcbiAgICAgIGlmICghdmFsdWVFcXVhbHModGhpcy52YWx1ZSwgZm9ybWF0dGVkKSkge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGZvcm1hdHRlZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1ZhbGlkVmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLnBpY2tlcikge1xuICAgICAgICB0aGlzLm1vdW50UGlja2VyKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5waWNrZXIuaXNWYWxpZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB0aGlzLnBpY2tlci5pc1ZhbGlkVmFsdWUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BpY2tlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3JjX3BpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChwaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG52YXIgY29tcG9uZW50Tm9ybWFsaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BpY2tlci52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBjb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIHNyY19waWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BpY2tlci52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGlja2VyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuXG4vKioqLyB9KSxcbi8qIDMzICovLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL2Jhc2ljL3RpbWUtc3Bpbm5lci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWZhY2FkZWImXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyXCIsXG4gICAgICBjbGFzczogeyBcImhhcy1zZWNvbmRzXCI6IF92bS5zaG93U2Vjb25kcyB9XG4gICAgfSxcbiAgICBbXG4gICAgICAhX3ZtLmFycm93Q29udHJvbFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImVsLXNjcm9sbGJhclwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVmOiBcImhvdXJzXCIsXG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX193cmFwcGVyXCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIFwid3JhcC1zdHlsZVwiOiBcIm1heC1oZWlnaHQ6IGluaGVyaXQ7XCIsXG4gICAgICAgICAgICAgICAgICBcInZpZXctY2xhc3NcIjogXCJlbC10aW1lLXNwaW5uZXJfX2xpc3RcIixcbiAgICAgICAgICAgICAgICAgIG5vcmVzaXplOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgdGFnOiBcInVsXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5hdGl2ZU9uOiB7XG4gICAgICAgICAgICAgICAgICBtb3VzZWVudGVyOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLmVtaXRTZWxlY3RSYW5nZShcImhvdXJzXCIpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLmFkanVzdEN1cnJlbnRTcGlubmVyKFwiaG91cnNcIilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF92bS5fbChfdm0uaG91cnNMaXN0LCBmdW5jdGlvbihkaXNhYmxlZCwgaG91cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgIFwibGlcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBob3VyLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX2l0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgYWN0aXZlOiBob3VyID09PSBfdm0uaG91cnMsIGRpc2FibGVkOiBkaXNhYmxlZCB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5oYW5kbGVDbGljayhcImhvdXJzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhvdXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIwXCIgKyAoX3ZtLmFtUG1Nb2RlID8gaG91ciAlIDEyIHx8IDEyIDogaG91cikpLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAtMlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICkgKyBfdm0uX3MoX3ZtLmFtUG0oaG91cikpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZWwtc2Nyb2xsYmFyXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWY6IFwibWludXRlc1wiLFxuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXRpbWUtc3Bpbm5lcl9fd3JhcHBlclwiLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICBcIndyYXAtc3R5bGVcIjogXCJtYXgtaGVpZ2h0OiBpbmhlcml0O1wiLFxuICAgICAgICAgICAgICAgICAgXCJ2aWV3LWNsYXNzXCI6IFwiZWwtdGltZS1zcGlubmVyX19saXN0XCIsXG4gICAgICAgICAgICAgICAgICBub3Jlc2l6ZTogXCJcIixcbiAgICAgICAgICAgICAgICAgIHRhZzogXCJ1bFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuYXRpdmVPbjoge1xuICAgICAgICAgICAgICAgICAgbW91c2VlbnRlcjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS5lbWl0U2VsZWN0UmFuZ2UoXCJtaW51dGVzXCIpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbW91c2Vtb3ZlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLmFkanVzdEN1cnJlbnRTcGlubmVyKFwibWludXRlc1wiKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgX3ZtLl9sKF92bS5taW51dGVzTGlzdCwgZnVuY3Rpb24oZW5hYmxlZCwga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgICAgICAgICAgXCJsaVwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX19pdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiB7IGFjdGl2ZToga2V5ID09PSBfdm0ubWludXRlcywgZGlzYWJsZWQ6ICFlbmFibGVkIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmhhbmRsZUNsaWNrKFwibWludXRlc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcygoXCIwXCIgKyBrZXkpLnNsaWNlKC0yKSkpXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJlbC1zY3JvbGxiYXJcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uc2hvd1NlY29uZHMsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwic2hvd1NlY29uZHNcIlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcmVmOiBcInNlY29uZHNcIixcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX3dyYXBwZXJcIixcbiAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgXCJ3cmFwLXN0eWxlXCI6IFwibWF4LWhlaWdodDogaW5oZXJpdDtcIixcbiAgICAgICAgICAgICAgICAgIFwidmlldy1jbGFzc1wiOiBcImVsLXRpbWUtc3Bpbm5lcl9fbGlzdFwiLFxuICAgICAgICAgICAgICAgICAgbm9yZXNpemU6IFwiXCIsXG4gICAgICAgICAgICAgICAgICB0YWc6IFwidWxcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmF0aXZlT246IHtcbiAgICAgICAgICAgICAgICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdm0uZW1pdFNlbGVjdFJhbmdlKFwic2Vjb25kc1wiKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS5hZGp1c3RDdXJyZW50U3Bpbm5lcihcInNlY29uZHNcIilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF92bS5fbCg2MCwgZnVuY3Rpb24oc2Vjb25kLCBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICBcImxpXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX2l0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgYWN0aXZlOiBrZXkgPT09IF92bS5zZWNvbmRzIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmhhbmRsZUNsaWNrKFwic2Vjb25kc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcygoXCIwXCIgKyBrZXkpLnNsaWNlKC0yKSkpXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgICBfdm0uYXJyb3dDb250cm9sXG4gICAgICAgID8gW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX3dyYXBwZXIgaXMtYXJyb3dcIixcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgbW91c2VlbnRlcjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS5lbWl0U2VsZWN0UmFuZ2UoXCJob3Vyc1wiKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF9jKFwiaVwiLCB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInJlcGVhdC1jbGlja1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1yZXBlYXQtY2xpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmRlY3JlYXNlLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiZGVjcmVhc2VcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX19hcnJvdyBlbC1pY29uLWFycm93LXVwXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfYyhcImlcIiwge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJyZXBlYXQtY2xpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtcmVwZWF0LWNsaWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5pbmNyZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImluY3JlYXNlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXRpbWUtc3Bpbm5lcl9fYXJyb3cgZWwtaWNvbi1hcnJvdy1kb3duXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwidWxcIixcbiAgICAgICAgICAgICAgICAgIHsgcmVmOiBcImhvdXJzXCIsIHN0YXRpY0NsYXNzOiBcImVsLXRpbWUtc3Bpbm5lcl9fbGlzdFwiIH0sXG4gICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLmFycm93SG91ckxpc3QsIGZ1bmN0aW9uKGhvdXIsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX19pdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGhvdXIgPT09IF92bS5ob3VycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IF92bS5ob3Vyc0xpc3RbaG91cl1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjBcIiArIChfdm0uYW1QbU1vZGUgPyBob3VyICUgMTIgfHwgMTIgOiBob3VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnNsaWNlKC0yKSArIF92bS5hbVBtKGhvdXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX193cmFwcGVyIGlzLWFycm93XCIsXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdm0uZW1pdFNlbGVjdFJhbmdlKFwibWludXRlc1wiKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF9jKFwiaVwiLCB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInJlcGVhdC1jbGlja1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1yZXBlYXQtY2xpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmRlY3JlYXNlLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiZGVjcmVhc2VcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX19hcnJvdyBlbC1pY29uLWFycm93LXVwXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfYyhcImlcIiwge1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJyZXBlYXQtY2xpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtcmVwZWF0LWNsaWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5pbmNyZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImluY3JlYXNlXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXRpbWUtc3Bpbm5lcl9fYXJyb3cgZWwtaWNvbi1hcnJvdy1kb3duXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwidWxcIixcbiAgICAgICAgICAgICAgICAgIHsgcmVmOiBcIm1pbnV0ZXNcIiwgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX19saXN0XCIgfSxcbiAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0uYXJyb3dNaW51dGVMaXN0LCBmdW5jdGlvbihtaW51dGUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgXCJsaVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX19pdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBhY3RpdmU6IG1pbnV0ZSA9PT0gX3ZtLm1pbnV0ZXMgfVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKFwiMFwiICsgbWludXRlKS5zbGljZSgtMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF92bS5zaG93U2Vjb25kc1xuICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtdGltZS1zcGlubmVyX193cmFwcGVyIGlzLWFycm93XCIsXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgbW91c2VlbnRlcjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uZW1pdFNlbGVjdFJhbmdlKFwic2Vjb25kc1wiKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicmVwZWF0LWNsaWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1yZXBlYXQtY2xpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5kZWNyZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJkZWNyZWFzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX2Fycm93IGVsLWljb24tYXJyb3ctdXBcIlxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicmVwZWF0LWNsaWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1yZXBlYXQtY2xpY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5pbmNyZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJpbmNyZWFzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX2Fycm93IGVsLWljb24tYXJyb3ctZG93blwiXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcInVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgeyByZWY6IFwic2Vjb25kc1wiLCBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX2xpc3RcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0uYXJyb3dTZWNvbmRMaXN0LCBmdW5jdGlvbihzZWNvbmQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC10aW1lLXNwaW5uZXJfX2l0ZW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBhY3RpdmU6IHNlY29uZCA9PT0gX3ZtLnNlY29uZHMgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoXCIwXCIgKyBzZWNvbmQpLnNsaWNlKC0yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgXVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMvdGltZS1zcGlubmVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xZmFjYWRlYiZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL3V0aWxzL2RhdGUtdXRpbFwiXG52YXIgZGF0ZV91dGlsXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi9zY3JvbGxiYXJcIlxudmFyIHNjcm9sbGJhcl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBzY3JvbGxiYXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oc2Nyb2xsYmFyXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvZGlyZWN0aXZlcy9yZXBlYXQtY2xpY2suanNcbnZhciByZXBlYXRfY2xpY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL2Jhc2ljL3RpbWUtc3Bpbm5lci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZV9zcGlubmVydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgY29tcG9uZW50czogeyBFbFNjcm9sbGJhcjogc2Nyb2xsYmFyX2RlZmF1bHQuYSB9LFxuXG4gIGRpcmVjdGl2ZXM6IHtcbiAgICByZXBlYXRDbGljazogcmVwZWF0X2NsaWNrW1wiYVwiIC8qIGRlZmF1bHQgKi9dXG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICBkYXRlOiB7fSxcbiAgICBkZWZhdWx0VmFsdWU6IHt9LCAvLyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZVxuICAgIHNob3dTZWNvbmRzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgYXJyb3dDb250cm9sOiBCb29sZWFuLFxuICAgIGFtUG1Nb2RlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJyAvLyAnYSc6IGFtL3BtOyAnQSc6IEFNL1BNXG4gICAgfVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgaG91cnM6IGZ1bmN0aW9uIGhvdXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRIb3VycygpO1xuICAgIH0sXG4gICAgbWludXRlczogZnVuY3Rpb24gbWludXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0TWludXRlcygpO1xuICAgIH0sXG4gICAgc2Vjb25kczogZnVuY3Rpb24gc2Vjb25kcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0U2Vjb25kcygpO1xuICAgIH0sXG4gICAgaG91cnNMaXN0OiBmdW5jdGlvbiBob3Vyc0xpc3QoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJnZXRSYW5nZUhvdXJzXCJdKSh0aGlzLnNlbGVjdGFibGVSYW5nZSk7XG4gICAgfSxcbiAgICBtaW51dGVzTGlzdDogZnVuY3Rpb24gbWludXRlc0xpc3QoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJnZXRSYW5nZU1pbnV0ZXNcIl0pKHRoaXMuc2VsZWN0YWJsZVJhbmdlLCB0aGlzLmhvdXJzKTtcbiAgICB9LFxuICAgIGFycm93SG91ckxpc3Q6IGZ1bmN0aW9uIGFycm93SG91ckxpc3QoKSB7XG4gICAgICB2YXIgaG91cnMgPSB0aGlzLmhvdXJzO1xuICAgICAgcmV0dXJuIFtob3VycyA+IDAgPyBob3VycyAtIDEgOiB1bmRlZmluZWQsIGhvdXJzLCBob3VycyA8IDIzID8gaG91cnMgKyAxIDogdW5kZWZpbmVkXTtcbiAgICB9LFxuICAgIGFycm93TWludXRlTGlzdDogZnVuY3Rpb24gYXJyb3dNaW51dGVMaXN0KCkge1xuICAgICAgdmFyIG1pbnV0ZXMgPSB0aGlzLm1pbnV0ZXM7XG4gICAgICByZXR1cm4gW21pbnV0ZXMgPiAwID8gbWludXRlcyAtIDEgOiB1bmRlZmluZWQsIG1pbnV0ZXMsIG1pbnV0ZXMgPCA1OSA/IG1pbnV0ZXMgKyAxIDogdW5kZWZpbmVkXTtcbiAgICB9LFxuICAgIGFycm93U2Vjb25kTGlzdDogZnVuY3Rpb24gYXJyb3dTZWNvbmRMaXN0KCkge1xuICAgICAgdmFyIHNlY29uZHMgPSB0aGlzLnNlY29uZHM7XG4gICAgICByZXR1cm4gW3NlY29uZHMgPiAwID8gc2Vjb25kcyAtIDEgOiB1bmRlZmluZWQsIHNlY29uZHMsIHNlY29uZHMgPCA1OSA/IHNlY29uZHMgKyAxIDogdW5kZWZpbmVkXTtcbiAgICB9XG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0YWJsZVJhbmdlOiBbXSxcbiAgICAgIGN1cnJlbnRTY3JvbGxiYXI6IG51bGxcbiAgICB9O1xuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAhX3RoaXMuYXJyb3dDb250cm9sICYmIF90aGlzLmJpbmRTY3JvbGxFdmVudCgpO1xuICAgIH0pO1xuICB9LFxuXG5cbiAgbWV0aG9kczoge1xuICAgIGluY3JlYXNlOiBmdW5jdGlvbiBpbmNyZWFzZSgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsRG93bigxKTtcbiAgICB9LFxuICAgIGRlY3JlYXNlOiBmdW5jdGlvbiBkZWNyZWFzZSgpIHtcbiAgICAgIHRoaXMuc2Nyb2xsRG93bigtMSk7XG4gICAgfSxcbiAgICBtb2RpZnlEYXRlRmllbGQ6IGZ1bmN0aW9uIG1vZGlmeURhdGVGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeVRpbWVcIl0pKHRoaXMuZGF0ZSwgdmFsdWUsIHRoaXMubWludXRlcywgdGhpcy5zZWNvbmRzKSk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5VGltZVwiXSkodGhpcy5kYXRlLCB0aGlzLmhvdXJzLCB2YWx1ZSwgdGhpcy5zZWNvbmRzKSk7YnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5VGltZVwiXSkodGhpcy5kYXRlLCB0aGlzLmhvdXJzLCB0aGlzLm1pbnV0ZXMsIHZhbHVlKSk7YnJlYWs7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2sodHlwZSwgX3JlZikge1xuICAgICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICAgICAgICBkaXNhYmxlZCA9IF9yZWYuZGlzYWJsZWQ7XG5cbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5tb2RpZnlEYXRlRmllbGQodHlwZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmVtaXRTZWxlY3RSYW5nZSh0eXBlKTtcbiAgICAgICAgdGhpcy5hZGp1c3RTcGlubmVyKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXRTZWxlY3RSYW5nZTogZnVuY3Rpb24gZW1pdFNlbGVjdFJhbmdlKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSAnaG91cnMnKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3NlbGVjdC1yYW5nZScsIDAsIDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbWludXRlcycpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnc2VsZWN0LXJhbmdlJywgMywgNSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzZWNvbmRzJykge1xuICAgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QtcmFuZ2UnLCA2LCA4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudFNjcm9sbGJhciA9IHR5cGU7XG4gICAgfSxcbiAgICBiaW5kU2Nyb2xsRXZlbnQ6IGZ1bmN0aW9uIGJpbmRTY3JvbGxFdmVudCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgYmluZEZ1bnRpb24gPSBmdW5jdGlvbiBiaW5kRnVudGlvbih0eXBlKSB7XG4gICAgICAgIF90aGlzMi4kcmVmc1t0eXBlXS53cmFwLm9uc2Nyb2xsID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBUT0RPOiBzY3JvbGwgaXMgZW1pdHRlZCB3aGVuIHNldCBzY3JvbGxUb3AgcHJvZ3JhbWF0aWNhbGx5XG4gICAgICAgICAgLy8gc2hvdWxkIGZpbmQgYmV0dGVyIHNvbHV0aW9ucyBpbiB0aGUgZnV0dXJlIVxuICAgICAgICAgIF90aGlzMi5oYW5kbGVTY3JvbGwodHlwZSwgZSk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgYmluZEZ1bnRpb24oJ2hvdXJzJyk7XG4gICAgICBiaW5kRnVudGlvbignbWludXRlcycpO1xuICAgICAgYmluZEZ1bnRpb24oJ3NlY29uZHMnKTtcbiAgICB9LFxuICAgIGhhbmRsZVNjcm9sbDogZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKHR5cGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWluKE1hdGgucm91bmQoKHRoaXMuJHJlZnNbdHlwZV0ud3JhcC5zY3JvbGxUb3AgLSAodGhpcy5zY3JvbGxCYXJIZWlnaHQodHlwZSkgKiAwLjUgLSAxMCkgLyB0aGlzLnR5cGVJdGVtSGVpZ2h0KHR5cGUpICsgMykgLyB0aGlzLnR5cGVJdGVtSGVpZ2h0KHR5cGUpKSwgdHlwZSA9PT0gJ2hvdXJzJyA/IDIzIDogNTkpO1xuICAgICAgdGhpcy5tb2RpZnlEYXRlRmllbGQodHlwZSwgdmFsdWUpO1xuICAgIH0sXG5cblxuICAgIC8vIE5PVEU6IHVzZWQgYnkgZGF0ZXRpbWUgLyBkYXRlLXJhbmdlIHBhbmVsXG4gICAgLy8gICAgICAgcmVuYW1lZCBmcm9tIGFkanVzdFNjcm9sbFRvcFxuICAgIC8vICAgICAgIHNob3VsZCB0cnkgdG8gcmVmYWN0b3J5IGl0XG4gICAgYWRqdXN0U3Bpbm5lcnM6IGZ1bmN0aW9uIGFkanVzdFNwaW5uZXJzKCkge1xuICAgICAgdGhpcy5hZGp1c3RTcGlubmVyKCdob3VycycsIHRoaXMuaG91cnMpO1xuICAgICAgdGhpcy5hZGp1c3RTcGlubmVyKCdtaW51dGVzJywgdGhpcy5taW51dGVzKTtcbiAgICAgIHRoaXMuYWRqdXN0U3Bpbm5lcignc2Vjb25kcycsIHRoaXMuc2Vjb25kcyk7XG4gICAgfSxcbiAgICBhZGp1c3RDdXJyZW50U3Bpbm5lcjogZnVuY3Rpb24gYWRqdXN0Q3VycmVudFNwaW5uZXIodHlwZSkge1xuICAgICAgdGhpcy5hZGp1c3RTcGlubmVyKHR5cGUsIHRoaXNbdHlwZV0pO1xuICAgIH0sXG4gICAgYWRqdXN0U3Bpbm5lcjogZnVuY3Rpb24gYWRqdXN0U3Bpbm5lcih0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuYXJyb3dDb250cm9sKSByZXR1cm47XG4gICAgICB2YXIgZWwgPSB0aGlzLiRyZWZzW3R5cGVdLndyYXA7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgZWwuc2Nyb2xsVG9wID0gTWF0aC5tYXgoMCwgdmFsdWUgKiB0aGlzLnR5cGVJdGVtSGVpZ2h0KHR5cGUpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNjcm9sbERvd246IGZ1bmN0aW9uIHNjcm9sbERvd24oc3RlcCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5jdXJyZW50U2Nyb2xsYmFyKSB7XG4gICAgICAgIHRoaXMuZW1pdFNlbGVjdFJhbmdlKCdob3VycycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLmN1cnJlbnRTY3JvbGxiYXI7XG4gICAgICB2YXIgaG91cnNMaXN0ID0gdGhpcy5ob3Vyc0xpc3Q7XG4gICAgICB2YXIgbm93ID0gdGhpc1tsYWJlbF07XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRTY3JvbGxiYXIgPT09ICdob3VycycpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gTWF0aC5hYnMoc3RlcCk7XG4gICAgICAgIHN0ZXAgPSBzdGVwID4gMCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGhvdXJzTGlzdC5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiB0b3RhbCkge1xuICAgICAgICAgIG5vdyA9IChub3cgKyBzdGVwICsgaG91cnNMaXN0Lmxlbmd0aCkgJSBob3Vyc0xpc3QubGVuZ3RoO1xuICAgICAgICAgIGlmIChob3Vyc0xpc3Rbbm93XSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvdGFsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdXJzTGlzdFtub3ddKSByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3cgPSAobm93ICsgc3RlcCArIDYwKSAlIDYwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGlmeURhdGVGaWVsZChsYWJlbCwgbm93KTtcbiAgICAgIHRoaXMuYWRqdXN0U3Bpbm5lcihsYWJlbCwgbm93KTtcbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5lbWl0U2VsZWN0UmFuZ2UoX3RoaXMzLmN1cnJlbnRTY3JvbGxiYXIpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhbVBtOiBmdW5jdGlvbiBhbVBtKGhvdXIpIHtcbiAgICAgIHZhciBzaG91bGRTaG93QW1QbSA9IHRoaXMuYW1QbU1vZGUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnO1xuICAgICAgaWYgKCFzaG91bGRTaG93QW1QbSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGlzQ2FwaXRhbCA9IHRoaXMuYW1QbU1vZGUgPT09ICdBJztcbiAgICAgIHZhciBjb250ZW50ID0gaG91ciA8IDEyID8gJyBhbScgOiAnIHBtJztcbiAgICAgIGlmIChpc0NhcGl0YWwpIGNvbnRlbnQgPSBjb250ZW50LnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9LFxuICAgIHR5cGVJdGVtSGVpZ2h0OiBmdW5jdGlvbiB0eXBlSXRlbUhlaWdodCh0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmc1t0eXBlXS4kZWwucXVlcnlTZWxlY3RvcignbGknKS5vZmZzZXRIZWlnaHQ7XG4gICAgfSxcbiAgICBzY3JvbGxCYXJIZWlnaHQ6IGZ1bmN0aW9uIHNjcm9sbEJhckhlaWdodCh0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmc1t0eXBlXS4kZWwub2Zmc2V0SGVpZ2h0O1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy90aW1lLXNwaW5uZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhc2ljX3RpbWVfc3Bpbm5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh0aW1lX3NwaW5uZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG52YXIgY29tcG9uZW50Tm9ybWFsaXplciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL2Jhc2ljL3RpbWUtc3Bpbm5lci52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBjb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIGJhc2ljX3RpbWVfc3Bpbm5lcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMvdGltZS1zcGlubmVyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0aW1lX3NwaW5uZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChjb21wb25lbnQuZXhwb3J0cyk7XG5cbi8qKiovIH0pLFxuLyogMzUgKi8sXG4vKiAzNiAqLyxcbi8qIDM3ICovLFxuLyogMzggKi8sXG4vKiAzOSAqLyxcbi8qIDQwICovLFxuLyogNDEgKi8sXG4vKiA0MiAqLyxcbi8qIDQzICovLFxuLyogNDQgKi8sXG4vKiA0NSAqLyxcbi8qIDQ2ICovLFxuLyogNDcgKi8sXG4vKiA0OCAqLyxcbi8qIDQ5ICovLFxuLyogNTAgKi8sXG4vKiA1MSAqLyxcbi8qIDUyICovLFxuLyogNTMgKi8sXG4vKiA1NCAqLyxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BpY2tlci52dWUgKyA0IG1vZHVsZXNcbnZhciBwaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvZGF0ZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjQ0MGQ0ZWEmXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwidHJhbnNpdGlvblwiLFxuICAgIHtcbiAgICAgIGF0dHJzOiB7IG5hbWU6IFwiZWwtem9vbS1pbi10b3BcIiB9LFxuICAgICAgb246IHsgXCJhZnRlci1lbnRlclwiOiBfdm0uaGFuZGxlRW50ZXIsIFwiYWZ0ZXItbGVhdmVcIjogX3ZtLmhhbmRsZUxlYXZlIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS52aXNpYmxlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInZpc2libGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtcGlja2VyLXBhbmVsIGVsLWRhdGUtcGlja2VyIGVsLXBvcHBlclwiLFxuICAgICAgICAgIGNsYXNzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIFwiaGFzLXNpZGViYXJcIjogX3ZtLiRzbG90cy5zaWRlYmFyIHx8IF92bS5zaG9ydGN1dHMsXG4gICAgICAgICAgICAgIFwiaGFzLXRpbWVcIjogX3ZtLnNob3dUaW1lXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZtLnBvcHBlckNsYXNzXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX2JvZHktd3JhcHBlclwiIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF92bS5fdChcInNpZGViYXJcIiksXG4gICAgICAgICAgICAgIF92bS5zaG9ydGN1dHNcbiAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImVsLXBpY2tlci1wYW5lbF9fc2lkZWJhclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0uc2hvcnRjdXRzLCBmdW5jdGlvbihzaG9ydGN1dCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXBpY2tlci1wYW5lbF9fc2hvcnRjdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5oYW5kbGVTaG9ydGN1dENsaWNrKHNob3J0Y3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKHNob3J0Y3V0LnRleHQpKV1cbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX2JvZHlcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLnNob3dUaW1lXG4gICAgICAgICAgICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtZGF0ZS1waWNrZXJfX3RpbWUtaGVhZGVyXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtcGlja2VyX19lZGl0b3Itd3JhcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZWwtaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogX3ZtLnQoXCJlbC5kYXRlcGlja2VyLnNlbGVjdERhdGVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLnZpc2libGVEYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF92bS51c2VySW5wdXREYXRlID0gdmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogX3ZtLmhhbmRsZVZpc2libGVEYXRlQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImNsaWNrb3V0c2lkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LWNsaWNrb3V0c2lkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5oYW5kbGVUaW1lUGlja0Nsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJoYW5kbGVUaW1lUGlja0Nsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtcGlja2VyX19lZGl0b3Itd3JhcFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImVsLWlucHV0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF92bS50KFwiZWwuZGF0ZXBpY2tlci5zZWxlY3RUaW1lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS52aXNpYmxlVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IFwic21hbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnRpbWVQaWNrZXJWaXNpYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfdm0udXNlcklucHV0VGltZSA9IHZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IF92bS5oYW5kbGVWaXNpYmxlVGltZUNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGltZS1waWNrZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogXCJ0aW1lcGlja2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGltZS1hcnJvdy1jb250cm9sXCI6IF92bS5hcnJvd0NvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBfdm0udGltZVBpY2tlclZpc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWNrOiBfdm0uaGFuZGxlVGltZVBpY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudGVkOiBfdm0ucHJveHlUaW1lUGlja2VyRGF0YVByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5jdXJyZW50VmlldyAhPT0gXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImN1cnJlbnRWaWV3ICE9PSAndGltZSdcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtZGF0ZS1waWNrZXJfX2hlYWRlclwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiZWwtZGF0ZS1waWNrZXJfX2hlYWRlci0tYm9yZGVyZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5jdXJyZW50VmlldyA9PT0gXCJ5ZWFyXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5jdXJyZW50VmlldyA9PT0gXCJtb250aFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtcGlja2VyLXBhbmVsX19pY29uLWJ0biBlbC1kYXRlLXBpY2tlcl9fcHJldi1idG4gZWwtaWNvbi1kLWFycm93LWxlZnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBfdm0udChcImVsLmRhdGVwaWNrZXIucHJldlllYXJcIilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ucHJldlllYXIgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uY3VycmVudFZpZXcgPT09IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImN1cnJlbnRWaWV3ID09PSAnZGF0ZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICBcImVsLXBpY2tlci1wYW5lbF9faWNvbi1idG4gZWwtZGF0ZS1waWNrZXJfX3ByZXYtYnRuIGVsLWljb24tYXJyb3ctbGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IF92bS50KFwiZWwuZGF0ZXBpY2tlci5wcmV2TW9udGhcIilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ucHJldk1vbnRoIH1cbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtcGlja2VyX19oZWFkZXItbGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHJvbGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uc2hvd1llYXJQaWNrZXIgfVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLnllYXJMYWJlbCkpXVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uY3VycmVudFZpZXcgPT09IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiY3VycmVudFZpZXcgPT09ICdkYXRlJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1kYXRlLXBpY2tlcl9faGVhZGVyLWxhYmVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBhY3RpdmU6IF92bS5jdXJyZW50VmlldyA9PT0gXCJtb250aFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyByb2xlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnNob3dNb250aFBpY2tlciB9XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udChcImVsLmRhdGVwaWNrZXIubW9udGhcIiArIChfdm0ubW9udGggKyAxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBfYyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICBcImVsLXBpY2tlci1wYW5lbF9faWNvbi1idG4gZWwtZGF0ZS1waWNrZXJfX25leHQtYnRuIGVsLWljb24tZC1hcnJvdy1yaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IF92bS50KFwiZWwuZGF0ZXBpY2tlci5uZXh0WWVhclwiKVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5uZXh0WWVhciB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBfYyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5jdXJyZW50VmlldyA9PT0gXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiY3VycmVudFZpZXcgPT09ICdkYXRlJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtcGlja2VyLXBhbmVsX19pY29uLWJ0biBlbC1kYXRlLXBpY2tlcl9fbmV4dC1idG4gZWwtaWNvbi1hcnJvdy1yaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IF92bS50KFwiZWwuZGF0ZXBpY2tlci5uZXh0TW9udGhcIilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ubmV4dE1vbnRoIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiZWwtcGlja2VyLXBhbmVsX19jb250ZW50XCIgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJkYXRlLXRhYmxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmN1cnJlbnRWaWV3ID09PSBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJjdXJyZW50VmlldyA9PT0gJ2RhdGUnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlbGVjdGlvbi1tb2RlXCI6IF92bS5zZWxlY3Rpb25Nb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmaXJzdC1kYXktb2Ytd2Vla1wiOiBfdm0uZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IF92bS5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgRGF0ZShfdm0uZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBfdm0uZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2VsbC1jbGFzcy1uYW1lXCI6IF92bS5jZWxsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNhYmxlZC1kYXRlXCI6IF92bS5kaXNhYmxlZERhdGVcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IHBpY2s6IF92bS5oYW5kbGVEYXRlUGljayB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInllYXItdGFibGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uY3VycmVudFZpZXcgPT09IFwieWVhclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImN1cnJlbnRWaWV3ID09PSAneWVhcidcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogX3ZtLmRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKF92bS5kZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IF92bS5kYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNhYmxlZC1kYXRlXCI6IF92bS5kaXNhYmxlZERhdGVcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IHBpY2s6IF92bS5oYW5kbGVZZWFyUGljayB9XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBfYyhcIm1vbnRoLXRhYmxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmN1cnJlbnRWaWV3ID09PSBcIm1vbnRoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiY3VycmVudFZpZXcgPT09ICdtb250aCdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0udmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogX3ZtLmRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKF92bS5kZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IF92bS5kYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNhYmxlZC1kYXRlXCI6IF92bS5kaXNhYmxlZERhdGVcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IHBpY2s6IF92bS5oYW5kbGVNb250aFBpY2sgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMlxuICAgICAgICAgICksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5mb290ZXJWaXNpYmxlICYmIF92bS5jdXJyZW50VmlldyA9PT0gXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImZvb3RlclZpc2libGUgJiYgY3VycmVudFZpZXcgPT09ICdkYXRlJ1wiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX2Zvb3RlclwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImVsLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5zZWxlY3Rpb25Nb2RlICE9PSBcImRhdGVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJzZWxlY3Rpb25Nb2RlICE9PSAnZGF0ZXMnXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXBpY2tlci1wYW5lbF9fbGluay1idG5cIixcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHNpemU6IFwibWluaVwiLCB0eXBlOiBcInRleHRcIiB9LFxuICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jaGFuZ2VUb05vdyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS50KFwiZWwuZGF0ZXBpY2tlci5ub3dcIikpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgIFwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImVsLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXBpY2tlci1wYW5lbF9fbGluay1idG5cIixcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHBsYWluOiBcIlwiLCBzaXplOiBcIm1pbmlcIiB9LFxuICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jb25maXJtIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLnQoXCJlbC5kYXRlcGlja2VyLmNvbmZpcm1cIikpICtcbiAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgIFwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC9kYXRlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yNDQwZDRlYSZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL3V0aWxzL2RhdGUtdXRpbFwiXG52YXIgZGF0ZV91dGlsXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy9jbGlja291dHNpZGVcIlxudmFyIGNsaWNrb3V0c2lkZV8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBjbGlja291dHNpZGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY2xpY2tvdXRzaWRlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi9taXhpbnMvbG9jYWxlXCJcbnZhciBsb2NhbGVfID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBsb2NhbGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9jYWxlXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi9pbnB1dFwiXG52YXIgaW5wdXRfID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgaW5wdXRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaW5wdXRfKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL2J1dHRvblwiXG52YXIgYnV0dG9uXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xudmFyIGJ1dHRvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihidXR0b25fKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC90aW1lLnZ1ZSArIDQgbW9kdWxlc1xudmFyIHBhbmVsX3RpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMveWVhci10YWJsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Yzg2YWI1ZTAmXG52YXIgeWVhcl90YWJsZXZ1ZV90eXBlX3RlbXBsYXRlX2lkX2M4NmFiNWUwX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInRhYmxlXCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJlbC15ZWFyLXRhYmxlXCIsIG9uOiB7IGNsaWNrOiBfdm0uaGFuZGxlWWVhclRhYmxlQ2xpY2sgfSB9LFxuICAgIFtcbiAgICAgIF9jKFwidGJvZHlcIiwgW1xuICAgICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwidGRcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgIGNsYXNzOiBfdm0uZ2V0Q2VsbFN0eWxlKF92bS5zdGFydFllYXIgKyAwKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfYyhcImFcIiwgeyBzdGF0aWNDbGFzczogXCJjZWxsXCIgfSwgW192bS5fdihfdm0uX3MoX3ZtLnN0YXJ0WWVhcikpXSldXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwidGRcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgIGNsYXNzOiBfdm0uZ2V0Q2VsbFN0eWxlKF92bS5zdGFydFllYXIgKyAxKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJhXCIsIHsgc3RhdGljQ2xhc3M6IFwiY2VsbFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5zdGFydFllYXIgKyAxKSlcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLFxuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJ0ZFwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJhdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgY2xhc3M6IF92bS5nZXRDZWxsU3R5bGUoX3ZtLnN0YXJ0WWVhciArIDIpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImFcIiwgeyBzdGF0aWNDbGFzczogXCJjZWxsXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnN0YXJ0WWVhciArIDIpKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInRkXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICBjbGFzczogX3ZtLmdldENlbGxTdHlsZShfdm0uc3RhcnRZZWFyICsgMylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiYVwiLCB7IHN0YXRpY0NsYXNzOiBcImNlbGxcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uc3RhcnRZZWFyICsgMykpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICBdKSxcbiAgICAgICAgX2MoXCJ0clwiLCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInRkXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICBjbGFzczogX3ZtLmdldENlbGxTdHlsZShfdm0uc3RhcnRZZWFyICsgNClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiYVwiLCB7IHN0YXRpY0NsYXNzOiBcImNlbGxcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uc3RhcnRZZWFyICsgNCkpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwidGRcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgIGNsYXNzOiBfdm0uZ2V0Q2VsbFN0eWxlKF92bS5zdGFydFllYXIgKyA1KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJhXCIsIHsgc3RhdGljQ2xhc3M6IFwiY2VsbFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5zdGFydFllYXIgKyA1KSlcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLFxuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJ0ZFwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJhdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgY2xhc3M6IF92bS5nZXRDZWxsU3R5bGUoX3ZtLnN0YXJ0WWVhciArIDYpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcImFcIiwgeyBzdGF0aWNDbGFzczogXCJjZWxsXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnN0YXJ0WWVhciArIDYpKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInRkXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICBjbGFzczogX3ZtLmdldENlbGxTdHlsZShfdm0uc3RhcnRZZWFyICsgNylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiYVwiLCB7IHN0YXRpY0NsYXNzOiBcImNlbGxcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uc3RhcnRZZWFyICsgNykpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICBdKSxcbiAgICAgICAgX2MoXCJ0clwiLCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInRkXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICBjbGFzczogX3ZtLmdldENlbGxTdHlsZShfdm0uc3RhcnRZZWFyICsgOClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiYVwiLCB7IHN0YXRpY0NsYXNzOiBcImNlbGxcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uc3RhcnRZZWFyICsgOCkpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwidGRcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgIGNsYXNzOiBfdm0uZ2V0Q2VsbFN0eWxlKF92bS5zdGFydFllYXIgKyA5KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJhXCIsIHsgc3RhdGljQ2xhc3M6IFwiY2VsbFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5zdGFydFllYXIgKyA5KSlcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLFxuICAgICAgICAgIF9jKFwidGRcIiksXG4gICAgICAgICAgX2MoXCJ0ZFwiKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdXG4gIClcbn1cbnZhciB5ZWFyX3RhYmxldnVlX3R5cGVfdGVtcGxhdGVfaWRfYzg2YWI1ZTBfc3RhdGljUmVuZGVyRm5zID0gW11cbnllYXJfdGFibGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jODZhYjVlMF9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy95ZWFyLXRhYmxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1jODZhYjVlMCZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiBleHRlcm5hbCBcImVsZW1lbnQtdWkvbGliL3V0aWxzL2RvbVwiXG52YXIgZG9tXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy91dGlsXCJcbnZhciB1dGlsXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy95ZWFyLXRhYmxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuXG52YXIgeWVhcl90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2RhdGVzSW5ZZWFyID0gZnVuY3Rpb24gZGF0ZXNJblllYXIoeWVhcikge1xuICB2YXIgbnVtT2ZEYXlzID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJnZXREYXlDb3VudE9mWWVhclwiXSkoeWVhcik7XG4gIHZhciBmaXJzdERheSA9IG5ldyBEYXRlKHllYXIsIDAsIDEpO1xuICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJyYW5nZVwiXSkobnVtT2ZEYXlzKS5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0RGF0ZVwiXSkoZmlyc3REYXksIG4pO1xuICB9KTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHllYXJfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBwcm9wczoge1xuICAgIGRpc2FibGVkRGF0ZToge30sXG4gICAgdmFsdWU6IHt9LFxuICAgIGRlZmF1bHRWYWx1ZToge1xuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IodmFsKSB7XG4gICAgICAgIC8vIG51bGwgb3IgdmFsaWQgRGF0ZSBPYmplY3RcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgaW5zdGFuY2VvZiBEYXRlICYmIE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlXCJdKSh2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0ZToge31cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIHN0YXJ0WWVhcjogZnVuY3Rpb24gc3RhcnRZZWFyKCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5kYXRlLmdldEZ1bGxZZWFyKCkgLyAxMCkgKiAxMDtcbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGdldENlbGxTdHlsZTogZnVuY3Rpb24gZ2V0Q2VsbFN0eWxlKHllYXIpIHtcbiAgICAgIHZhciBzdHlsZSA9IHt9O1xuICAgICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcblxuICAgICAgc3R5bGUuZGlzYWJsZWQgPSB0eXBlb2YgdGhpcy5kaXNhYmxlZERhdGUgPT09ICdmdW5jdGlvbicgPyB5ZWFyX3RhYmxldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfZGF0ZXNJblllYXIoeWVhcikuZXZlcnkodGhpcy5kaXNhYmxlZERhdGUpIDogZmFsc2U7XG4gICAgICBzdHlsZS5jdXJyZW50ID0gT2JqZWN0KHV0aWxfW1wiYXJyYXlGaW5kSW5kZXhcIl0pKE9iamVjdCh1dGlsX1tcImNvZXJjZVRydXRoeVZhbHVlVG9BcnJheVwiXSkodGhpcy52YWx1ZSksIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXI7XG4gICAgICB9KSA+PSAwO1xuICAgICAgc3R5bGUudG9kYXkgPSB0b2RheS5nZXRGdWxsWWVhcigpID09PSB5ZWFyO1xuICAgICAgc3R5bGUuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdFZhbHVlICYmIHRoaXMuZGVmYXVsdFZhbHVlLmdldEZ1bGxZZWFyKCkgPT09IHllYXI7XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuICAgIGhhbmRsZVllYXJUYWJsZUNsaWNrOiBmdW5jdGlvbiBoYW5kbGVZZWFyVGFibGVDbGljayhldmVudCkge1xuICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgICAgIGlmIChPYmplY3QoZG9tX1tcImhhc0NsYXNzXCJdKSh0YXJnZXQucGFyZW50Tm9kZSwgJ2Rpc2FibGVkJykpIHJldHVybjtcbiAgICAgICAgdmFyIHllYXIgPSB0YXJnZXQudGV4dENvbnRlbnQgfHwgdGFyZ2V0LmlubmVyVGV4dDtcbiAgICAgICAgdGhpcy4kZW1pdCgncGljaycsIE51bWJlcih5ZWFyKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL2Jhc2ljL3llYXItdGFibGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGJhc2ljX3llYXJfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoeWVhcl90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcbnZhciBjb21wb25lbnROb3JtYWxpemVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMveWVhci10YWJsZS52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBjb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIGJhc2ljX3llYXJfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHllYXJfdGFibGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jODZhYjVlMF9yZW5kZXIsXG4gIHllYXJfdGFibGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF9jODZhYjVlMF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMveWVhci10YWJsZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeWVhcl90YWJsZSA9IChjb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy9tb250aC10YWJsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NjU0ZDRmNDImXG52YXIgbW9udGhfdGFibGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF82NTRkNGY0Ml9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ0YWJsZVwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImVsLW1vbnRoLXRhYmxlXCIsXG4gICAgICBvbjogeyBjbGljazogX3ZtLmhhbmRsZU1vbnRoVGFibGVDbGljaywgbW91c2Vtb3ZlOiBfdm0uaGFuZGxlTW91c2VNb3ZlIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcInRib2R5XCIsXG4gICAgICAgIF92bS5fbChfdm0ucm93cywgZnVuY3Rpb24ocm93LCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICBcInRyXCIsXG4gICAgICAgICAgICB7IGtleToga2V5IH0sXG4gICAgICAgICAgICBfdm0uX2wocm93LCBmdW5jdGlvbihjZWxsLCBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jKFwidGRcIiwgeyBrZXk6IGtleSwgY2xhc3M6IF92bS5nZXRDZWxsU3R5bGUoY2VsbCkgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIFtcbiAgICAgICAgICAgICAgICAgIF9jKFwiYVwiLCB7IHN0YXRpY0NsYXNzOiBcImNlbGxcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0udChcImVsLmRhdGVwaWNrZXIubW9udGhzLlwiICsgX3ZtLm1vbnRoc1tjZWxsLnRleHRdKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAwXG4gICAgICAgICAgKVxuICAgICAgICB9KSxcbiAgICAgICAgMFxuICAgICAgKVxuICAgIF1cbiAgKVxufVxudmFyIG1vbnRoX3RhYmxldnVlX3R5cGVfdGVtcGxhdGVfaWRfNjU0ZDRmNDJfc3RhdGljUmVuZGVyRm5zID0gW11cbm1vbnRoX3RhYmxldnVlX3R5cGVfdGVtcGxhdGVfaWRfNjU0ZDRmNDJfcmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMvbW9udGgtdGFibGUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTY1NGQ0ZjQyJlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMvbW9udGgtdGFibGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cblxuXG52YXIgbW9udGhfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19kYXRlc0luTW9udGggPSBmdW5jdGlvbiBkYXRlc0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgdmFyIG51bU9mRGF5cyA9IE9iamVjdChkYXRlX3V0aWxfW1wiZ2V0RGF5Q291bnRPZk1vbnRoXCJdKSh5ZWFyLCBtb250aCk7XG4gIHZhciBmaXJzdERheSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wicmFuZ2VcIl0pKG51bU9mRGF5cykubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wibmV4dERhdGVcIl0pKGZpcnN0RGF5LCBuKTtcbiAgfSk7XG59O1xuXG52YXIgY2xlYXJEYXRlID0gZnVuY3Rpb24gY2xlYXJEYXRlKGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpKTtcbn07XG5cbnZhciBnZXRNb250aFRpbWVzdGFtcCA9IGZ1bmN0aW9uIGdldE1vbnRoVGltZXN0YW1wKHRpbWUpIHtcbiAgaWYgKHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdGltZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY2xlYXJEYXRlKG5ldyBEYXRlKHRpbWUpKS5nZXRUaW1lKCk7XG4gIH0gZWxzZSBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gY2xlYXJEYXRlKHRpbWUpLmdldFRpbWUoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9udGhfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBwcm9wczoge1xuICAgIGRpc2FibGVkRGF0ZToge30sXG4gICAgdmFsdWU6IHt9LFxuICAgIHNlbGVjdGlvbk1vZGU6IHtcbiAgICAgIGRlZmF1bHQ6ICdtb250aCdcbiAgICB9LFxuICAgIG1pbkRhdGU6IHt9LFxuXG4gICAgbWF4RGF0ZToge30sXG4gICAgZGVmYXVsdFZhbHVlOiB7XG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgLy8gbnVsbCBvciB2YWxpZCBEYXRlIE9iamVjdFxuICAgICAgICByZXR1cm4gdmFsID09PSBudWxsIHx8IE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlXCJdKSh2YWwpIHx8IEFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwuZXZlcnkoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRlOiB7fSxcbiAgICByYW5nZVN0YXRlOiB7XG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbmREYXRlOiBudWxsLFxuICAgICAgICAgIHNlbGVjdGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWl4aW5zOiBbbG9jYWxlX2RlZmF1bHQuYV0sXG5cbiAgd2F0Y2g6IHtcbiAgICAncmFuZ2VTdGF0ZS5lbmREYXRlJzogZnVuY3Rpb24gcmFuZ2VTdGF0ZUVuZERhdGUobmV3VmFsKSB7XG4gICAgICB0aGlzLm1hcmtSYW5nZSh0aGlzLm1pbkRhdGUsIG5ld1ZhbCk7XG4gICAgfSxcbiAgICBtaW5EYXRlOiBmdW5jdGlvbiBtaW5EYXRlKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICBpZiAoZ2V0TW9udGhUaW1lc3RhbXAobmV3VmFsKSAhPT0gZ2V0TW9udGhUaW1lc3RhbXAob2xkVmFsKSkge1xuICAgICAgICB0aGlzLm1hcmtSYW5nZSh0aGlzLm1pbkRhdGUsIHRoaXMubWF4RGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXhEYXRlOiBmdW5jdGlvbiBtYXhEYXRlKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICBpZiAoZ2V0TW9udGhUaW1lc3RhbXAobmV3VmFsKSAhPT0gZ2V0TW9udGhUaW1lc3RhbXAob2xkVmFsKSkge1xuICAgICAgICB0aGlzLm1hcmtSYW5nZSh0aGlzLm1pbkRhdGUsIHRoaXMubWF4RGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbnRoczogWydqYW4nLCAnZmViJywgJ21hcicsICdhcHInLCAnbWF5JywgJ2p1bicsICdqdWwnLCAnYXVnJywgJ3NlcCcsICdvY3QnLCAnbm92JywgJ2RlYyddLFxuICAgICAgdGFibGVSb3dzOiBbW10sIFtdLCBbXV0sXG4gICAgICBsYXN0Um93OiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH0sXG5cblxuICBtZXRob2RzOiB7XG4gICAgY2VsbE1hdGNoZXNEYXRlOiBmdW5jdGlvbiBjZWxsTWF0Y2hlc0RhdGUoY2VsbCwgZGF0ZSkge1xuICAgICAgdmFyIHZhbHVlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCkgPT09IHZhbHVlLmdldEZ1bGxZZWFyKCkgJiYgTnVtYmVyKGNlbGwudGV4dCkgPT09IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgfSxcbiAgICBnZXRDZWxsU3R5bGU6IGZ1bmN0aW9uIGdldENlbGxTdHlsZShjZWxsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAgIHZhciB5ZWFyID0gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgdmFyIG1vbnRoID0gY2VsbC50ZXh0O1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlID8gQXJyYXkuaXNBcnJheSh0aGlzLmRlZmF1bHRWYWx1ZSkgPyB0aGlzLmRlZmF1bHRWYWx1ZSA6IFt0aGlzLmRlZmF1bHRWYWx1ZV0gOiBbXTtcbiAgICAgIHN0eWxlLmRpc2FibGVkID0gdHlwZW9mIHRoaXMuZGlzYWJsZWREYXRlID09PSAnZnVuY3Rpb24nID8gbW9udGhfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19kYXRlc0luTW9udGgoeWVhciwgbW9udGgpLmV2ZXJ5KHRoaXMuZGlzYWJsZWREYXRlKSA6IGZhbHNlO1xuICAgICAgc3R5bGUuY3VycmVudCA9IE9iamVjdCh1dGlsX1tcImFycmF5RmluZEluZGV4XCJdKShPYmplY3QodXRpbF9bXCJjb2VyY2VUcnV0aHlWYWx1ZVRvQXJyYXlcIl0pKHRoaXMudmFsdWUpLCBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gbW9udGg7XG4gICAgICB9KSA+PSAwO1xuICAgICAgc3R5bGUudG9kYXkgPSB0b2RheS5nZXRGdWxsWWVhcigpID09PSB5ZWFyICYmIHRvZGF5LmdldE1vbnRoKCkgPT09IG1vbnRoO1xuICAgICAgc3R5bGUuZGVmYXVsdCA9IGRlZmF1bHRWYWx1ZS5zb21lKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jZWxsTWF0Y2hlc0RhdGUoY2VsbCwgZGF0ZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNlbGwuaW5SYW5nZSkge1xuICAgICAgICBzdHlsZVsnaW4tcmFuZ2UnXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNlbGwuc3RhcnQpIHtcbiAgICAgICAgICBzdHlsZVsnc3RhcnQtZGF0ZSddID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZWxsLmVuZCkge1xuICAgICAgICAgIHN0eWxlWydlbmQtZGF0ZSddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG4gICAgZ2V0TW9udGhPZkNlbGw6IGZ1bmN0aW9uIGdldE1vbnRoT2ZDZWxsKG1vbnRoKSB7XG4gICAgICB2YXIgeWVhciA9IHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICB9LFxuICAgIG1hcmtSYW5nZTogZnVuY3Rpb24gbWFya1JhbmdlKG1pbkRhdGUsIG1heERhdGUpIHtcbiAgICAgIG1pbkRhdGUgPSBnZXRNb250aFRpbWVzdGFtcChtaW5EYXRlKTtcbiAgICAgIG1heERhdGUgPSBnZXRNb250aFRpbWVzdGFtcChtYXhEYXRlKSB8fCBtaW5EYXRlO1xuICAgICAgdmFyIF9yZWYgPSBbTWF0aC5taW4obWluRGF0ZSwgbWF4RGF0ZSksIE1hdGgubWF4KG1pbkRhdGUsIG1heERhdGUpXTtcbiAgICAgIG1pbkRhdGUgPSBfcmVmWzBdO1xuICAgICAgbWF4RGF0ZSA9IF9yZWZbMV07XG5cbiAgICAgIHZhciByb3dzID0gdGhpcy5yb3dzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGsgPSByb3dzLmxlbmd0aDsgaSA8IGs7IGkrKykge1xuICAgICAgICB2YXIgcm93ID0gcm93c1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSByb3cubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG5cbiAgICAgICAgICB2YXIgY2VsbCA9IHJvd1tqXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBpICogNCArIGo7XG4gICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUuZ2V0RnVsbFllYXIoKSwgaW5kZXgpLmdldFRpbWUoKTtcblxuICAgICAgICAgIGNlbGwuaW5SYW5nZSA9IG1pbkRhdGUgJiYgdGltZSA+PSBtaW5EYXRlICYmIHRpbWUgPD0gbWF4RGF0ZTtcbiAgICAgICAgICBjZWxsLnN0YXJ0ID0gbWluRGF0ZSAmJiB0aW1lID09PSBtaW5EYXRlO1xuICAgICAgICAgIGNlbGwuZW5kID0gbWF4RGF0ZSAmJiB0aW1lID09PSBtYXhEYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgaWYgKCF0aGlzLnJhbmdlU3RhdGUuc2VsZWN0aW5nKSByZXR1cm47XG5cbiAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnRElWJykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQudGFnTmFtZSAhPT0gJ1REJykgcmV0dXJuO1xuXG4gICAgICB2YXIgcm93ID0gdGFyZ2V0LnBhcmVudE5vZGUucm93SW5kZXg7XG4gICAgICB2YXIgY29sdW1uID0gdGFyZ2V0LmNlbGxJbmRleDtcbiAgICAgIC8vIGNhbiBub3Qgc2VsZWN0IGRpc2FibGVkIGRhdGVcbiAgICAgIGlmICh0aGlzLnJvd3Nbcm93XVtjb2x1bW5dLmRpc2FibGVkKSByZXR1cm47XG5cbiAgICAgIC8vIG9ubHkgdXBkYXRlIHJhbmdlU3RhdGUgd2hlbiBtb3VzZSBtb3ZlcyB0byBhIG5ldyBjZWxsXG4gICAgICAvLyB0aGlzIGF2b2lkcyBmcmVxdWVudCBEYXRlIG9iamVjdCBjcmVhdGlvbiBhbmQgaW1wcm92ZXMgcGVyZm9ybWFuY2VcbiAgICAgIGlmIChyb3cgIT09IHRoaXMubGFzdFJvdyB8fCBjb2x1bW4gIT09IHRoaXMubGFzdENvbHVtbikge1xuICAgICAgICB0aGlzLmxhc3RSb3cgPSByb3c7XG4gICAgICAgIHRoaXMubGFzdENvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlcmFuZ2UnLCB7XG4gICAgICAgICAgbWluRGF0ZTogdGhpcy5taW5EYXRlLFxuICAgICAgICAgIG1heERhdGU6IHRoaXMubWF4RGF0ZSxcbiAgICAgICAgICByYW5nZVN0YXRlOiB7XG4gICAgICAgICAgICBzZWxlY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICBlbmREYXRlOiB0aGlzLmdldE1vbnRoT2ZDZWxsKHJvdyAqIDQgKyBjb2x1bW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZU1vbnRoVGFibGVDbGljazogZnVuY3Rpb24gaGFuZGxlTW9udGhUYWJsZUNsaWNrKGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgIT09ICdURCcpIHJldHVybjtcbiAgICAgIGlmIChPYmplY3QoZG9tX1tcImhhc0NsYXNzXCJdKSh0YXJnZXQsICdkaXNhYmxlZCcpKSByZXR1cm47XG4gICAgICB2YXIgY29sdW1uID0gdGFyZ2V0LmNlbGxJbmRleDtcbiAgICAgIHZhciByb3cgPSB0YXJnZXQucGFyZW50Tm9kZS5yb3dJbmRleDtcbiAgICAgIHZhciBtb250aCA9IHJvdyAqIDQgKyBjb2x1bW47XG4gICAgICB2YXIgbmV3RGF0ZSA9IHRoaXMuZ2V0TW9udGhPZkNlbGwobW9udGgpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICBpZiAoIXRoaXMucmFuZ2VTdGF0ZS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICB0aGlzLiRlbWl0KCdwaWNrJywgeyBtaW5EYXRlOiBuZXdEYXRlLCBtYXhEYXRlOiBudWxsIH0pO1xuICAgICAgICAgIHRoaXMucmFuZ2VTdGF0ZS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChuZXdEYXRlID49IHRoaXMubWluRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgncGljaycsIHsgbWluRGF0ZTogdGhpcy5taW5EYXRlLCBtYXhEYXRlOiBuZXdEYXRlIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdwaWNrJywgeyBtaW5EYXRlOiBuZXdEYXRlLCBtYXhEYXRlOiB0aGlzLm1pbkRhdGUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmFuZ2VTdGF0ZS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZW1pdCgncGljaycsIG1vbnRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICByb3dzOiBmdW5jdGlvbiByb3dzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yeSByb3dzIC8gZ2V0Q2VsbENsYXNzZXNcbiAgICAgIHZhciByb3dzID0gdGhpcy50YWJsZVJvd3M7XG4gICAgICB2YXIgZGlzYWJsZWREYXRlID0gdGhpcy5kaXNhYmxlZERhdGU7XG4gICAgICB2YXIgc2VsZWN0ZWREYXRlID0gW107XG4gICAgICB2YXIgbm93ID0gZ2V0TW9udGhUaW1lc3RhbXAobmV3IERhdGUoKSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHZhciByb3cgPSByb3dzW2ldO1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGopIHtcbiAgICAgICAgICB2YXIgY2VsbCA9IHJvd1tqXTtcbiAgICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIGNlbGwgPSB7IHJvdzogaSwgY29sdW1uOiBqLCB0eXBlOiAnbm9ybWFsJywgaW5SYW5nZTogZmFsc2UsIHN0YXJ0OiBmYWxzZSwgZW5kOiBmYWxzZSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNlbGwudHlwZSA9ICdub3JtYWwnO1xuXG4gICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDQgKyBqO1xuICAgICAgICAgIHZhciB0aW1lID0gbmV3IERhdGUoX3RoaXMyLmRhdGUuZ2V0RnVsbFllYXIoKSwgaW5kZXgpLmdldFRpbWUoKTtcbiAgICAgICAgICBjZWxsLmluUmFuZ2UgPSB0aW1lID49IGdldE1vbnRoVGltZXN0YW1wKF90aGlzMi5taW5EYXRlKSAmJiB0aW1lIDw9IGdldE1vbnRoVGltZXN0YW1wKF90aGlzMi5tYXhEYXRlKTtcbiAgICAgICAgICBjZWxsLnN0YXJ0ID0gX3RoaXMyLm1pbkRhdGUgJiYgdGltZSA9PT0gZ2V0TW9udGhUaW1lc3RhbXAoX3RoaXMyLm1pbkRhdGUpO1xuICAgICAgICAgIGNlbGwuZW5kID0gX3RoaXMyLm1heERhdGUgJiYgdGltZSA9PT0gZ2V0TW9udGhUaW1lc3RhbXAoX3RoaXMyLm1heERhdGUpO1xuICAgICAgICAgIHZhciBpc1RvZGF5ID0gdGltZSA9PT0gbm93O1xuXG4gICAgICAgICAgaWYgKGlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNlbGwudHlwZSA9ICd0b2RheSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNlbGwudGV4dCA9IGluZGV4O1xuICAgICAgICAgIHZhciBjZWxsRGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xuICAgICAgICAgIGNlbGwuZGlzYWJsZWQgPSB0eXBlb2YgZGlzYWJsZWREYXRlID09PSAnZnVuY3Rpb24nICYmIGRpc2FibGVkRGF0ZShjZWxsRGF0ZSk7XG4gICAgICAgICAgY2VsbC5zZWxlY3RlZCA9IE9iamVjdCh1dGlsX1tcImFycmF5RmluZFwiXSkoc2VsZWN0ZWREYXRlLCBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpID09PSBjZWxsRGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpczIuJHNldChyb3csIGosIGNlbGwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgX2xvb3Aoaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy9tb250aC10YWJsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmFzaWNfbW9udGhfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAobW9udGhfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL2Jhc2ljL21vbnRoLXRhYmxlLnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIG1vbnRoX3RhYmxlX2NvbXBvbmVudCA9IE9iamVjdChjb21wb25lbnROb3JtYWxpemVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShcbiAgYmFzaWNfbW9udGhfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIG1vbnRoX3RhYmxldnVlX3R5cGVfdGVtcGxhdGVfaWRfNjU0ZDRmNDJfcmVuZGVyLFxuICBtb250aF90YWJsZXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzY1NGQ0ZjQyX3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgbW9udGhfdGFibGVfYXBpOyB9XG5tb250aF90YWJsZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInBhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy9tb250aC10YWJsZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9udGhfdGFibGUgPSAobW9udGhfdGFibGVfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMvZGF0ZS10YWJsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWQxZjMzNDEmXG52YXIgZGF0ZV90YWJsZXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzVkMWYzMzQxX3JlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInRhYmxlXCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtZGF0ZS10YWJsZVwiLFxuICAgICAgY2xhc3M6IHsgXCJpcy13ZWVrLW1vZGVcIjogX3ZtLnNlbGVjdGlvbk1vZGUgPT09IFwid2Vla1wiIH0sXG4gICAgICBhdHRyczogeyBjZWxsc3BhY2luZzogXCIwXCIsIGNlbGxwYWRkaW5nOiBcIjBcIiB9LFxuICAgICAgb246IHsgY2xpY2s6IF92bS5oYW5kbGVDbGljaywgbW91c2Vtb3ZlOiBfdm0uaGFuZGxlTW91c2VNb3ZlIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcInRib2R5XCIsXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwidHJcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX3ZtLnNob3dXZWVrTnVtYmVyXG4gICAgICAgICAgICAgICAgPyBfYyhcInRoXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS50KFwiZWwuZGF0ZXBpY2tlci53ZWVrXCIpKSldKVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF92bS5fbChfdm0uV0VFS1MsIGZ1bmN0aW9uKHdlZWssIGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYyhcInRoXCIsIHsga2V5OiBrZXkgfSwgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0udChcImVsLmRhdGVwaWNrZXIud2Vla3MuXCIgKyB3ZWVrKSkpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfdm0uX2woX3ZtLnJvd3MsIGZ1bmN0aW9uKHJvdywga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgIFwidHJcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtdGFibGVfX3Jvd1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB7IGN1cnJlbnQ6IF92bS5pc1dlZWtBY3RpdmUocm93WzFdKSB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF92bS5fbChyb3csIGZ1bmN0aW9uKGNlbGwsIGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfYyhcInRkXCIsIHsga2V5OiBrZXksIGNsYXNzOiBfdm0uZ2V0Q2VsbENsYXNzZXMoY2VsbCkgfSwgW1xuICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICBcIiArIF92bS5fcyhjZWxsLnRleHQpICsgXCJcXG4gICAgICAgIFwiKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIDJcbiAgICAgIClcbiAgICBdXG4gIClcbn1cbnZhciBkYXRlX3RhYmxldnVlX3R5cGVfdGVtcGxhdGVfaWRfNWQxZjMzNDFfc3RhdGljUmVuZGVyRm5zID0gW11cbmRhdGVfdGFibGV2dWVfdHlwZV90ZW1wbGF0ZV9pZF81ZDFmMzM0MV9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy9kYXRlLXRhYmxlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ZDFmMzM0MSZcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL2Jhc2ljL2RhdGUtdGFibGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cbnZhciBfV0VFS1MgPSBbJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCddO1xudmFyIGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXREYXRlVGltZXN0YW1wID0gZnVuY3Rpb24gZ2V0RGF0ZVRpbWVzdGFtcCh0aW1lKSB7XG4gIGlmICh0eXBlb2YgdGltZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wiY2xlYXJUaW1lXCJdKShuZXcgRGF0ZSh0aW1lKSkuZ2V0VGltZSgpO1xuICB9IGVsc2UgaWYgKHRpbWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wiY2xlYXJUaW1lXCJdKSh0aW1lKS5nZXRUaW1lKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxufTtcblxuLy8gcmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgc2F0aXNmaWVzIGBwcmVkYCBmcm9tIGFyclxuLy8gcmV0dXJuIGEgbmV3IGFycmF5IGlmIG1vZGlmaWNhdGlvbiBvY2N1cnNcbi8vIHJldHVybiB0aGUgb3JpZ2luYWwgYXJyYXkgb3RoZXJ3aXNlXG52YXIgZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX3JlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnIsIHByZWQpIHtcbiAgdmFyIGlkeCA9IHR5cGVvZiBwcmVkID09PSAnZnVuY3Rpb24nID8gT2JqZWN0KHV0aWxfW1wiYXJyYXlGaW5kSW5kZXhcIl0pKGFyciwgcHJlZCkgOiBhcnIuaW5kZXhPZihwcmVkKTtcbiAgcmV0dXJuIGlkeCA+PSAwID8gW10uY29uY2F0KGFyci5zbGljZSgwLCBpZHgpLCBhcnIuc2xpY2UoaWR4ICsgMSkpIDogYXJyO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG1peGluczogW2xvY2FsZV9kZWZhdWx0LmFdLFxuXG4gIHByb3BzOiB7XG4gICAgZmlyc3REYXlPZldlZWs6IHtcbiAgICAgIGRlZmF1bHQ6IDcsXG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uIHZhbGlkYXRvcih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+PSAxICYmIHZhbCA8PSA3O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWx1ZToge30sXG5cbiAgICBkZWZhdWx0VmFsdWU6IHtcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbCkge1xuICAgICAgICAvLyBlaXRoZXI6IG51bGwsIHZhbGlkIERhdGUgb2JqZWN0LCBBcnJheSBvZiB2YWxpZCBEYXRlIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkodmFsKSB8fCBBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLmV2ZXJ5KGRhdGVfdXRpbF9bXCJpc0RhdGVcIl0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkYXRlOiB7fSxcblxuICAgIHNlbGVjdGlvbk1vZGU6IHtcbiAgICAgIGRlZmF1bHQ6ICdkYXknXG4gICAgfSxcblxuICAgIHNob3dXZWVrTnVtYmVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuXG4gICAgZGlzYWJsZWREYXRlOiB7fSxcblxuICAgIGNlbGxDbGFzc05hbWU6IHt9LFxuXG4gICAgbWluRGF0ZToge30sXG5cbiAgICBtYXhEYXRlOiB7fSxcblxuICAgIHJhbmdlU3RhdGU6IHtcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVuZERhdGU6IG51bGwsXG4gICAgICAgICAgc2VsZWN0aW5nOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIG9mZnNldERheTogZnVuY3Rpb24gb2Zmc2V0RGF5KCkge1xuICAgICAgdmFyIHdlZWsgPSB0aGlzLmZpcnN0RGF5T2ZXZWVrO1xuICAgICAgLy8g5ZGo5pel5Li655WM6ZmQ77yM5bem5Y+z5YGP56e755qE5aSp5pWw77yMMzIxNzY1NCDkvovlpoLlkajkuIDlsLHmmK8gLTHvvIznm67nmoTmmK/osIPmlbTliY3kuKTooYzml6XmnJ/nmoTkvY3nva5cbiAgICAgIHJldHVybiB3ZWVrID4gMyA/IDcgLSB3ZWVrIDogLXdlZWs7XG4gICAgfSxcbiAgICBXRUVLUzogZnVuY3Rpb24gV0VFS1MoKSB7XG4gICAgICB2YXIgd2VlayA9IHRoaXMuZmlyc3REYXlPZldlZWs7XG4gICAgICByZXR1cm4gX1dFRUtTLmNvbmNhdChfV0VFS1MpLnNsaWNlKHdlZWssIHdlZWsgKyA3KTtcbiAgICB9LFxuICAgIHllYXI6IGZ1bmN0aW9uIHllYXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgfSxcbiAgICBtb250aDogZnVuY3Rpb24gbW9udGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlLmdldE1vbnRoKCk7XG4gICAgfSxcbiAgICBzdGFydERhdGU6IGZ1bmN0aW9uIHN0YXJ0RGF0ZSgpIHtcbiAgICAgIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImdldFN0YXJ0RGF0ZU9mTW9udGhcIl0pKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gICAgfSxcbiAgICByb3dzOiBmdW5jdGlvbiByb3dzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gVE9ETzogcmVmYWN0b3J5IHJvd3MgLyBnZXRDZWxsQ2xhc3Nlc1xuICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIDEpO1xuICAgICAgdmFyIGRheSA9IE9iamVjdChkYXRlX3V0aWxfW1wiZ2V0Rmlyc3REYXlPZk1vbnRoXCJdKShkYXRlKTsgLy8gZGF5IG9mIGZpcnN0IGRheVxuICAgICAgdmFyIGRhdGVDb3VudE9mTW9udGggPSBPYmplY3QoZGF0ZV91dGlsX1tcImdldERheUNvdW50T2ZNb250aFwiXSkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkpO1xuICAgICAgdmFyIGRhdGVDb3VudE9mTGFzdE1vbnRoID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJnZXREYXlDb3VudE9mTW9udGhcIl0pKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpID09PSAwID8gMTEgOiBkYXRlLmdldE1vbnRoKCkgLSAxKTtcblxuICAgICAgZGF5ID0gZGF5ID09PSAwID8gNyA6IGRheTtcblxuICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0RGF5O1xuICAgICAgdmFyIHJvd3MgPSB0aGlzLnRhYmxlUm93cztcbiAgICAgIHZhciBjb3VudCA9IDE7XG5cbiAgICAgIHZhciBzdGFydERhdGUgPSB0aGlzLnN0YXJ0RGF0ZTtcbiAgICAgIHZhciBkaXNhYmxlZERhdGUgPSB0aGlzLmRpc2FibGVkRGF0ZTtcbiAgICAgIHZhciBjZWxsQ2xhc3NOYW1lID0gdGhpcy5jZWxsQ2xhc3NOYW1lO1xuICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ2RhdGVzJyA/IE9iamVjdCh1dGlsX1tcImNvZXJjZVRydXRoeVZhbHVlVG9BcnJheVwiXSkodGhpcy52YWx1ZSkgOiBbXTtcbiAgICAgIHZhciBub3cgPSBkYXRlX3RhYmxldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfZ2V0RGF0ZVRpbWVzdGFtcChuZXcgRGF0ZSgpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgdmFyIHJvdyA9IHJvd3NbaV07XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgICBpZiAoIXJvd1swXSkge1xuICAgICAgICAgICAgcm93WzBdID0geyB0eXBlOiAnd2VlaycsIHRleHQ6IE9iamVjdChkYXRlX3V0aWxfW1wiZ2V0V2Vla051bWJlclwiXSkoT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0RGF0ZVwiXSkoc3RhcnREYXRlLCBpICogNyArIDEpKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGopIHtcbiAgICAgICAgICB2YXIgY2VsbCA9IHJvd1tfdGhpcy5zaG93V2Vla051bWJlciA/IGogKyAxIDogal07XG4gICAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICBjZWxsID0geyByb3c6IGksIGNvbHVtbjogaiwgdHlwZTogJ25vcm1hbCcsIGluUmFuZ2U6IGZhbHNlLCBzdGFydDogZmFsc2UsIGVuZDogZmFsc2UgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjZWxsLnR5cGUgPSAnbm9ybWFsJztcblxuICAgICAgICAgIHZhciBpbmRleCA9IGkgKiA3ICsgajtcbiAgICAgICAgICB2YXIgdGltZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dERhdGVcIl0pKHN0YXJ0RGF0ZSwgaW5kZXggLSBvZmZzZXQpLmdldFRpbWUoKTtcbiAgICAgICAgICBjZWxsLmluUmFuZ2UgPSB0aW1lID49IGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXREYXRlVGltZXN0YW1wKF90aGlzLm1pbkRhdGUpICYmIHRpbWUgPD0gZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2dldERhdGVUaW1lc3RhbXAoX3RoaXMubWF4RGF0ZSk7XG4gICAgICAgICAgY2VsbC5zdGFydCA9IF90aGlzLm1pbkRhdGUgJiYgdGltZSA9PT0gZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2dldERhdGVUaW1lc3RhbXAoX3RoaXMubWluRGF0ZSk7XG4gICAgICAgICAgY2VsbC5lbmQgPSBfdGhpcy5tYXhEYXRlICYmIHRpbWUgPT09IGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXREYXRlVGltZXN0YW1wKF90aGlzLm1heERhdGUpO1xuICAgICAgICAgIHZhciBpc1RvZGF5ID0gdGltZSA9PT0gbm93O1xuXG4gICAgICAgICAgaWYgKGlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNlbGwudHlwZSA9ICd0b2RheSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPj0gMCAmJiBpIDw9IDEpIHtcbiAgICAgICAgICAgIHZhciBudW1iZXJPZkRheXNGcm9tUHJldmlvdXNNb250aCA9IGRheSArIG9mZnNldCA8IDAgPyA3ICsgZGF5ICsgb2Zmc2V0IDogZGF5ICsgb2Zmc2V0O1xuXG4gICAgICAgICAgICBpZiAoaiArIGkgKiA3ID49IG51bWJlck9mRGF5c0Zyb21QcmV2aW91c01vbnRoKSB7XG4gICAgICAgICAgICAgIGNlbGwudGV4dCA9IGNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjZWxsLnRleHQgPSBkYXRlQ291bnRPZkxhc3RNb250aCAtIChudW1iZXJPZkRheXNGcm9tUHJldmlvdXNNb250aCAtIGogJSA3KSArIDEgKyBpICogNztcbiAgICAgICAgICAgICAgY2VsbC50eXBlID0gJ3ByZXYtbW9udGgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnQgPD0gZGF0ZUNvdW50T2ZNb250aCkge1xuICAgICAgICAgICAgICBjZWxsLnRleHQgPSBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2VsbC50ZXh0ID0gY291bnQrKyAtIGRhdGVDb3VudE9mTW9udGg7XG4gICAgICAgICAgICAgIGNlbGwudHlwZSA9ICduZXh0LW1vbnRoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2VsbERhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcbiAgICAgICAgICBjZWxsLmRpc2FibGVkID0gdHlwZW9mIGRpc2FibGVkRGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkaXNhYmxlZERhdGUoY2VsbERhdGUpO1xuICAgICAgICAgIGNlbGwuc2VsZWN0ZWQgPSBPYmplY3QodXRpbF9bXCJhcnJheUZpbmRcIl0pKHNlbGVjdGVkRGF0ZSwgZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSA9PT0gY2VsbERhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNlbGwuY3VzdG9tQ2xhc3MgPSB0eXBlb2YgY2VsbENsYXNzTmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiBjZWxsQ2xhc3NOYW1lKGNlbGxEYXRlKTtcbiAgICAgICAgICBfdGhpcy4kc2V0KHJvdywgX3RoaXMuc2hvd1dlZWtOdW1iZXIgPyBqICsgMSA6IGosIGNlbGwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgICAgX2xvb3Aoaik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnd2VlaycpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNob3dXZWVrTnVtYmVyID8gMSA6IDA7XG4gICAgICAgICAgdmFyIGVuZCA9IHRoaXMuc2hvd1dlZWtOdW1iZXIgPyA3IDogNjtcbiAgICAgICAgICB2YXIgaXNXZWVrQWN0aXZlID0gdGhpcy5pc1dlZWtBY3RpdmUocm93W3N0YXJ0ICsgMV0pO1xuXG4gICAgICAgICAgcm93W3N0YXJ0XS5pblJhbmdlID0gaXNXZWVrQWN0aXZlO1xuICAgICAgICAgIHJvd1tzdGFydF0uc3RhcnQgPSBpc1dlZWtBY3RpdmU7XG4gICAgICAgICAgcm93W2VuZF0uaW5SYW5nZSA9IGlzV2Vla0FjdGl2ZTtcbiAgICAgICAgICByb3dbZW5kXS5lbmQgPSBpc1dlZWtBY3RpdmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgJ3JhbmdlU3RhdGUuZW5kRGF0ZSc6IGZ1bmN0aW9uIHJhbmdlU3RhdGVFbmREYXRlKG5ld1ZhbCkge1xuICAgICAgdGhpcy5tYXJrUmFuZ2UodGhpcy5taW5EYXRlLCBuZXdWYWwpO1xuICAgIH0sXG4gICAgbWluRGF0ZTogZnVuY3Rpb24gbWluRGF0ZShuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgaWYgKGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXREYXRlVGltZXN0YW1wKG5ld1ZhbCkgIT09IGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXREYXRlVGltZXN0YW1wKG9sZFZhbCkpIHtcbiAgICAgICAgdGhpcy5tYXJrUmFuZ2UodGhpcy5taW5EYXRlLCB0aGlzLm1heERhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWF4RGF0ZTogZnVuY3Rpb24gbWF4RGF0ZShuZXdWYWwsIG9sZFZhbCkge1xuICAgICAgaWYgKGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXREYXRlVGltZXN0YW1wKG5ld1ZhbCkgIT09IGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19nZXREYXRlVGltZXN0YW1wKG9sZFZhbCkpIHtcbiAgICAgICAgdGhpcy5tYXJrUmFuZ2UodGhpcy5taW5EYXRlLCB0aGlzLm1heERhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZVJvd3M6IFtbXSwgW10sIFtdLCBbXSwgW10sIFtdXSxcbiAgICAgIGxhc3RSb3c6IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfSxcblxuXG4gIG1ldGhvZHM6IHtcbiAgICBjZWxsTWF0Y2hlc0RhdGU6IGZ1bmN0aW9uIGNlbGxNYXRjaGVzRGF0ZShjZWxsLCBkYXRlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIHJldHVybiB0aGlzLnllYXIgPT09IHZhbHVlLmdldEZ1bGxZZWFyKCkgJiYgdGhpcy5tb250aCA9PT0gdmFsdWUuZ2V0TW9udGgoKSAmJiBOdW1iZXIoY2VsbC50ZXh0KSA9PT0gdmFsdWUuZ2V0RGF0ZSgpO1xuICAgIH0sXG4gICAgZ2V0Q2VsbENsYXNzZXM6IGZ1bmN0aW9uIGdldENlbGxDbGFzc2VzKGNlbGwpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgc2VsZWN0aW9uTW9kZSA9IHRoaXMuc2VsZWN0aW9uTW9kZTtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSB0aGlzLmRlZmF1bHRWYWx1ZSA/IEFycmF5LmlzQXJyYXkodGhpcy5kZWZhdWx0VmFsdWUpID8gdGhpcy5kZWZhdWx0VmFsdWUgOiBbdGhpcy5kZWZhdWx0VmFsdWVdIDogW107XG5cbiAgICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgICBpZiAoKGNlbGwudHlwZSA9PT0gJ25vcm1hbCcgfHwgY2VsbC50eXBlID09PSAndG9kYXknKSAmJiAhY2VsbC5kaXNhYmxlZCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ2F2YWlsYWJsZScpO1xuICAgICAgICBpZiAoY2VsbC50eXBlID09PSAndG9kYXknKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKCd0b2RheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc2VzLnB1c2goY2VsbC50eXBlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNlbGwudHlwZSA9PT0gJ25vcm1hbCcgJiYgZGVmYXVsdFZhbHVlLnNvbWUoZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5jZWxsTWF0Y2hlc0RhdGUoY2VsbCwgZGF0ZSk7XG4gICAgICB9KSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ2RlZmF1bHQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbk1vZGUgPT09ICdkYXknICYmIChjZWxsLnR5cGUgPT09ICdub3JtYWwnIHx8IGNlbGwudHlwZSA9PT0gJ3RvZGF5JykgJiYgdGhpcy5jZWxsTWF0Y2hlc0RhdGUoY2VsbCwgdGhpcy52YWx1ZSkpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKCdjdXJyZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjZWxsLmluUmFuZ2UgJiYgKGNlbGwudHlwZSA9PT0gJ25vcm1hbCcgfHwgY2VsbC50eXBlID09PSAndG9kYXknIHx8IHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3dlZWsnKSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ2luLXJhbmdlJyk7XG5cbiAgICAgICAgaWYgKGNlbGwuc3RhcnQpIHtcbiAgICAgICAgICBjbGFzc2VzLnB1c2goJ3N0YXJ0LWRhdGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZWxsLmVuZCkge1xuICAgICAgICAgIGNsYXNzZXMucHVzaCgnZW5kLWRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2VsbC5kaXNhYmxlZCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goJ2Rpc2FibGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjZWxsLnNlbGVjdGVkKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaCgnc2VsZWN0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNlbGwuY3VzdG9tQ2xhc3MpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGNlbGwuY3VzdG9tQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG4gICAgfSxcbiAgICBnZXREYXRlT2ZDZWxsOiBmdW5jdGlvbiBnZXREYXRlT2ZDZWxsKHJvdywgY29sdW1uKSB7XG4gICAgICB2YXIgb2Zmc2V0RnJvbVN0YXJ0ID0gcm93ICogNyArIChjb2x1bW4gLSAodGhpcy5zaG93V2Vla051bWJlciA/IDEgOiAwKSkgLSB0aGlzLm9mZnNldERheTtcbiAgICAgIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHREYXRlXCJdKSh0aGlzLnN0YXJ0RGF0ZSwgb2Zmc2V0RnJvbVN0YXJ0KTtcbiAgICB9LFxuICAgIGlzV2Vla0FjdGl2ZTogZnVuY3Rpb24gaXNXZWVrQWN0aXZlKGNlbGwpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgIT09ICd3ZWVrJykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIDEpO1xuICAgICAgdmFyIHllYXIgPSBuZXdEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICB2YXIgbW9udGggPSBuZXdEYXRlLmdldE1vbnRoKCk7XG5cbiAgICAgIGlmIChjZWxsLnR5cGUgPT09ICdwcmV2LW1vbnRoJykge1xuICAgICAgICBuZXdEYXRlLnNldE1vbnRoKG1vbnRoID09PSAwID8gMTEgOiBtb250aCAtIDEpO1xuICAgICAgICBuZXdEYXRlLnNldEZ1bGxZZWFyKG1vbnRoID09PSAwID8geWVhciAtIDEgOiB5ZWFyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNlbGwudHlwZSA9PT0gJ25leHQtbW9udGgnKSB7XG4gICAgICAgIG5ld0RhdGUuc2V0TW9udGgobW9udGggPT09IDExID8gMCA6IG1vbnRoICsgMSk7XG4gICAgICAgIG5ld0RhdGUuc2V0RnVsbFllYXIobW9udGggPT09IDExID8geWVhciArIDEgOiB5ZWFyKTtcbiAgICAgIH1cblxuICAgICAgbmV3RGF0ZS5zZXREYXRlKHBhcnNlSW50KGNlbGwudGV4dCwgMTApKTtcblxuICAgICAgaWYgKE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlXCJdKSh0aGlzLnZhbHVlKSkge1xuICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gKHRoaXMudmFsdWUuZ2V0RGF5KCkgLSB0aGlzLmZpcnN0RGF5T2ZXZWVrICsgNykgJSA3IC0gMTtcbiAgICAgICAgdmFyIHdlZWtEYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwcmV2RGF0ZVwiXSkodGhpcy52YWx1ZSwgZGF5T2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHdlZWtEYXRlLmdldFRpbWUoKSA9PT0gbmV3RGF0ZS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBtYXJrUmFuZ2U6IGZ1bmN0aW9uIG1hcmtSYW5nZShtaW5EYXRlLCBtYXhEYXRlKSB7XG4gICAgICBtaW5EYXRlID0gZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2dldERhdGVUaW1lc3RhbXAobWluRGF0ZSk7XG4gICAgICBtYXhEYXRlID0gZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2dldERhdGVUaW1lc3RhbXAobWF4RGF0ZSkgfHwgbWluRGF0ZTtcbiAgICAgIHZhciBfcmVmID0gW01hdGgubWluKG1pbkRhdGUsIG1heERhdGUpLCBNYXRoLm1heChtaW5EYXRlLCBtYXhEYXRlKV07XG4gICAgICBtaW5EYXRlID0gX3JlZlswXTtcbiAgICAgIG1heERhdGUgPSBfcmVmWzFdO1xuXG5cbiAgICAgIHZhciBzdGFydERhdGUgPSB0aGlzLnN0YXJ0RGF0ZTtcbiAgICAgIHZhciByb3dzID0gdGhpcy5yb3dzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGsgPSByb3dzLmxlbmd0aDsgaSA8IGs7IGkrKykge1xuICAgICAgICB2YXIgcm93ID0gcm93c1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSByb3cubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2hvd1dlZWtOdW1iZXIgJiYgaiA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgICB2YXIgX2NlbGwgPSByb3dbal07XG4gICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDcgKyBqICsgKHRoaXMuc2hvd1dlZWtOdW1iZXIgPyAtMSA6IDApO1xuICAgICAgICAgIHZhciB0aW1lID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0RGF0ZVwiXSkoc3RhcnREYXRlLCBpbmRleCAtIHRoaXMub2Zmc2V0RGF5KS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICBfY2VsbC5pblJhbmdlID0gbWluRGF0ZSAmJiB0aW1lID49IG1pbkRhdGUgJiYgdGltZSA8PSBtYXhEYXRlO1xuICAgICAgICAgIF9jZWxsLnN0YXJ0ID0gbWluRGF0ZSAmJiB0aW1lID09PSBtaW5EYXRlO1xuICAgICAgICAgIF9jZWxsLmVuZCA9IG1heERhdGUgJiYgdGltZSA9PT0gbWF4RGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5yYW5nZVN0YXRlLnNlbGVjdGluZykgcmV0dXJuO1xuXG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnU1BBTicpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgIT09ICdURCcpIHJldHVybjtcblxuICAgICAgdmFyIHJvdyA9IHRhcmdldC5wYXJlbnROb2RlLnJvd0luZGV4IC0gMTtcbiAgICAgIHZhciBjb2x1bW4gPSB0YXJnZXQuY2VsbEluZGV4O1xuXG4gICAgICAvLyBjYW4gbm90IHNlbGVjdCBkaXNhYmxlZCBkYXRlXG4gICAgICBpZiAodGhpcy5yb3dzW3Jvd11bY29sdW1uXS5kaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBvbmx5IHVwZGF0ZSByYW5nZVN0YXRlIHdoZW4gbW91c2UgbW92ZXMgdG8gYSBuZXcgY2VsbFxuICAgICAgLy8gdGhpcyBhdm9pZHMgZnJlcXVlbnQgRGF0ZSBvYmplY3QgY3JlYXRpb24gYW5kIGltcHJvdmVzIHBlcmZvcm1hbmNlXG4gICAgICBpZiAocm93ICE9PSB0aGlzLmxhc3RSb3cgfHwgY29sdW1uICE9PSB0aGlzLmxhc3RDb2x1bW4pIHtcbiAgICAgICAgdGhpcy5sYXN0Um93ID0gcm93O1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZXJhbmdlJywge1xuICAgICAgICAgIG1pbkRhdGU6IHRoaXMubWluRGF0ZSxcbiAgICAgICAgICBtYXhEYXRlOiB0aGlzLm1heERhdGUsXG4gICAgICAgICAgcmFuZ2VTdGF0ZToge1xuICAgICAgICAgICAgc2VsZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgZW5kRGF0ZTogdGhpcy5nZXREYXRlT2ZDZWxsKHJvdywgY29sdW1uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09ICdTUEFOJykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSAnRElWJykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldC50YWdOYW1lICE9PSAnVEQnKSByZXR1cm47XG5cbiAgICAgIHZhciByb3cgPSB0YXJnZXQucGFyZW50Tm9kZS5yb3dJbmRleCAtIDE7XG4gICAgICB2YXIgY29sdW1uID0gdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnd2VlaycgPyAxIDogdGFyZ2V0LmNlbGxJbmRleDtcbiAgICAgIHZhciBjZWxsID0gdGhpcy5yb3dzW3Jvd11bY29sdW1uXTtcblxuICAgICAgaWYgKGNlbGwuZGlzYWJsZWQgfHwgY2VsbC50eXBlID09PSAnd2VlaycpIHJldHVybjtcblxuICAgICAgdmFyIG5ld0RhdGUgPSB0aGlzLmdldERhdGVPZkNlbGwocm93LCBjb2x1bW4pO1xuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAncmFuZ2UnKSB7XG4gICAgICAgIGlmICghdGhpcy5yYW5nZVN0YXRlLnNlbGVjdGluZykge1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ3BpY2snLCB7IG1pbkRhdGU6IG5ld0RhdGUsIG1heERhdGU6IG51bGwgfSk7XG4gICAgICAgICAgdGhpcy5yYW5nZVN0YXRlLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld0RhdGUgPj0gdGhpcy5taW5EYXRlKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdwaWNrJywgeyBtaW5EYXRlOiB0aGlzLm1pbkRhdGUsIG1heERhdGU6IG5ld0RhdGUgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ3BpY2snLCB7IG1pbkRhdGU6IG5ld0RhdGUsIG1heERhdGU6IHRoaXMubWluRGF0ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yYW5nZVN0YXRlLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ2RheScpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgncGljaycsIG5ld0RhdGUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICd3ZWVrJykge1xuICAgICAgICB2YXIgd2Vla051bWJlciA9IE9iamVjdChkYXRlX3V0aWxfW1wiZ2V0V2Vla051bWJlclwiXSkobmV3RGF0ZSk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArICd3JyArIHdlZWtOdW1iZXI7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3BpY2snLCB7XG4gICAgICAgICAgeWVhcjogbmV3RGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgIHdlZWs6IHdlZWtOdW1iZXIsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRhdGU6IG5ld0RhdGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ2RhdGVzJykge1xuICAgICAgICB2YXIgX3ZhbHVlID0gdGhpcy52YWx1ZSB8fCBbXTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY2VsbC5zZWxlY3RlZCA/IGRhdGVfdGFibGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19yZW1vdmVGcm9tQXJyYXkoX3ZhbHVlLCBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSA9PT0gbmV3RGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIH0pIDogW10uY29uY2F0KF92YWx1ZSwgW25ld0RhdGVdKTtcbiAgICAgICAgdGhpcy4kZW1pdCgncGljaycsIG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvYmFzaWMvZGF0ZS10YWJsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmFzaWNfZGF0ZV90YWJsZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChkYXRlX3RhYmxldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy9kYXRlLXRhYmxlLnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGRhdGVfdGFibGVfY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBiYXNpY19kYXRlX3RhYmxldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBkYXRlX3RhYmxldnVlX3R5cGVfdGVtcGxhdGVfaWRfNWQxZjMzNDFfcmVuZGVyLFxuICBkYXRlX3RhYmxldnVlX3R5cGVfdGVtcGxhdGVfaWRfNWQxZjMzNDFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBkYXRlX3RhYmxlX2FwaTsgfVxuZGF0ZV90YWJsZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInBhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9iYXNpYy9kYXRlLXRhYmxlLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkYXRlX3RhYmxlID0gKGRhdGVfdGFibGVfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BhbmVsL2RhdGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRhdGV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBtaXhpbnM6IFtsb2NhbGVfZGVmYXVsdC5hXSxcblxuICBkaXJlY3RpdmVzOiB7IENsaWNrb3V0c2lkZTogY2xpY2tvdXRzaWRlX2RlZmF1bHQuYSB9LFxuXG4gIHdhdGNoOiB7XG4gICAgc2hvd1RpbWU6IGZ1bmN0aW9uIHNob3dUaW1lKHZhbCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXZhbCkgcmV0dXJuO1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgdmFyIGlucHV0RWxtID0gX3RoaXMuJHJlZnMuaW5wdXQuJGVsO1xuICAgICAgICBpZiAoaW5wdXRFbG0pIHtcbiAgICAgICAgICBfdGhpcy5waWNrZXJXaWR0aCA9IGlucHV0RWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgMTA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHZhbCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ2RhdGVzJyAmJiB0aGlzLnZhbHVlKSByZXR1cm47XG4gICAgICBpZiAoT2JqZWN0KGRhdGVfdXRpbF9bXCJpc0RhdGVcIl0pKHZhbCkpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUodmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHRoaXMuZ2V0RGVmYXVsdFZhbHVlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZSh2YWwpIHtcbiAgICAgIGlmICghT2JqZWN0KGRhdGVfdXRpbF9bXCJpc0RhdGVcIl0pKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHZhbCA/IG5ldyBEYXRlKHZhbCkgOiBuZXcgRGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGltZVBpY2tlclZpc2libGU6IGZ1bmN0aW9uIHRpbWVQaWNrZXJWaXNpYmxlKHZhbCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh2YWwpIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi4kcmVmcy50aW1lcGlja2VyLmFkanVzdFNwaW5uZXJzKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNlbGVjdGlvbk1vZGU6IGZ1bmN0aW9uIHNlbGVjdGlvbk1vZGUobmV3VmFsKSB7XG4gICAgICBpZiAobmV3VmFsID09PSAnbW9udGgnKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3ICE9PSAneWVhcicgfHwgdGhpcy5jdXJyZW50VmlldyAhPT0gJ21vbnRoJykge1xuICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSAnbW9udGgnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbCA9PT0gJ2RhdGVzJykge1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gJ2RhdGUnO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgcHJveHlUaW1lUGlja2VyRGF0YVByb3BlcnRpZXM6IGZ1bmN0aW9uIHByb3h5VGltZVBpY2tlckRhdGFQcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBmb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQodGltZUZvcm1hdCkge1xuICAgICAgICBfdGhpczMuJHJlZnMudGltZXBpY2tlci5mb3JtYXQgPSB0aW1lRm9ybWF0O1xuICAgICAgfTtcbiAgICAgIHZhciB2YWx1ZSA9IGZ1bmN0aW9uIHZhbHVlKF92YWx1ZSkge1xuICAgICAgICBfdGhpczMuJHJlZnMudGltZXBpY2tlci52YWx1ZSA9IF92YWx1ZTtcbiAgICAgIH07XG4gICAgICB2YXIgZGF0ZSA9IGZ1bmN0aW9uIGRhdGUoX2RhdGUpIHtcbiAgICAgICAgX3RoaXMzLiRyZWZzLnRpbWVwaWNrZXIuZGF0ZSA9IF9kYXRlO1xuICAgICAgfTtcbiAgICAgIHZhciBzZWxlY3RhYmxlUmFuZ2UgPSBmdW5jdGlvbiBzZWxlY3RhYmxlUmFuZ2UoX3NlbGVjdGFibGVSYW5nZSkge1xuICAgICAgICBfdGhpczMuJHJlZnMudGltZXBpY2tlci5zZWxlY3RhYmxlUmFuZ2UgPSBfc2VsZWN0YWJsZVJhbmdlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy4kd2F0Y2goJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgdGhpcy4kd2F0Y2goJ2RhdGUnLCBkYXRlKTtcbiAgICAgIHRoaXMuJHdhdGNoKCdzZWxlY3RhYmxlUmFuZ2UnLCBzZWxlY3RhYmxlUmFuZ2UpO1xuXG4gICAgICBmb3JtYXQodGhpcy50aW1lRm9ybWF0KTtcbiAgICAgIHZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgZGF0ZSh0aGlzLmRhdGUpO1xuICAgICAgc2VsZWN0YWJsZVJhbmdlKHRoaXMuc2VsZWN0YWJsZVJhbmdlKTtcbiAgICB9LFxuICAgIGhhbmRsZUNsZWFyOiBmdW5jdGlvbiBoYW5kbGVDbGVhcigpIHtcbiAgICAgIHRoaXMuZGF0ZSA9IHRoaXMuZ2V0RGVmYXVsdFZhbHVlKCk7XG4gICAgICB0aGlzLiRlbWl0KCdwaWNrJywgbnVsbCk7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRoaXMuJGVtaXQuYXBwbHkodGhpcywgWydwaWNrJywgdmFsdWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhciBkYXRlcyA9IHZhbHVlLm1hcChmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQuc2hvd1RpbWUgPyBPYmplY3QoZGF0ZV91dGlsX1tcImNsZWFyTWlsbGlzZWNvbmRzXCJdKShkYXRlKSA6IE9iamVjdChkYXRlX3V0aWxfW1wiY2xlYXJUaW1lXCJdKShkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGVtaXQuYXBwbHkodGhpcywgWydwaWNrJywgZGF0ZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbWl0LmFwcGx5KHRoaXMsIFsncGljaycsIHRoaXMuc2hvd1RpbWUgPyBPYmplY3QoZGF0ZV91dGlsX1tcImNsZWFyTWlsbGlzZWNvbmRzXCJdKSh2YWx1ZSkgOiBPYmplY3QoZGF0ZV91dGlsX1tcImNsZWFyVGltZVwiXSkodmFsdWUpXS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgICAgdGhpcy51c2VySW5wdXREYXRlID0gbnVsbDtcbiAgICAgIHRoaXMudXNlcklucHV0VGltZSA9IG51bGw7XG4gICAgfSxcblxuXG4gICAgLy8gcmVzZXREYXRlKCkge1xuICAgIC8vICAgdGhpcy5kYXRlID0gbmV3IERhdGUodGhpcy5kYXRlKTtcbiAgICAvLyB9LFxuXG4gICAgc2hvd01vbnRoUGlja2VyOiBmdW5jdGlvbiBzaG93TW9udGhQaWNrZXIoKSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gJ21vbnRoJztcbiAgICB9LFxuICAgIHNob3dZZWFyUGlja2VyOiBmdW5jdGlvbiBzaG93WWVhclBpY2tlcigpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSAneWVhcic7XG4gICAgfSxcblxuXG4gICAgLy8gWFhYOiDmsqHnlKjliLBcbiAgICAvLyBoYW5kbGVMYWJlbENsaWNrKCkge1xuICAgIC8vICAgaWYgKHRoaXMuY3VycmVudFZpZXcgPT09ICdkYXRlJykge1xuICAgIC8vICAgICB0aGlzLnNob3dNb250aFBpY2tlcigpO1xuICAgIC8vICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRWaWV3ID09PSAnbW9udGgnKSB7XG4gICAgLy8gICAgIHRoaXMuc2hvd1llYXJQaWNrZXIoKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9LFxuXG4gICAgcHJldk1vbnRoOiBmdW5jdGlvbiBwcmV2TW9udGgoKSB7XG4gICAgICB0aGlzLmRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcInByZXZNb250aFwiXSkodGhpcy5kYXRlKTtcbiAgICB9LFxuICAgIG5leHRNb250aDogZnVuY3Rpb24gbmV4dE1vbnRoKCkge1xuICAgICAgdGhpcy5kYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0TW9udGhcIl0pKHRoaXMuZGF0ZSk7XG4gICAgfSxcbiAgICBwcmV2WWVhcjogZnVuY3Rpb24gcHJldlllYXIoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50VmlldyA9PT0gJ3llYXInKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wicHJldlllYXJcIl0pKHRoaXMuZGF0ZSwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwcmV2WWVhclwiXSkodGhpcy5kYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5leHRZZWFyOiBmdW5jdGlvbiBuZXh0WWVhcigpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3ID09PSAneWVhcicpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0WWVhclwiXSkodGhpcy5kYXRlLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRZZWFyXCJdKSh0aGlzLmRhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlU2hvcnRjdXRDbGljazogZnVuY3Rpb24gaGFuZGxlU2hvcnRjdXRDbGljayhzaG9ydGN1dCkge1xuICAgICAgaWYgKHNob3J0Y3V0Lm9uQ2xpY2spIHtcbiAgICAgICAgc2hvcnRjdXQub25DbGljayh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVRpbWVQaWNrOiBmdW5jdGlvbiBoYW5kbGVUaW1lUGljayh2YWx1ZSwgdmlzaWJsZSwgZmlyc3QpIHtcbiAgICAgIGlmIChPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkodmFsdWUpKSB7XG4gICAgICAgIHZhciBuZXdEYXRlID0gdGhpcy52YWx1ZSA/IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5VGltZVwiXSkodGhpcy52YWx1ZSwgdmFsdWUuZ2V0SG91cnMoKSwgdmFsdWUuZ2V0TWludXRlcygpLCB2YWx1ZS5nZXRTZWNvbmRzKCkpIDogT2JqZWN0KGRhdGVfdXRpbF9bXCJtb2RpZnlXaXRoVGltZVN0cmluZ1wiXSkodGhpcy5nZXREZWZhdWx0VmFsdWUoKSwgdGhpcy5kZWZhdWx0VGltZSk7XG4gICAgICAgIHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmRhdGUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KHZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcy50aW1lUGlja2VyVmlzaWJsZSA9IHZpc2libGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVUaW1lUGlja0Nsb3NlOiBmdW5jdGlvbiBoYW5kbGVUaW1lUGlja0Nsb3NlKCkge1xuICAgICAgdGhpcy50aW1lUGlja2VyVmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgaGFuZGxlTW9udGhQaWNrOiBmdW5jdGlvbiBoYW5kbGVNb250aFBpY2sobW9udGgpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtb250aCcpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJtb2RpZnlEYXRlXCJdKSh0aGlzLmRhdGUsIHRoaXMueWVhciwgbW9udGgsIDEpO1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5kYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wiY2hhbmdlWWVhck1vbnRoQW5kQ2xhbXBEYXRlXCJdKSh0aGlzLmRhdGUsIHRoaXMueWVhciwgbW9udGgpO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgZW1pdCBpbnRlcm1lZGlhdGUgdmFsdWUgPz9cbiAgICAgICAgLy8gdGhpcy5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSAnZGF0ZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVEYXRlUGljazogZnVuY3Rpb24gaGFuZGxlRGF0ZVBpY2sodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdkYXknKSB7XG4gICAgICAgIHZhciBuZXdEYXRlID0gdGhpcy52YWx1ZSA/IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5RGF0ZVwiXSkodGhpcy52YWx1ZSwgdmFsdWUuZ2V0RnVsbFllYXIoKSwgdmFsdWUuZ2V0TW9udGgoKSwgdmFsdWUuZ2V0RGF0ZSgpKSA6IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5V2l0aFRpbWVTdHJpbmdcIl0pKHZhbHVlLCB0aGlzLmRlZmF1bHRUaW1lKTtcbiAgICAgICAgLy8gY2hhbmdlIGRlZmF1bHQgdGltZSB3aGlsZSBvdXQgb2Ygc2VsZWN0YWJsZVJhbmdlXG4gICAgICAgIGlmICghdGhpcy5jaGVja0RhdGVXaXRoaW5SYW5nZShuZXdEYXRlKSkge1xuICAgICAgICAgIG5ld0RhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeURhdGVcIl0pKHRoaXMuc2VsZWN0YWJsZVJhbmdlWzBdWzBdLCB2YWx1ZS5nZXRGdWxsWWVhcigpLCB2YWx1ZS5nZXRNb250aCgpLCB2YWx1ZS5nZXREYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmRhdGUsIHRoaXMuc2hvd1RpbWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICd3ZWVrJykge1xuICAgICAgICB0aGlzLmVtaXQodmFsdWUuZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ2RhdGVzJykge1xuICAgICAgICB0aGlzLmVtaXQodmFsdWUsIHRydWUpOyAvLyBzZXQgZmFsc2UgdG8ga2VlcCBwYW5lbCBvcGVuXG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVZZWFyUGljazogZnVuY3Rpb24gaGFuZGxlWWVhclBpY2soeWVhcikge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3llYXInKSB7XG4gICAgICAgIHRoaXMuZGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5RGF0ZVwiXSkodGhpcy5kYXRlLCB5ZWFyLCAwLCAxKTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcImNoYW5nZVllYXJNb250aEFuZENsYW1wRGF0ZVwiXSkodGhpcy5kYXRlLCB5ZWFyLCB0aGlzLm1vbnRoKTtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIGVtaXQgaW50ZXJtZWRpYXRlIHZhbHVlID8/XG4gICAgICAgIC8vIHRoaXMuZW1pdCh0aGlzLmRhdGUsIHRydWUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gJ21vbnRoJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGNoYW5nZVRvTm93OiBmdW5jdGlvbiBjaGFuZ2VUb05vdygpIHtcbiAgICAgIC8vIE5PVEU6IG5vdCBhIHBlcm1hbmVudCBzb2x1dGlvblxuICAgICAgLy8gICAgICAgY29uc2lkZXIgZGlzYWJsZSBcIm5vd1wiIGJ1dHRvbiBpbiB0aGUgZnV0dXJlXG4gICAgICBpZiAoKCF0aGlzLmRpc2FibGVkRGF0ZSB8fCAhdGhpcy5kaXNhYmxlZERhdGUobmV3IERhdGUoKSkpICYmIHRoaXMuY2hlY2tEYXRlV2l0aGluUmFuZ2UobmV3IERhdGUoKSkpIHtcbiAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25maXJtOiBmdW5jdGlvbiBjb25maXJtKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ2RhdGVzJykge1xuICAgICAgICB0aGlzLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2YWx1ZSB3ZXJlIGVtaXR0ZWQgaW4gaGFuZGxle0RhdGUsVGltZX1QaWNrLCBub3RoaW5nIHRvIHVwZGF0ZSBoZXJlXG4gICAgICAgIC8vIGRlYWwgd2l0aCB0aGUgc2NlbmFyaW8gd2hlcmU6IHVzZXIgb3BlbnMgdGhlIHBpY2tlciwgdGhlbiBjb25maXJtIHdpdGhvdXQgZG9pbmcgYW55dGhpbmdcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUgOiBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeVdpdGhUaW1lU3RyaW5nXCJdKSh0aGlzLmdldERlZmF1bHRWYWx1ZSgpLCB0aGlzLmRlZmF1bHRUaW1lKTtcbiAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUodmFsdWUpOyAvLyByZWZyZXNoIGRhdGVcbiAgICAgICAgdGhpcy5lbWl0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2V0VmlldzogZnVuY3Rpb24gcmVzZXRWaWV3KCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ21vbnRoJykge1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gJ21vbnRoJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAneWVhcicpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9ICd5ZWFyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXcgPSAnZGF0ZSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVFbnRlcjogZnVuY3Rpb24gaGFuZGxlRW50ZXIoKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24pO1xuICAgIH0sXG4gICAgaGFuZGxlTGVhdmU6IGZ1bmN0aW9uIGhhbmRsZUxlYXZlKCkge1xuICAgICAgdGhpcy4kZW1pdCgnZG9kZXN0cm95Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd24pO1xuICAgIH0sXG4gICAgaGFuZGxlS2V5ZG93bjogZnVuY3Rpb24gaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgdmFyIGxpc3QgPSBbMzgsIDQwLCAzNywgMzldO1xuICAgICAgaWYgKHRoaXMudmlzaWJsZSAmJiAhdGhpcy50aW1lUGlja2VyVmlzaWJsZSkge1xuICAgICAgICBpZiAobGlzdC5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlS2V5Q29udHJvbChrZXlDb2RlKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlDb2RlID09PSAxMyAmJiB0aGlzLnVzZXJJbnB1dERhdGUgPT09IG51bGwgJiYgdGhpcy51c2VySW5wdXRUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gRW50ZXJcbiAgICAgICAgICB0aGlzLmVtaXQodGhpcy5kYXRlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUtleUNvbnRyb2w6IGZ1bmN0aW9uIGhhbmRsZUtleUNvbnRyb2woa2V5Q29kZSkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICd5ZWFyJzoge1xuICAgICAgICAgIDM4OiAtNCwgNDA6IDQsIDM3OiAtMSwgMzk6IDEsIG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGRhdGUsIHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ21vbnRoJzoge1xuICAgICAgICAgIDM4OiAtNCwgNDA6IDQsIDM3OiAtMSwgMzk6IDEsIG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGRhdGUsIHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3dlZWsnOiB7XG4gICAgICAgICAgMzg6IC0xLCA0MDogMSwgMzc6IC0xLCAzOTogMSwgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoZGF0ZSwgc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdkYXknOiB7XG4gICAgICAgICAgMzg6IC03LCA0MDogNywgMzc6IC0xLCAzOTogMSwgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoZGF0ZSwgc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBtb2RlID0gdGhpcy5zZWxlY3Rpb25Nb2RlO1xuICAgICAgdmFyIHllYXIgPSAzLjE1MzZlMTA7XG4gICAgICB2YXIgbm93ID0gdGhpcy5kYXRlLmdldFRpbWUoKTtcbiAgICAgIHZhciBuZXdEYXRlID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgICB3aGlsZSAoTWF0aC5hYnMobm93IC0gbmV3RGF0ZS5nZXRUaW1lKCkpIDw9IHllYXIpIHtcbiAgICAgICAgdmFyIG1hcCA9IG1hcHBpbmdbbW9kZV07XG4gICAgICAgIG1hcC5vZmZzZXQobmV3RGF0ZSwgbWFwW2tleUNvZGVdKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc2FibGVkRGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLmRpc2FibGVkRGF0ZShuZXdEYXRlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3BpY2snLCBuZXdEYXRlLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVWaXNpYmxlVGltZUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlVmlzaWJsZVRpbWVDaGFuZ2UodmFsdWUpIHtcbiAgICAgIHZhciB0aW1lID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwYXJzZURhdGVcIl0pKHZhbHVlLCB0aGlzLnRpbWVGb3JtYXQpO1xuICAgICAgaWYgKHRpbWUgJiYgdGhpcy5jaGVja0RhdGVXaXRoaW5SYW5nZSh0aW1lKSkge1xuICAgICAgICB0aGlzLmRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeURhdGVcIl0pKHRpbWUsIHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5tb250aERhdGUpO1xuICAgICAgICB0aGlzLnVzZXJJbnB1dFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZWZzLnRpbWVwaWNrZXIudmFsdWUgPSB0aGlzLmRhdGU7XG4gICAgICAgIHRoaXMudGltZVBpY2tlclZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZGF0ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVWaXNpYmxlRGF0ZUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlVmlzaWJsZURhdGVDaGFuZ2UodmFsdWUpIHtcbiAgICAgIHZhciBkYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwYXJzZURhdGVcIl0pKHZhbHVlLCB0aGlzLmRhdGVGb3JtYXQpO1xuICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc2FibGVkRGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLmRpc2FibGVkRGF0ZShkYXRlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeVRpbWVcIl0pKGRhdGUsIHRoaXMuZGF0ZS5nZXRIb3VycygpLCB0aGlzLmRhdGUuZ2V0TWludXRlcygpLCB0aGlzLmRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgdGhpcy51c2VySW5wdXREYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNldFZpZXcoKTtcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuZGF0ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1ZhbGlkVmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmICFpc05hTih2YWx1ZSkgJiYgKHR5cGVvZiB0aGlzLmRpc2FibGVkRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/ICF0aGlzLmRpc2FibGVkRGF0ZSh2YWx1ZSkgOiB0cnVlKSAmJiB0aGlzLmNoZWNrRGF0ZVdpdGhpblJhbmdlKHZhbHVlKTtcbiAgICB9LFxuICAgIGdldERlZmF1bHRWYWx1ZTogZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKCkge1xuICAgICAgLy8gaWYgZGVmYXVsdC12YWx1ZSBpcyBzZXQsIHJldHVybiBpdFxuICAgICAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gbm93ICh0aGUgbW9tZW50IHRoaXMgbWV0aG9kIGdldHMgY2FsbGVkKVxuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlID8gbmV3IERhdGUodGhpcy5kZWZhdWx0VmFsdWUpIDogbmV3IERhdGUoKTtcbiAgICB9LFxuICAgIGNoZWNrRGF0ZVdpdGhpblJhbmdlOiBmdW5jdGlvbiBjaGVja0RhdGVXaXRoaW5SYW5nZShkYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RhYmxlUmFuZ2UubGVuZ3RoID4gMCA/IE9iamVjdChkYXRlX3V0aWxfW1widGltZVdpdGhpblJhbmdlXCJdKShkYXRlLCB0aGlzLnNlbGVjdGFibGVSYW5nZSwgdGhpcy5mb3JtYXQgfHwgJ0hIOm1tOnNzJykgOiB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG4gICAgVGltZVBpY2tlcjogcGFuZWxfdGltZVtcImFcIiAvKiBkZWZhdWx0ICovXSwgWWVhclRhYmxlOiB5ZWFyX3RhYmxlLCBNb250aFRhYmxlOiBtb250aF90YWJsZSwgRGF0ZVRhYmxlOiBkYXRlX3RhYmxlLCBFbElucHV0OiBpbnB1dF9kZWZhdWx0LmEsIEVsQnV0dG9uOiBidXR0b25fZGVmYXVsdC5hXG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9wcGVyQ2xhc3M6ICcnLFxuICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCwgLy8gdXNlIGdldERlZmF1bHRWYWx1ZSgpIGZvciB0aW1lIGNvbXB1dGF0aW9uXG4gICAgICBkZWZhdWx0VGltZTogbnVsbCxcbiAgICAgIHNob3dUaW1lOiBmYWxzZSxcbiAgICAgIHNlbGVjdGlvbk1vZGU6ICdkYXknLFxuICAgICAgc2hvcnRjdXRzOiAnJyxcbiAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgY3VycmVudFZpZXc6ICdkYXRlJyxcbiAgICAgIGRpc2FibGVkRGF0ZTogJycsXG4gICAgICBjZWxsQ2xhc3NOYW1lOiAnJyxcbiAgICAgIHNlbGVjdGFibGVSYW5nZTogW10sXG4gICAgICBmaXJzdERheU9mV2VlazogNyxcbiAgICAgIHNob3dXZWVrTnVtYmVyOiBmYWxzZSxcbiAgICAgIHRpbWVQaWNrZXJWaXNpYmxlOiBmYWxzZSxcbiAgICAgIGZvcm1hdDogJycsXG4gICAgICBhcnJvd0NvbnRyb2w6IGZhbHNlLFxuICAgICAgdXNlcklucHV0RGF0ZTogbnVsbCxcbiAgICAgIHVzZXJJbnB1dFRpbWU6IG51bGxcbiAgICB9O1xuICB9LFxuXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICB5ZWFyOiBmdW5jdGlvbiB5ZWFyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIH0sXG4gICAgbW9udGg6IGZ1bmN0aW9uIG1vbnRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRNb250aCgpO1xuICAgIH0sXG4gICAgd2VlazogZnVuY3Rpb24gd2VlaygpIHtcbiAgICAgIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImdldFdlZWtOdW1iZXJcIl0pKHRoaXMuZGF0ZSk7XG4gICAgfSxcbiAgICBtb250aERhdGU6IGZ1bmN0aW9uIG1vbnRoRGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0RGF0ZSgpO1xuICAgIH0sXG4gICAgZm9vdGVyVmlzaWJsZTogZnVuY3Rpb24gZm9vdGVyVmlzaWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dUaW1lIHx8IHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ2RhdGVzJztcbiAgICB9LFxuICAgIHZpc2libGVUaW1lOiBmdW5jdGlvbiB2aXNpYmxlVGltZSgpIHtcbiAgICAgIGlmICh0aGlzLnVzZXJJbnB1dFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlcklucHV0VGltZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImZvcm1hdERhdGVcIl0pKHRoaXMudmFsdWUgfHwgdGhpcy5kZWZhdWx0VmFsdWUsIHRoaXMudGltZUZvcm1hdCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB2aXNpYmxlRGF0ZTogZnVuY3Rpb24gdmlzaWJsZURhdGUoKSB7XG4gICAgICBpZiAodGhpcy51c2VySW5wdXREYXRlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJJbnB1dERhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJmb3JtYXREYXRlXCJdKSh0aGlzLnZhbHVlIHx8IHRoaXMuZGVmYXVsdFZhbHVlLCB0aGlzLmRhdGVGb3JtYXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeWVhckxhYmVsOiBmdW5jdGlvbiB5ZWFyTGFiZWwoKSB7XG4gICAgICB2YXIgeWVhclRyYW5zbGF0aW9uID0gdGhpcy50KCdlbC5kYXRlcGlja2VyLnllYXInKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3ID09PSAneWVhcicpIHtcbiAgICAgICAgdmFyIHN0YXJ0WWVhciA9IE1hdGguZmxvb3IodGhpcy55ZWFyIC8gMTApICogMTA7XG4gICAgICAgIGlmICh5ZWFyVHJhbnNsYXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnRZZWFyICsgJyAnICsgeWVhclRyYW5zbGF0aW9uICsgJyAtICcgKyAoc3RhcnRZZWFyICsgOSkgKyAnICcgKyB5ZWFyVHJhbnNsYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0WWVhciArICcgLSAnICsgKHN0YXJ0WWVhciArIDkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMueWVhciArICcgJyArIHllYXJUcmFuc2xhdGlvbjtcbiAgICB9LFxuICAgIHRpbWVGb3JtYXQ6IGZ1bmN0aW9uIHRpbWVGb3JtYXQoKSB7XG4gICAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wiZXh0cmFjdFRpbWVGb3JtYXRcIl0pKHRoaXMuZm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnSEg6bW06c3MnO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0ZUZvcm1hdDogZnVuY3Rpb24gZGF0ZUZvcm1hdCgpIHtcbiAgICAgIGlmICh0aGlzLmZvcm1hdCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJleHRyYWN0RGF0ZUZvcm1hdFwiXSkodGhpcy5mb3JtYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICd5eXl5LU1NLWRkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvZGF0ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFuZWxfZGF0ZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChkYXRldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC9kYXRlLnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGRhdGVfY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBwYW5lbF9kYXRldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyB2YXIgZGF0ZV9hcGk7IH1cbmRhdGVfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvZGF0ZS52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFuZWxfZGF0ZSA9IChkYXRlX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BhbmVsL2RhdGUtcmFuZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI2NTI4NDlhJlxudmFyIGRhdGVfcmFuZ2V2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yNjUyODQ5YV9yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAge1xuICAgICAgYXR0cnM6IHsgbmFtZTogXCJlbC16b29tLWluLXRvcFwiIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcImFmdGVyLWxlYXZlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIF92bS4kZW1pdChcImRvZGVzdHJveVwiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJzaG93XCIsXG4gICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdm0udmlzaWJsZSxcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJ2aXNpYmxlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXBpY2tlci1wYW5lbCBlbC1kYXRlLXJhbmdlLXBpY2tlciBlbC1wb3BwZXJcIixcbiAgICAgICAgICBjbGFzczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBcImhhcy1zaWRlYmFyXCI6IF92bS4kc2xvdHMuc2lkZWJhciB8fCBfdm0uc2hvcnRjdXRzLFxuICAgICAgICAgICAgICBcImhhcy10aW1lXCI6IF92bS5zaG93VGltZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF92bS5wb3BwZXJDbGFzc1xuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiZWwtcGlja2VyLXBhbmVsX19ib2R5LXdyYXBwZXJcIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uX3QoXCJzaWRlYmFyXCIpLFxuICAgICAgICAgICAgICBfdm0uc2hvcnRjdXRzXG4gICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX3NpZGViYXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLnNob3J0Y3V0cywgZnVuY3Rpb24oc2hvcnRjdXQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX3Nob3J0Y3V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uaGFuZGxlU2hvcnRjdXRDbGljayhzaG9ydGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhzaG9ydGN1dC50ZXh0KSldXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtcGlja2VyLXBhbmVsX19ib2R5XCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5zaG93VGltZVxuICAgICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiZWwtZGF0ZS1yYW5nZS1waWNrZXJfX3RpbWUtaGVhZGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiZWwtZGF0ZS1yYW5nZS1waWNrZXJfX2VkaXRvcnMtd3JhcFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsLWRhdGUtcmFuZ2UtcGlja2VyX190aW1lLXBpY2tlci13cmFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZWwtaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogXCJtaW5JbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtcmFuZ2UtcGlja2VyX19lZGl0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IF92bS5yYW5nZVN0YXRlLnNlbGVjdGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdm0udChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC5kYXRlcGlja2VyLnN0YXJ0RGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5taW5WaXNpYmxlRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5oYW5kbGVEYXRlSW5wdXQodmFsLCBcIm1pblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uaGFuZGxlRGF0ZUNoYW5nZSh2YWwsIFwibWluXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImNsaWNrb3V0c2lkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LWNsaWNrb3V0c2lkZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5oYW5kbGVNaW5UaW1lQ2xvc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImhhbmRsZU1pblRpbWVDbG9zZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsLWRhdGUtcmFuZ2UtcGlja2VyX190aW1lLXBpY2tlci13cmFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZWwtaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtcmFuZ2UtcGlja2VyX19lZGl0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IF92bS5yYW5nZVN0YXRlLnNlbGVjdGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdm0udChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC5kYXRlcGlja2VyLnN0YXJ0VGltZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5taW5WaXNpYmxlVGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLm1pblRpbWVQaWNrZXJWaXNpYmxlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5oYW5kbGVUaW1lSW5wdXQodmFsLCBcIm1pblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uaGFuZGxlVGltZUNoYW5nZSh2YWwsIFwibWluXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJ0aW1lLXBpY2tlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBcIm1pblRpbWVQaWNrZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aW1lLWFycm93LWNvbnRyb2xcIjogX3ZtLmFycm93Q29udHJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IF92bS5taW5UaW1lUGlja2VyVmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2s6IF92bS5oYW5kbGVNaW5UaW1lUGljayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uJHJlZnMubWluVGltZVBpY2tlci5mb3JtYXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS50aW1lRm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJlbC1pY29uLWFycm93LXJpZ2h0XCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtZGF0ZS1yYW5nZS1waWNrZXJfX2VkaXRvcnMtd3JhcCBpcy1yaWdodFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsLWRhdGUtcmFuZ2UtcGlja2VyX190aW1lLXBpY2tlci13cmFwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiZWwtaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtcmFuZ2UtcGlja2VyX19lZGl0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogXCJzbWFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IF92bS5yYW5nZVN0YXRlLnNlbGVjdGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdm0udChcImVsLmRhdGVwaWNrZXIuZW5kRGF0ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubWF4VmlzaWJsZURhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkb25seTogIV92bS5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmhhbmRsZURhdGVJbnB1dCh2YWwsIFwibWF4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5oYW5kbGVEYXRlQ2hhbmdlKHZhbCwgXCJtYXhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xpY2tvdXRzaWRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtY2xpY2tvdXRzaWRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmhhbmRsZU1heFRpbWVDbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiaGFuZGxlTWF4VGltZUNsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtZGF0ZS1yYW5nZS1waWNrZXJfX3RpbWUtcGlja2VyLXdyYXBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJlbC1pbnB1dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtZGF0ZS1yYW5nZS1waWNrZXJfX2VkaXRvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogX3ZtLnJhbmdlU3RhdGUuc2VsZWN0aW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF92bS50KFwiZWwuZGF0ZXBpY2tlci5lbmRUaW1lXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5tYXhWaXNpYmxlVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRvbmx5OiAhX3ZtLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF92bS5tYXhUaW1lUGlja2VyVmlzaWJsZSA9IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmhhbmRsZVRpbWVJbnB1dCh2YWwsIFwibWF4XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92bS5oYW5kbGVUaW1lQ2hhbmdlKHZhbCwgXCJtYXhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcInRpbWUtcGlja2VyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IFwibWF4VGltZVBpY2tlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRpbWUtYXJyb3ctY29udHJvbFwiOiBfdm0uYXJyb3dDb250cm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogX3ZtLm1heFRpbWVQaWNrZXJWaXNpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGljazogX3ZtLmhhbmRsZU1heFRpbWVQaWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRlZDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS4kcmVmcy5tYXhUaW1lUGlja2VyLmZvcm1hdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnRpbWVGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZWwtcGlja2VyLXBhbmVsX19jb250ZW50IGVsLWRhdGUtcmFuZ2UtcGlja2VyX19jb250ZW50IGlzLWxlZnRcIlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJlbC1kYXRlLXJhbmdlLXBpY2tlcl9faGVhZGVyXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsLXBpY2tlci1wYW5lbF9faWNvbi1idG4gZWwtaWNvbi1kLWFycm93LWxlZnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ubGVmdFByZXZZZWFyIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2ljb24tYnRuIGVsLWljb24tYXJyb3ctbGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5sZWZ0UHJldk1vbnRoIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0udW5saW5rUGFuZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtcGlja2VyLXBhbmVsX19pY29uLWJ0biBlbC1pY29uLWQtYXJyb3ctcmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBcImlzLWRpc2FibGVkXCI6ICFfdm0uZW5hYmxlWWVhckFycm93IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogIV92bS5lbmFibGVZZWFyQXJyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ubGVmdE5leHRZZWFyIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLnVubGlua1BhbmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBfYyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsLXBpY2tlci1wYW5lbF9faWNvbi1idG4gZWwtaWNvbi1hcnJvdy1yaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiB7IFwiaXMtZGlzYWJsZWRcIjogIV92bS5lbmFibGVNb250aEFycm93IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogIV92bS5lbmFibGVNb250aEFycm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLmxlZnROZXh0TW9udGggfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCBbX3ZtLl92KF92bS5fcyhfdm0ubGVmdExhYmVsKSldKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJkYXRlLXRhYmxlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzZWxlY3Rpb24tbW9kZVwiOiBcInJhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlOiBfdm0ubGVmdERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogX3ZtLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWluLWRhdGVcIjogX3ZtLm1pbkRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1heC1kYXRlXCI6IF92bS5tYXhEYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyYW5nZS1zdGF0ZVwiOiBfdm0ucmFuZ2VTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWQtZGF0ZVwiOiBfdm0uZGlzYWJsZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjZWxsLWNsYXNzLW5hbWVcIjogX3ZtLmNlbGxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpcnN0LWRheS1vZi13ZWVrXCI6IF92bS5maXJzdERheU9mV2Vla1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXJhbmdlOiBfdm0uaGFuZGxlQ2hhbmdlUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrOiBfdm0uaGFuZGxlUmFuZ2VQaWNrXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2NvbnRlbnQgZWwtZGF0ZS1yYW5nZS1waWNrZXJfX2NvbnRlbnQgaXMtcmlnaHRcIlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJlbC1kYXRlLXJhbmdlLXBpY2tlcl9faGVhZGVyXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS51bmxpbmtQYW5lbHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2ljb24tYnRuIGVsLWljb24tZC1hcnJvdy1sZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgXCJpcy1kaXNhYmxlZFwiOiAhX3ZtLmVuYWJsZVllYXJBcnJvdyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICFfdm0uZW5hYmxlWWVhckFycm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnJpZ2h0UHJldlllYXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0udW5saW5rUGFuZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtcGlja2VyLXBhbmVsX19pY29uLWJ0biBlbC1pY29uLWFycm93LWxlZnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBcImlzLWRpc2FibGVkXCI6ICFfdm0uZW5hYmxlTW9udGhBcnJvdyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICFfdm0uZW5hYmxlTW9udGhBcnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5yaWdodFByZXZNb250aCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsLXBpY2tlci1wYW5lbF9faWNvbi1idG4gZWwtaWNvbi1kLWFycm93LXJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnJpZ2h0TmV4dFllYXIgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImVsLXBpY2tlci1wYW5lbF9faWNvbi1idG4gZWwtaWNvbi1hcnJvdy1yaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5yaWdodE5leHRNb250aCB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgW192bS5fdihfdm0uX3MoX3ZtLnJpZ2h0TGFiZWwpKV0pXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfYyhcImRhdGUtdGFibGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlbGVjdGlvbi1tb2RlXCI6IFwicmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IF92bS5yaWdodERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogX3ZtLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWluLWRhdGVcIjogX3ZtLm1pbkRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1heC1kYXRlXCI6IF92bS5tYXhEYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyYW5nZS1zdGF0ZVwiOiBfdm0ucmFuZ2VTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWQtZGF0ZVwiOiBfdm0uZGlzYWJsZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjZWxsLWNsYXNzLW5hbWVcIjogX3ZtLmNlbGxDbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpcnN0LWRheS1vZi13ZWVrXCI6IF92bS5maXJzdERheU9mV2Vla1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXJhbmdlOiBfdm0uaGFuZGxlQ2hhbmdlUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrOiBfdm0uaGFuZGxlUmFuZ2VQaWNrXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMlxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLnNob3dUaW1lXG4gICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX2Zvb3RlclwiIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwiZWwtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX2xpbmstYnRuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgc2l6ZTogXCJtaW5pXCIsIHR5cGU6IFwidGV4dFwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5oYW5kbGVDbGVhciB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLnQoXCJlbC5kYXRlcGlja2VyLmNsZWFyXCIpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJlbC1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImVsLXBpY2tlci1wYW5lbF9fbGluay1idG5cIixcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhaW46IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBcIm1pbmlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0uYnRuRGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5oYW5kbGVDb25maXJtKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udChcImVsLmRhdGVwaWNrZXIuY29uZmlybVwiKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF1cbiAgKVxufVxudmFyIGRhdGVfcmFuZ2V2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yNjUyODQ5YV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuZGF0ZV9yYW5nZXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzI2NTI4NDlhX3JlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BhbmVsL2RhdGUtcmFuZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI2NTI4NDlhJlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvZGF0ZS1yYW5nZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cblxuXG5cblxuXG5cblxuXG52YXIgZGF0ZV9yYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NhbGNEZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiBjYWxjRGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpKSB7XG4gICAgcmV0dXJuIFtuZXcgRGF0ZShkZWZhdWx0VmFsdWVbMF0pLCBuZXcgRGF0ZShkZWZhdWx0VmFsdWVbMV0pXTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gW25ldyBEYXRlKGRlZmF1bHRWYWx1ZSksIE9iamVjdChkYXRlX3V0aWxfW1wibmV4dERhdGVcIl0pKG5ldyBEYXRlKGRlZmF1bHRWYWx1ZSksIDEpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW25ldyBEYXRlKCksIE9iamVjdChkYXRlX3V0aWxfW1wibmV4dERhdGVcIl0pKG5ldyBEYXRlKCksIDEpXTtcbiAgfVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGF0ZV9yYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG1peGluczogW2xvY2FsZV9kZWZhdWx0LmFdLFxuXG4gIGRpcmVjdGl2ZXM6IHsgQ2xpY2tvdXRzaWRlOiBjbGlja291dHNpZGVfZGVmYXVsdC5hIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBidG5EaXNhYmxlZDogZnVuY3Rpb24gYnRuRGlzYWJsZWQoKSB7XG4gICAgICByZXR1cm4gISh0aGlzLm1pbkRhdGUgJiYgdGhpcy5tYXhEYXRlICYmICF0aGlzLnNlbGVjdGluZyAmJiB0aGlzLmlzVmFsaWRWYWx1ZShbdGhpcy5taW5EYXRlLCB0aGlzLm1heERhdGVdKSk7XG4gICAgfSxcbiAgICBsZWZ0TGFiZWw6IGZ1bmN0aW9uIGxlZnRMYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlZnREYXRlLmdldEZ1bGxZZWFyKCkgKyAnICcgKyB0aGlzLnQoJ2VsLmRhdGVwaWNrZXIueWVhcicpICsgJyAnICsgdGhpcy50KCdlbC5kYXRlcGlja2VyLm1vbnRoJyArICh0aGlzLmxlZnREYXRlLmdldE1vbnRoKCkgKyAxKSk7XG4gICAgfSxcbiAgICByaWdodExhYmVsOiBmdW5jdGlvbiByaWdodExhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmlnaHREYXRlLmdldEZ1bGxZZWFyKCkgKyAnICcgKyB0aGlzLnQoJ2VsLmRhdGVwaWNrZXIueWVhcicpICsgJyAnICsgdGhpcy50KCdlbC5kYXRlcGlja2VyLm1vbnRoJyArICh0aGlzLnJpZ2h0RGF0ZS5nZXRNb250aCgpICsgMSkpO1xuICAgIH0sXG4gICAgbGVmdFllYXI6IGZ1bmN0aW9uIGxlZnRZZWFyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVmdERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB9LFxuICAgIGxlZnRNb250aDogZnVuY3Rpb24gbGVmdE1vbnRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVmdERhdGUuZ2V0TW9udGgoKTtcbiAgICB9LFxuICAgIGxlZnRNb250aERhdGU6IGZ1bmN0aW9uIGxlZnRNb250aERhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZWZ0RGF0ZS5nZXREYXRlKCk7XG4gICAgfSxcbiAgICByaWdodFllYXI6IGZ1bmN0aW9uIHJpZ2h0WWVhcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJpZ2h0RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIH0sXG4gICAgcmlnaHRNb250aDogZnVuY3Rpb24gcmlnaHRNb250aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJpZ2h0RGF0ZS5nZXRNb250aCgpO1xuICAgIH0sXG4gICAgcmlnaHRNb250aERhdGU6IGZ1bmN0aW9uIHJpZ2h0TW9udGhEYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmlnaHREYXRlLmdldERhdGUoKTtcbiAgICB9LFxuICAgIG1pblZpc2libGVEYXRlOiBmdW5jdGlvbiBtaW5WaXNpYmxlRGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmRhdGVVc2VySW5wdXQubWluICE9PSBudWxsKSByZXR1cm4gdGhpcy5kYXRlVXNlcklucHV0Lm1pbjtcbiAgICAgIGlmICh0aGlzLm1pbkRhdGUpIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImZvcm1hdERhdGVcIl0pKHRoaXMubWluRGF0ZSwgdGhpcy5kYXRlRm9ybWF0KTtcbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuICAgIG1heFZpc2libGVEYXRlOiBmdW5jdGlvbiBtYXhWaXNpYmxlRGF0ZSgpIHtcbiAgICAgIGlmICh0aGlzLmRhdGVVc2VySW5wdXQubWF4ICE9PSBudWxsKSByZXR1cm4gdGhpcy5kYXRlVXNlcklucHV0Lm1heDtcbiAgICAgIGlmICh0aGlzLm1heERhdGUgfHwgdGhpcy5taW5EYXRlKSByZXR1cm4gT2JqZWN0KGRhdGVfdXRpbF9bXCJmb3JtYXREYXRlXCJdKSh0aGlzLm1heERhdGUgfHwgdGhpcy5taW5EYXRlLCB0aGlzLmRhdGVGb3JtYXQpO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG4gICAgbWluVmlzaWJsZVRpbWU6IGZ1bmN0aW9uIG1pblZpc2libGVUaW1lKCkge1xuICAgICAgaWYgKHRoaXMudGltZVVzZXJJbnB1dC5taW4gIT09IG51bGwpIHJldHVybiB0aGlzLnRpbWVVc2VySW5wdXQubWluO1xuICAgICAgaWYgKHRoaXMubWluRGF0ZSkgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wiZm9ybWF0RGF0ZVwiXSkodGhpcy5taW5EYXRlLCB0aGlzLnRpbWVGb3JtYXQpO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG4gICAgbWF4VmlzaWJsZVRpbWU6IGZ1bmN0aW9uIG1heFZpc2libGVUaW1lKCkge1xuICAgICAgaWYgKHRoaXMudGltZVVzZXJJbnB1dC5tYXggIT09IG51bGwpIHJldHVybiB0aGlzLnRpbWVVc2VySW5wdXQubWF4O1xuICAgICAgaWYgKHRoaXMubWF4RGF0ZSB8fCB0aGlzLm1pbkRhdGUpIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImZvcm1hdERhdGVcIl0pKHRoaXMubWF4RGF0ZSB8fCB0aGlzLm1pbkRhdGUsIHRoaXMudGltZUZvcm1hdCk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSxcbiAgICB0aW1lRm9ybWF0OiBmdW5jdGlvbiB0aW1lRm9ybWF0KCkge1xuICAgICAgaWYgKHRoaXMuZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QoZGF0ZV91dGlsX1tcImV4dHJhY3RUaW1lRm9ybWF0XCJdKSh0aGlzLmZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0hIOm1tOnNzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGVGb3JtYXQ6IGZ1bmN0aW9uIGRhdGVGb3JtYXQoKSB7XG4gICAgICBpZiAodGhpcy5mb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdChkYXRlX3V0aWxfW1wiZXh0cmFjdERhdGVGb3JtYXRcIl0pKHRoaXMuZm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAneXl5eS1NTS1kZCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmFibGVNb250aEFycm93OiBmdW5jdGlvbiBlbmFibGVNb250aEFycm93KCkge1xuICAgICAgdmFyIG5leHRNb250aCA9ICh0aGlzLmxlZnRNb250aCArIDEpICUgMTI7XG4gICAgICB2YXIgeWVhck9mZnNldCA9IHRoaXMubGVmdE1vbnRoICsgMSA+PSAxMiA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHRoaXMudW5saW5rUGFuZWxzICYmIG5ldyBEYXRlKHRoaXMubGVmdFllYXIgKyB5ZWFyT2Zmc2V0LCBuZXh0TW9udGgpIDwgbmV3IERhdGUodGhpcy5yaWdodFllYXIsIHRoaXMucmlnaHRNb250aCk7XG4gICAgfSxcbiAgICBlbmFibGVZZWFyQXJyb3c6IGZ1bmN0aW9uIGVuYWJsZVllYXJBcnJvdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnVubGlua1BhbmVscyAmJiB0aGlzLnJpZ2h0WWVhciAqIDEyICsgdGhpcy5yaWdodE1vbnRoIC0gKHRoaXMubGVmdFllYXIgKiAxMiArIHRoaXMubGVmdE1vbnRoICsgMSkgPj0gMTI7XG4gICAgfVxuICB9LFxuXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcHBlckNsYXNzOiAnJyxcbiAgICAgIHZhbHVlOiBbXSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCxcbiAgICAgIGRlZmF1bHRUaW1lOiBudWxsLFxuICAgICAgbWluRGF0ZTogJycsXG4gICAgICBtYXhEYXRlOiAnJyxcbiAgICAgIGxlZnREYXRlOiBuZXcgRGF0ZSgpLFxuICAgICAgcmlnaHREYXRlOiBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRNb250aFwiXSkobmV3IERhdGUoKSksXG4gICAgICByYW5nZVN0YXRlOiB7XG4gICAgICAgIGVuZERhdGU6IG51bGwsXG4gICAgICAgIHNlbGVjdGluZzogZmFsc2UsXG4gICAgICAgIHJvdzogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9LFxuICAgICAgc2hvd1RpbWU6IGZhbHNlLFxuICAgICAgc2hvcnRjdXRzOiAnJyxcbiAgICAgIHZpc2libGU6ICcnLFxuICAgICAgZGlzYWJsZWREYXRlOiAnJyxcbiAgICAgIGNlbGxDbGFzc05hbWU6ICcnLFxuICAgICAgZmlyc3REYXlPZldlZWs6IDcsXG4gICAgICBtaW5UaW1lUGlja2VyVmlzaWJsZTogZmFsc2UsXG4gICAgICBtYXhUaW1lUGlja2VyVmlzaWJsZTogZmFsc2UsXG4gICAgICBmb3JtYXQ6ICcnLFxuICAgICAgYXJyb3dDb250cm9sOiBmYWxzZSxcbiAgICAgIHVubGlua1BhbmVsczogZmFsc2UsXG4gICAgICBkYXRlVXNlcklucHV0OiB7XG4gICAgICAgIG1pbjogbnVsbCxcbiAgICAgICAgbWF4OiBudWxsXG4gICAgICB9LFxuICAgICAgdGltZVVzZXJJbnB1dDoge1xuICAgICAgICBtaW46IG51bGwsXG4gICAgICAgIG1heDogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIG1pbkRhdGU6IGZ1bmN0aW9uIG1pbkRhdGUodmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRhdGVVc2VySW5wdXQubWluID0gbnVsbDtcbiAgICAgIHRoaXMudGltZVVzZXJJbnB1dC5taW4gPSBudWxsO1xuICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuJHJlZnMubWF4VGltZVBpY2tlciAmJiBfdGhpcy5tYXhEYXRlICYmIF90aGlzLm1heERhdGUgPCBfdGhpcy5taW5EYXRlKSB7XG4gICAgICAgICAgdmFyIGZvcm1hdCA9ICdISDptbTpzcyc7XG4gICAgICAgICAgX3RoaXMuJHJlZnMubWF4VGltZVBpY2tlci5zZWxlY3RhYmxlUmFuZ2UgPSBbW09iamVjdChkYXRlX3V0aWxfW1wicGFyc2VEYXRlXCJdKShPYmplY3QoZGF0ZV91dGlsX1tcImZvcm1hdERhdGVcIl0pKF90aGlzLm1pbkRhdGUsIGZvcm1hdCksIGZvcm1hdCksIE9iamVjdChkYXRlX3V0aWxfW1wicGFyc2VEYXRlXCJdKSgnMjM6NTk6NTknLCBmb3JtYXQpXV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHZhbCAmJiB0aGlzLiRyZWZzLm1pblRpbWVQaWNrZXIpIHtcbiAgICAgICAgdGhpcy4kcmVmcy5taW5UaW1lUGlja2VyLmRhdGUgPSB2YWw7XG4gICAgICAgIHRoaXMuJHJlZnMubWluVGltZVBpY2tlci52YWx1ZSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heERhdGU6IGZ1bmN0aW9uIG1heERhdGUodmFsKSB7XG4gICAgICB0aGlzLmRhdGVVc2VySW5wdXQubWF4ID0gbnVsbDtcbiAgICAgIHRoaXMudGltZVVzZXJJbnB1dC5tYXggPSBudWxsO1xuICAgICAgaWYgKHZhbCAmJiB0aGlzLiRyZWZzLm1heFRpbWVQaWNrZXIpIHtcbiAgICAgICAgdGhpcy4kcmVmcy5tYXhUaW1lUGlja2VyLmRhdGUgPSB2YWw7XG4gICAgICAgIHRoaXMuJHJlZnMubWF4VGltZVBpY2tlci52YWx1ZSA9IHZhbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pblRpbWVQaWNrZXJWaXNpYmxlOiBmdW5jdGlvbiBtaW5UaW1lUGlja2VyVmlzaWJsZSh2YWwpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuJHJlZnMubWluVGltZVBpY2tlci5kYXRlID0gX3RoaXMyLm1pbkRhdGU7XG4gICAgICAgICAgX3RoaXMyLiRyZWZzLm1pblRpbWVQaWNrZXIudmFsdWUgPSBfdGhpczIubWluRGF0ZTtcbiAgICAgICAgICBfdGhpczIuJHJlZnMubWluVGltZVBpY2tlci5hZGp1c3RTcGlubmVycygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heFRpbWVQaWNrZXJWaXNpYmxlOiBmdW5jdGlvbiBtYXhUaW1lUGlja2VyVmlzaWJsZSh2YWwpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuJHJlZnMubWF4VGltZVBpY2tlci5kYXRlID0gX3RoaXMzLm1heERhdGU7XG4gICAgICAgICAgX3RoaXMzLiRyZWZzLm1heFRpbWVQaWNrZXIudmFsdWUgPSBfdGhpczMubWF4RGF0ZTtcbiAgICAgICAgICBfdGhpczMuJHJlZnMubWF4VGltZVBpY2tlci5hZGp1c3RTcGlubmVycygpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWwpIHtcbiAgICAgIGlmICghbmV3VmFsKSB7XG4gICAgICAgIHRoaXMubWluRGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV3VmFsKSkge1xuICAgICAgICB0aGlzLm1pbkRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkobmV3VmFsWzBdKSA/IG5ldyBEYXRlKG5ld1ZhbFswXSkgOiBudWxsO1xuICAgICAgICB0aGlzLm1heERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkobmV3VmFsWzFdKSA/IG5ldyBEYXRlKG5ld1ZhbFsxXSkgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5taW5EYXRlKSB7XG4gICAgICAgICAgdGhpcy5sZWZ0RGF0ZSA9IHRoaXMubWluRGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy51bmxpbmtQYW5lbHMgJiYgdGhpcy5tYXhEYXRlKSB7XG4gICAgICAgICAgICB2YXIgbWluRGF0ZVllYXIgPSB0aGlzLm1pbkRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIHZhciBtaW5EYXRlTW9udGggPSB0aGlzLm1pbkRhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIHZhciBtYXhEYXRlWWVhciA9IHRoaXMubWF4RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdmFyIG1heERhdGVNb250aCA9IHRoaXMubWF4RGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgdGhpcy5yaWdodERhdGUgPSBtaW5EYXRlWWVhciA9PT0gbWF4RGF0ZVllYXIgJiYgbWluRGF0ZU1vbnRoID09PSBtYXhEYXRlTW9udGggPyBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRNb250aFwiXSkodGhpcy5tYXhEYXRlKSA6IHRoaXMubWF4RGF0ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yaWdodERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRNb250aFwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVmdERhdGUgPSBkYXRlX3JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfY2FsY0RlZmF1bHRWYWx1ZSh0aGlzLmRlZmF1bHRWYWx1ZSlbMF07XG4gICAgICAgICAgdGhpcy5yaWdodERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRNb250aFwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gZGVmYXVsdFZhbHVlKHZhbCkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHZhciBfY2FsY0RlZmF1bHRWYWx1ZSA9IGRhdGVfcmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jYWxjRGVmYXVsdFZhbHVlKHZhbCksXG4gICAgICAgICAgICBsZWZ0ID0gX2NhbGNEZWZhdWx0VmFsdWVbMF0sXG4gICAgICAgICAgICByaWdodCA9IF9jYWxjRGVmYXVsdFZhbHVlWzFdO1xuXG4gICAgICAgIHRoaXMubGVmdERhdGUgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IHZhbCAmJiB2YWxbMV0gJiYgdGhpcy51bmxpbmtQYW5lbHMgPyByaWdodCA6IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKSh0aGlzLmxlZnREYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZUNsZWFyOiBmdW5jdGlvbiBoYW5kbGVDbGVhcigpIHtcbiAgICAgIHRoaXMubWluRGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLm1heERhdGUgPSBudWxsO1xuICAgICAgdGhpcy5sZWZ0RGF0ZSA9IGRhdGVfcmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jYWxjRGVmYXVsdFZhbHVlKHRoaXMuZGVmYXVsdFZhbHVlKVswXTtcbiAgICAgIHRoaXMucmlnaHREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0TW9udGhcIl0pKHRoaXMubGVmdERhdGUpO1xuICAgICAgdGhpcy4kZW1pdCgncGljaycsIG51bGwpO1xuICAgIH0sXG4gICAgaGFuZGxlQ2hhbmdlUmFuZ2U6IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVJhbmdlKHZhbCkge1xuICAgICAgdGhpcy5taW5EYXRlID0gdmFsLm1pbkRhdGU7XG4gICAgICB0aGlzLm1heERhdGUgPSB2YWwubWF4RGF0ZTtcbiAgICAgIHRoaXMucmFuZ2VTdGF0ZSA9IHZhbC5yYW5nZVN0YXRlO1xuICAgIH0sXG4gICAgaGFuZGxlRGF0ZUlucHV0OiBmdW5jdGlvbiBoYW5kbGVEYXRlSW5wdXQodmFsdWUsIHR5cGUpIHtcbiAgICAgIHRoaXMuZGF0ZVVzZXJJbnB1dFt0eXBlXSA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5kYXRlRm9ybWF0Lmxlbmd0aCkgcmV0dXJuO1xuICAgICAgdmFyIHBhcnNlZFZhbHVlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwYXJzZURhdGVcIl0pKHZhbHVlLCB0aGlzLmRhdGVGb3JtYXQpO1xuXG4gICAgICBpZiAocGFyc2VkVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc2FibGVkRGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLmRpc2FibGVkRGF0ZShuZXcgRGF0ZShwYXJzZWRWYWx1ZSkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnbWluJykge1xuICAgICAgICAgIHRoaXMubWluRGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5RGF0ZVwiXSkodGhpcy5taW5EYXRlIHx8IG5ldyBEYXRlKCksIHBhcnNlZFZhbHVlLmdldEZ1bGxZZWFyKCksIHBhcnNlZFZhbHVlLmdldE1vbnRoKCksIHBhcnNlZFZhbHVlLmdldERhdGUoKSk7XG4gICAgICAgICAgdGhpcy5sZWZ0RGF0ZSA9IG5ldyBEYXRlKHBhcnNlZFZhbHVlKTtcbiAgICAgICAgICBpZiAoIXRoaXMudW5saW5rUGFuZWxzKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKSh0aGlzLmxlZnREYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYXhEYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJtb2RpZnlEYXRlXCJdKSh0aGlzLm1heERhdGUgfHwgbmV3IERhdGUoKSwgcGFyc2VkVmFsdWUuZ2V0RnVsbFllYXIoKSwgcGFyc2VkVmFsdWUuZ2V0TW9udGgoKSwgcGFyc2VkVmFsdWUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IG5ldyBEYXRlKHBhcnNlZFZhbHVlKTtcbiAgICAgICAgICBpZiAoIXRoaXMudW5saW5rUGFuZWxzKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwcmV2TW9udGhcIl0pKHBhcnNlZFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZURhdGVDaGFuZ2U6IGZ1bmN0aW9uIGhhbmRsZURhdGVDaGFuZ2UodmFsdWUsIHR5cGUpIHtcbiAgICAgIHZhciBwYXJzZWRWYWx1ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wicGFyc2VEYXRlXCJdKSh2YWx1ZSwgdGhpcy5kYXRlRm9ybWF0KTtcbiAgICAgIGlmIChwYXJzZWRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICB0aGlzLm1pbkRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeURhdGVcIl0pKHRoaXMubWluRGF0ZSwgcGFyc2VkVmFsdWUuZ2V0RnVsbFllYXIoKSwgcGFyc2VkVmFsdWUuZ2V0TW9udGgoKSwgcGFyc2VkVmFsdWUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICBpZiAodGhpcy5taW5EYXRlID4gdGhpcy5tYXhEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLm1heERhdGUgPSB0aGlzLm1pbkRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWF4RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5RGF0ZVwiXSkodGhpcy5tYXhEYXRlLCBwYXJzZWRWYWx1ZS5nZXRGdWxsWWVhcigpLCBwYXJzZWRWYWx1ZS5nZXRNb250aCgpLCBwYXJzZWRWYWx1ZS5nZXREYXRlKCkpO1xuICAgICAgICAgIGlmICh0aGlzLm1heERhdGUgPCB0aGlzLm1pbkRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMubWluRGF0ZSA9IHRoaXMubWF4RGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVRpbWVJbnB1dDogZnVuY3Rpb24gaGFuZGxlVGltZUlucHV0KHZhbHVlLCB0eXBlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy50aW1lVXNlcklucHV0W3R5cGVdID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLnRpbWVGb3JtYXQubGVuZ3RoKSByZXR1cm47XG4gICAgICB2YXIgcGFyc2VkVmFsdWUgPSBPYmplY3QoZGF0ZV91dGlsX1tcInBhcnNlRGF0ZVwiXSkodmFsdWUsIHRoaXMudGltZUZvcm1hdCk7XG5cbiAgICAgIGlmIChwYXJzZWRWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICB0aGlzLm1pbkRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeVRpbWVcIl0pKHRoaXMubWluRGF0ZSwgcGFyc2VkVmFsdWUuZ2V0SG91cnMoKSwgcGFyc2VkVmFsdWUuZ2V0TWludXRlcygpLCBwYXJzZWRWYWx1ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0LiRyZWZzLm1pblRpbWVQaWNrZXIuYWRqdXN0U3Bpbm5lcnMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1heERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm1vZGlmeVRpbWVcIl0pKHRoaXMubWF4RGF0ZSwgcGFyc2VkVmFsdWUuZ2V0SG91cnMoKSwgcGFyc2VkVmFsdWUuZ2V0TWludXRlcygpLCBwYXJzZWRWYWx1ZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM0LiRyZWZzLm1heFRpbWVQaWNrZXIuYWRqdXN0U3Bpbm5lcnMoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlVGltZUNoYW5nZTogZnVuY3Rpb24gaGFuZGxlVGltZUNoYW5nZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgdmFyIHBhcnNlZFZhbHVlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwYXJzZURhdGVcIl0pKHZhbHVlLCB0aGlzLnRpbWVGb3JtYXQpO1xuICAgICAgaWYgKHBhcnNlZFZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnbWluJykge1xuICAgICAgICAgIHRoaXMubWluRGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5VGltZVwiXSkodGhpcy5taW5EYXRlLCBwYXJzZWRWYWx1ZS5nZXRIb3VycygpLCBwYXJzZWRWYWx1ZS5nZXRNaW51dGVzKCksIHBhcnNlZFZhbHVlLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgaWYgKHRoaXMubWluRGF0ZSA+IHRoaXMubWF4RGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5tYXhEYXRlID0gdGhpcy5taW5EYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiRyZWZzLm1pblRpbWVQaWNrZXIudmFsdWUgPSB0aGlzLm1pbkRhdGU7XG4gICAgICAgICAgdGhpcy5taW5UaW1lUGlja2VyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWF4RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5VGltZVwiXSkodGhpcy5tYXhEYXRlLCBwYXJzZWRWYWx1ZS5nZXRIb3VycygpLCBwYXJzZWRWYWx1ZS5nZXRNaW51dGVzKCksIHBhcnNlZFZhbHVlLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgaWYgKHRoaXMubWF4RGF0ZSA8IHRoaXMubWluRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5taW5EYXRlID0gdGhpcy5tYXhEYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiRyZWZzLm1heFRpbWVQaWNrZXIudmFsdWUgPSB0aGlzLm1pbkRhdGU7XG4gICAgICAgICAgdGhpcy5tYXhUaW1lUGlja2VyVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVSYW5nZVBpY2s6IGZ1bmN0aW9uIGhhbmRsZVJhbmdlUGljayh2YWwpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xvc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIHZhciBkZWZhdWx0VGltZSA9IHRoaXMuZGVmYXVsdFRpbWUgfHwgW107XG4gICAgICB2YXIgbWluRGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5V2l0aFRpbWVTdHJpbmdcIl0pKHZhbC5taW5EYXRlLCBkZWZhdWx0VGltZVswXSk7XG4gICAgICB2YXIgbWF4RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibW9kaWZ5V2l0aFRpbWVTdHJpbmdcIl0pKHZhbC5tYXhEYXRlLCBkZWZhdWx0VGltZVsxXSk7XG5cbiAgICAgIGlmICh0aGlzLm1heERhdGUgPT09IG1heERhdGUgJiYgdGhpcy5taW5EYXRlID09PSBtaW5EYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25QaWNrICYmIHRoaXMub25QaWNrKHZhbCk7XG4gICAgICB0aGlzLm1heERhdGUgPSBtYXhEYXRlO1xuICAgICAgdGhpcy5taW5EYXRlID0gbWluRGF0ZTtcblxuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0VsZW1lRkUvZWxlbWVudC9pc3N1ZXMvNzUzOSwgc2hvdWxkIHJlbW92ZSB0aGlzIGJsb2NrIHdoZW4gd2UgZG9uJ3QgaGF2ZSB0byBjYXJlIGFib3V0IENocm9taXVtIDU1IC0gNTdcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUubWF4RGF0ZSA9IG1heERhdGU7XG4gICAgICAgIF90aGlzNS5taW5EYXRlID0gbWluRGF0ZTtcbiAgICAgIH0sIDEwKTtcbiAgICAgIGlmICghY2xvc2UgfHwgdGhpcy5zaG93VGltZSkgcmV0dXJuO1xuICAgICAgdGhpcy5oYW5kbGVDb25maXJtKCk7XG4gICAgfSxcbiAgICBoYW5kbGVTaG9ydGN1dENsaWNrOiBmdW5jdGlvbiBoYW5kbGVTaG9ydGN1dENsaWNrKHNob3J0Y3V0KSB7XG4gICAgICBpZiAoc2hvcnRjdXQub25DbGljaykge1xuICAgICAgICBzaG9ydGN1dC5vbkNsaWNrKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlTWluVGltZVBpY2s6IGZ1bmN0aW9uIGhhbmRsZU1pblRpbWVQaWNrKHZhbHVlLCB2aXNpYmxlLCBmaXJzdCkge1xuICAgICAgdGhpcy5taW5EYXRlID0gdGhpcy5taW5EYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5taW5EYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJtb2RpZnlUaW1lXCJdKSh0aGlzLm1pbkRhdGUsIHZhbHVlLmdldEhvdXJzKCksIHZhbHVlLmdldE1pbnV0ZXMoKSwgdmFsdWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLm1pblRpbWVQaWNrZXJWaXNpYmxlID0gdmlzaWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm1heERhdGUgfHwgdGhpcy5tYXhEYXRlICYmIHRoaXMubWF4RGF0ZS5nZXRUaW1lKCkgPCB0aGlzLm1pbkRhdGUuZ2V0VGltZSgpKSB7XG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IG5ldyBEYXRlKHRoaXMubWluRGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVNaW5UaW1lQ2xvc2U6IGZ1bmN0aW9uIGhhbmRsZU1pblRpbWVDbG9zZSgpIHtcbiAgICAgIHRoaXMubWluVGltZVBpY2tlclZpc2libGUgPSBmYWxzZTtcbiAgICB9LFxuICAgIGhhbmRsZU1heFRpbWVQaWNrOiBmdW5jdGlvbiBoYW5kbGVNYXhUaW1lUGljayh2YWx1ZSwgdmlzaWJsZSwgZmlyc3QpIHtcbiAgICAgIGlmICh0aGlzLm1heERhdGUgJiYgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJtb2RpZnlUaW1lXCJdKSh0aGlzLm1heERhdGUsIHZhbHVlLmdldEhvdXJzKCksIHZhbHVlLmdldE1pbnV0ZXMoKSwgdmFsdWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICB0aGlzLm1heFRpbWVQaWNrZXJWaXNpYmxlID0gdmlzaWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF4RGF0ZSAmJiB0aGlzLm1pbkRhdGUgJiYgdGhpcy5taW5EYXRlLmdldFRpbWUoKSA+IHRoaXMubWF4RGF0ZS5nZXRUaW1lKCkpIHtcbiAgICAgICAgdGhpcy5taW5EYXRlID0gbmV3IERhdGUodGhpcy5tYXhEYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZU1heFRpbWVDbG9zZTogZnVuY3Rpb24gaGFuZGxlTWF4VGltZUNsb3NlKCkge1xuICAgICAgdGhpcy5tYXhUaW1lUGlja2VyVmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sXG5cblxuICAgIC8vIGxlZnRQcmV2KiwgcmlnaHROZXh0KiBuZWVkIHRvIHRha2UgY2FyZSBvZiBgdW5saW5rUGFuZWxzYFxuICAgIGxlZnRQcmV2WWVhcjogZnVuY3Rpb24gbGVmdFByZXZZZWFyKCkge1xuICAgICAgdGhpcy5sZWZ0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wicHJldlllYXJcIl0pKHRoaXMubGVmdERhdGUpO1xuICAgICAgaWYgKCF0aGlzLnVubGlua1BhbmVscykge1xuICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKSh0aGlzLmxlZnREYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxlZnRQcmV2TW9udGg6IGZ1bmN0aW9uIGxlZnRQcmV2TW9udGgoKSB7XG4gICAgICB0aGlzLmxlZnREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwcmV2TW9udGhcIl0pKHRoaXMubGVmdERhdGUpO1xuICAgICAgaWYgKCF0aGlzLnVubGlua1BhbmVscykge1xuICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKSh0aGlzLmxlZnREYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJpZ2h0TmV4dFllYXI6IGZ1bmN0aW9uIHJpZ2h0TmV4dFllYXIoKSB7XG4gICAgICBpZiAoIXRoaXMudW5saW5rUGFuZWxzKSB7XG4gICAgICAgIHRoaXMubGVmdERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRZZWFyXCJdKSh0aGlzLmxlZnREYXRlKTtcbiAgICAgICAgdGhpcy5yaWdodERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRNb250aFwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dFllYXJcIl0pKHRoaXMucmlnaHREYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJpZ2h0TmV4dE1vbnRoOiBmdW5jdGlvbiByaWdodE5leHRNb250aCgpIHtcbiAgICAgIGlmICghdGhpcy51bmxpbmtQYW5lbHMpIHtcbiAgICAgICAgdGhpcy5sZWZ0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKSh0aGlzLmxlZnREYXRlKTtcbiAgICAgICAgdGhpcy5yaWdodERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRNb250aFwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKSh0aGlzLnJpZ2h0RGF0ZSk7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgLy8gbGVmdE5leHQqLCByaWdodFByZXYqIGFyZSBjYWxsZWQgd2hlbiBgdW5saW5rUGFuZWxzYCBpcyB0cnVlXG4gICAgbGVmdE5leHRZZWFyOiBmdW5jdGlvbiBsZWZ0TmV4dFllYXIoKSB7XG4gICAgICB0aGlzLmxlZnREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0WWVhclwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgfSxcbiAgICBsZWZ0TmV4dE1vbnRoOiBmdW5jdGlvbiBsZWZ0TmV4dE1vbnRoKCkge1xuICAgICAgdGhpcy5sZWZ0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKSh0aGlzLmxlZnREYXRlKTtcbiAgICB9LFxuICAgIHJpZ2h0UHJldlllYXI6IGZ1bmN0aW9uIHJpZ2h0UHJldlllYXIoKSB7XG4gICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wicHJldlllYXJcIl0pKHRoaXMucmlnaHREYXRlKTtcbiAgICB9LFxuICAgIHJpZ2h0UHJldk1vbnRoOiBmdW5jdGlvbiByaWdodFByZXZNb250aCgpIHtcbiAgICAgIHRoaXMucmlnaHREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwcmV2TW9udGhcIl0pKHRoaXMucmlnaHREYXRlKTtcbiAgICB9LFxuICAgIGhhbmRsZUNvbmZpcm06IGZ1bmN0aW9uIGhhbmRsZUNvbmZpcm0oKSB7XG4gICAgICB2YXIgdmlzaWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmlzVmFsaWRWYWx1ZShbdGhpcy5taW5EYXRlLCB0aGlzLm1heERhdGVdKSkge1xuICAgICAgICB0aGlzLiRlbWl0KCdwaWNrJywgW3RoaXMubWluRGF0ZSwgdGhpcy5tYXhEYXRlXSwgdmlzaWJsZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1ZhbGlkVmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWRWYWx1ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlICYmIHZhbHVlWzBdICYmIHZhbHVlWzFdICYmIE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlXCJdKSh2YWx1ZVswXSkgJiYgT2JqZWN0KGRhdGVfdXRpbF9bXCJpc0RhdGVcIl0pKHZhbHVlWzFdKSAmJiB2YWx1ZVswXS5nZXRUaW1lKCkgPD0gdmFsdWVbMV0uZ2V0VGltZSgpICYmICh0eXBlb2YgdGhpcy5kaXNhYmxlZERhdGUgPT09ICdmdW5jdGlvbicgPyAhdGhpcy5kaXNhYmxlZERhdGUodmFsdWVbMF0pICYmICF0aGlzLmRpc2FibGVkRGF0ZSh2YWx1ZVsxXSkgOiB0cnVlKTtcbiAgICB9LFxuICAgIHJlc2V0VmlldzogZnVuY3Rpb24gcmVzZXRWaWV3KCkge1xuICAgICAgLy8gTk9URTogdGhpcyBpcyBhIGhhY2sgdG8gcmVzZXQge21pbiwgbWF4fURhdGUgb24gcGlja2VyIG9wZW4uXG4gICAgICAvLyBUT0RPOiBjb3JyZWN0IHdheSBvZiBkb2luZyBzbyBpcyB0byByZWZhY3RvciB7bWluLCBtYXh9RGF0ZSB0byBiZSBkZXBlbmRlbnQgb24gdmFsdWUgYW5kIGludGVybmFsIHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgLy8gICAgICAgYW4gYWx0ZXJuYXRpdmUgd291bGQgYmUgcmVzZXRWaWV3IHdoZW5ldmVyIHBpY2tlciBiZWNvbWVzIHZpc2libGUsIHNob3VsZCBhbHNvIGludmVzdGlnYXRlIGRhdGUtcGFuZWwncyByZXNldFZpZXdcbiAgICAgIGlmICh0aGlzLm1pbkRhdGUgJiYgdGhpcy5tYXhEYXRlID09IG51bGwpIHRoaXMucmFuZ2VTdGF0ZS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubWluRGF0ZSA9IHRoaXMudmFsdWUgJiYgT2JqZWN0KGRhdGVfdXRpbF9bXCJpc0RhdGVcIl0pKHRoaXMudmFsdWVbMF0pID8gbmV3IERhdGUodGhpcy52YWx1ZVswXSkgOiBudWxsO1xuICAgICAgdGhpcy5tYXhEYXRlID0gdGhpcy52YWx1ZSAmJiBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkodGhpcy52YWx1ZVswXSkgPyBuZXcgRGF0ZSh0aGlzLnZhbHVlWzFdKSA6IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHsgVGltZVBpY2tlcjogcGFuZWxfdGltZVtcImFcIiAvKiBkZWZhdWx0ICovXSwgRGF0ZVRhYmxlOiBkYXRlX3RhYmxlLCBFbElucHV0OiBpbnB1dF9kZWZhdWx0LmEsIEVsQnV0dG9uOiBidXR0b25fZGVmYXVsdC5hIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvZGF0ZS1yYW5nZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFuZWxfZGF0ZV9yYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChkYXRlX3JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC9kYXRlLXJhbmdlLnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGRhdGVfcmFuZ2VfY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBwYW5lbF9kYXRlX3JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBkYXRlX3JhbmdldnVlX3R5cGVfdGVtcGxhdGVfaWRfMjY1Mjg0OWFfcmVuZGVyLFxuICBkYXRlX3JhbmdldnVlX3R5cGVfdGVtcGxhdGVfaWRfMjY1Mjg0OWFfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBkYXRlX3JhbmdlX2FwaTsgfVxuZGF0ZV9yYW5nZV9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInBhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC9kYXRlLXJhbmdlLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkYXRlX3JhbmdlID0gKGRhdGVfcmFuZ2VfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvbW9udGgtcmFuZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWYyNjQ1ZmI4JlxudmFyIG1vbnRoX3JhbmdldnVlX3R5cGVfdGVtcGxhdGVfaWRfZjI2NDVmYjhfcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwidHJhbnNpdGlvblwiLFxuICAgIHtcbiAgICAgIGF0dHJzOiB7IG5hbWU6IFwiZWwtem9vbS1pbi10b3BcIiB9LFxuICAgICAgb246IHtcbiAgICAgICAgXCJhZnRlci1sZWF2ZVwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICBfdm0uJGVtaXQoXCJkb2Rlc3Ryb3lcIilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuICAgICAgICAgICAgICB2YWx1ZTogX3ZtLnZpc2libGUsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IFwidmlzaWJsZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWwgZWwtZGF0ZS1yYW5nZS1waWNrZXIgZWwtcG9wcGVyXCIsXG4gICAgICAgICAgY2xhc3M6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgXCJoYXMtc2lkZWJhclwiOiBfdm0uJHNsb3RzLnNpZGViYXIgfHwgX3ZtLnNob3J0Y3V0c1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF92bS5wb3BwZXJDbGFzc1xuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiZWwtcGlja2VyLXBhbmVsX19ib2R5LXdyYXBwZXJcIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uX3QoXCJzaWRlYmFyXCIpLFxuICAgICAgICAgICAgICBfdm0uc2hvcnRjdXRzXG4gICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX3NpZGViYXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLnNob3J0Y3V0cywgZnVuY3Rpb24oc2hvcnRjdXQsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJlbC1waWNrZXItcGFuZWxfX3Nob3J0Y3V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uaGFuZGxlU2hvcnRjdXRDbGljayhzaG9ydGN1dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhzaG9ydGN1dC50ZXh0KSldXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZWwtcGlja2VyLXBhbmVsX19ib2R5XCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2NvbnRlbnQgZWwtZGF0ZS1yYW5nZS1waWNrZXJfX2NvbnRlbnQgaXMtbGVmdFwiXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImVsLWRhdGUtcmFuZ2UtcGlja2VyX19oZWFkZXJcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZWwtcGlja2VyLXBhbmVsX19pY29uLWJ0biBlbC1pY29uLWQtYXJyb3ctbGVmdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5sZWZ0UHJldlllYXIgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS51bmxpbmtQYW5lbHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2ljb24tYnRuIGVsLWljb24tZC1hcnJvdy1yaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiB7IFwiaXMtZGlzYWJsZWRcIjogIV92bS5lbmFibGVZZWFyQXJyb3cgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiAhX3ZtLmVuYWJsZVllYXJBcnJvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5sZWZ0TmV4dFllYXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCBbX3ZtLl92KF92bS5fcyhfdm0ubGVmdExhYmVsKSldKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJtb250aC10YWJsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2VsZWN0aW9uLW1vZGVcIjogXCJyYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogX3ZtLmxlZnREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJkZWZhdWx0LXZhbHVlXCI6IF92bS5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1pbi1kYXRlXCI6IF92bS5taW5EYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtZGF0ZVwiOiBfdm0ubWF4RGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmFuZ2Utc3RhdGVcIjogX3ZtLnJhbmdlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRpc2FibGVkLWRhdGVcIjogX3ZtLmRpc2FibGVkRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXJhbmdlOiBfdm0uaGFuZGxlQ2hhbmdlUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrOiBfdm0uaGFuZGxlUmFuZ2VQaWNrXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2NvbnRlbnQgZWwtZGF0ZS1yYW5nZS1waWNrZXJfX2NvbnRlbnQgaXMtcmlnaHRcIlxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJlbC1kYXRlLXJhbmdlLXBpY2tlcl9faGVhZGVyXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS51bmxpbmtQYW5lbHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2ljb24tYnRuIGVsLWljb24tZC1hcnJvdy1sZWZ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgXCJpcy1kaXNhYmxlZFwiOiAhX3ZtLmVuYWJsZVllYXJBcnJvdyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICFfdm0uZW5hYmxlWWVhckFycm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnJpZ2h0UHJldlllYXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbC1waWNrZXItcGFuZWxfX2ljb24tYnRuIGVsLWljb24tZC1hcnJvdy1yaWdodFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJidXR0b25cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5yaWdodE5leHRZZWFyIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCBbX3ZtLl92KF92bS5fcyhfdm0ucmlnaHRMYWJlbCkpXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwibW9udGgtdGFibGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlbGVjdGlvbi1tb2RlXCI6IFwicmFuZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IF92bS5yaWdodERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRlZmF1bHQtdmFsdWVcIjogX3ZtLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWluLWRhdGVcIjogX3ZtLm1pbkRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1heC1kYXRlXCI6IF92bS5tYXhEYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJyYW5nZS1zdGF0ZVwiOiBfdm0ucmFuZ2VTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzYWJsZWQtZGF0ZVwiOiBfdm0uZGlzYWJsZWREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcmFuZ2U6IF92bS5oYW5kbGVDaGFuZ2VSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2s6IF92bS5oYW5kbGVSYW5nZVBpY2tcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICApXG4gICAgXVxuICApXG59XG52YXIgbW9udGhfcmFuZ2V2dWVfdHlwZV90ZW1wbGF0ZV9pZF9mMjY0NWZiOF9zdGF0aWNSZW5kZXJGbnMgPSBbXVxubW9udGhfcmFuZ2V2dWVfdHlwZV90ZW1wbGF0ZV9pZF9mMjY0NWZiOF9yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC9tb250aC1yYW5nZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZjI2NDVmYjgmXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC9tb250aC1yYW5nZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuXG5cbnZhciBtb250aF9yYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NhbGNEZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiBjYWxjRGVmYXVsdFZhbHVlKGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpKSB7XG4gICAgcmV0dXJuIFtuZXcgRGF0ZShkZWZhdWx0VmFsdWVbMF0pLCBuZXcgRGF0ZShkZWZhdWx0VmFsdWVbMV0pXTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gW25ldyBEYXRlKGRlZmF1bHRWYWx1ZSksIE9iamVjdChkYXRlX3V0aWxfW1wibmV4dE1vbnRoXCJdKShuZXcgRGF0ZShkZWZhdWx0VmFsdWUpKV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtuZXcgRGF0ZSgpLCBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRNb250aFwiXSkobmV3IERhdGUoKSldO1xuICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbW9udGhfcmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBtaXhpbnM6IFtsb2NhbGVfZGVmYXVsdC5hXSxcblxuICBkaXJlY3RpdmVzOiB7IENsaWNrb3V0c2lkZTogY2xpY2tvdXRzaWRlX2RlZmF1bHQuYSB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgYnRuRGlzYWJsZWQ6IGZ1bmN0aW9uIGJ0bkRpc2FibGVkKCkge1xuICAgICAgcmV0dXJuICEodGhpcy5taW5EYXRlICYmIHRoaXMubWF4RGF0ZSAmJiAhdGhpcy5zZWxlY3RpbmcgJiYgdGhpcy5pc1ZhbGlkVmFsdWUoW3RoaXMubWluRGF0ZSwgdGhpcy5tYXhEYXRlXSkpO1xuICAgIH0sXG4gICAgbGVmdExhYmVsOiBmdW5jdGlvbiBsZWZ0TGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZWZ0RGF0ZS5nZXRGdWxsWWVhcigpICsgJyAnICsgdGhpcy50KCdlbC5kYXRlcGlja2VyLnllYXInKTtcbiAgICB9LFxuICAgIHJpZ2h0TGFiZWw6IGZ1bmN0aW9uIHJpZ2h0TGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodERhdGUuZ2V0RnVsbFllYXIoKSArICcgJyArIHRoaXMudCgnZWwuZGF0ZXBpY2tlci55ZWFyJyk7XG4gICAgfSxcbiAgICBsZWZ0WWVhcjogZnVuY3Rpb24gbGVmdFllYXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZWZ0RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIH0sXG4gICAgcmlnaHRZZWFyOiBmdW5jdGlvbiByaWdodFllYXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gdGhpcy5sZWZ0RGF0ZS5nZXRGdWxsWWVhcigpID8gdGhpcy5sZWZ0RGF0ZS5nZXRGdWxsWWVhcigpICsgMSA6IHRoaXMucmlnaHREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgfSxcbiAgICBlbmFibGVZZWFyQXJyb3c6IGZ1bmN0aW9uIGVuYWJsZVllYXJBcnJvdygpIHtcbiAgICAgIHJldHVybiB0aGlzLnVubGlua1BhbmVscyAmJiB0aGlzLnJpZ2h0WWVhciA+IHRoaXMubGVmdFllYXIgKyAxO1xuICAgIH1cbiAgfSxcblxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3BwZXJDbGFzczogJycsXG4gICAgICB2YWx1ZTogW10sXG4gICAgICBkZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgICBkZWZhdWx0VGltZTogbnVsbCxcbiAgICAgIG1pbkRhdGU6ICcnLFxuICAgICAgbWF4RGF0ZTogJycsXG4gICAgICBsZWZ0RGF0ZTogbmV3IERhdGUoKSxcbiAgICAgIHJpZ2h0RGF0ZTogT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0WWVhclwiXSkobmV3IERhdGUoKSksXG4gICAgICByYW5nZVN0YXRlOiB7XG4gICAgICAgIGVuZERhdGU6IG51bGwsXG4gICAgICAgIHNlbGVjdGluZzogZmFsc2UsXG4gICAgICAgIHJvdzogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICB9LFxuICAgICAgc2hvcnRjdXRzOiAnJyxcbiAgICAgIHZpc2libGU6ICcnLFxuICAgICAgZGlzYWJsZWREYXRlOiAnJyxcbiAgICAgIGZvcm1hdDogJycsXG4gICAgICBhcnJvd0NvbnRyb2w6IGZhbHNlLFxuICAgICAgdW5saW5rUGFuZWxzOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWwpIHtcbiAgICAgIGlmICghbmV3VmFsKSB7XG4gICAgICAgIHRoaXMubWluRGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV3VmFsKSkge1xuICAgICAgICB0aGlzLm1pbkRhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkobmV3VmFsWzBdKSA/IG5ldyBEYXRlKG5ld1ZhbFswXSkgOiBudWxsO1xuICAgICAgICB0aGlzLm1heERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkobmV3VmFsWzFdKSA/IG5ldyBEYXRlKG5ld1ZhbFsxXSkgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5taW5EYXRlKSB7XG4gICAgICAgICAgdGhpcy5sZWZ0RGF0ZSA9IHRoaXMubWluRGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy51bmxpbmtQYW5lbHMgJiYgdGhpcy5tYXhEYXRlKSB7XG4gICAgICAgICAgICB2YXIgbWluRGF0ZVllYXIgPSB0aGlzLm1pbkRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIHZhciBtYXhEYXRlWWVhciA9IHRoaXMubWF4RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdGhpcy5yaWdodERhdGUgPSBtaW5EYXRlWWVhciA9PT0gbWF4RGF0ZVllYXIgPyBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRZZWFyXCJdKSh0aGlzLm1heERhdGUpIDogdGhpcy5tYXhEYXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dFllYXJcIl0pKHRoaXMubGVmdERhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlZnREYXRlID0gbW9udGhfcmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jYWxjRGVmYXVsdFZhbHVlKHRoaXMuZGVmYXVsdFZhbHVlKVswXTtcbiAgICAgICAgICB0aGlzLnJpZ2h0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dFllYXJcIl0pKHRoaXMubGVmdERhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWZhdWx0VmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZSh2YWwpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnZhbHVlKSkge1xuICAgICAgICB2YXIgX2NhbGNEZWZhdWx0VmFsdWUgPSBtb250aF9yYW5nZXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2NhbGNEZWZhdWx0VmFsdWUodmFsKSxcbiAgICAgICAgICAgIGxlZnQgPSBfY2FsY0RlZmF1bHRWYWx1ZVswXSxcbiAgICAgICAgICAgIHJpZ2h0ID0gX2NhbGNEZWZhdWx0VmFsdWVbMV07XG5cbiAgICAgICAgdGhpcy5sZWZ0RGF0ZSA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHREYXRlID0gdmFsICYmIHZhbFsxXSAmJiBsZWZ0LmdldEZ1bGxZZWFyKCkgIT09IHJpZ2h0LmdldEZ1bGxZZWFyKCkgJiYgdGhpcy51bmxpbmtQYW5lbHMgPyByaWdodCA6IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dFllYXJcIl0pKHRoaXMubGVmdERhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlQ2xlYXI6IGZ1bmN0aW9uIGhhbmRsZUNsZWFyKCkge1xuICAgICAgdGhpcy5taW5EYXRlID0gbnVsbDtcbiAgICAgIHRoaXMubWF4RGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLmxlZnREYXRlID0gbW9udGhfcmFuZ2V2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19jYWxjRGVmYXVsdFZhbHVlKHRoaXMuZGVmYXVsdFZhbHVlKVswXTtcbiAgICAgIHRoaXMucmlnaHREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0WWVhclwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgICB0aGlzLiRlbWl0KCdwaWNrJywgbnVsbCk7XG4gICAgfSxcbiAgICBoYW5kbGVDaGFuZ2VSYW5nZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlUmFuZ2UodmFsKSB7XG4gICAgICB0aGlzLm1pbkRhdGUgPSB2YWwubWluRGF0ZTtcbiAgICAgIHRoaXMubWF4RGF0ZSA9IHZhbC5tYXhEYXRlO1xuICAgICAgdGhpcy5yYW5nZVN0YXRlID0gdmFsLnJhbmdlU3RhdGU7XG4gICAgfSxcbiAgICBoYW5kbGVSYW5nZVBpY2s6IGZ1bmN0aW9uIGhhbmRsZVJhbmdlUGljayh2YWwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBjbG9zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICAgICAgdmFyIGRlZmF1bHRUaW1lID0gdGhpcy5kZWZhdWx0VGltZSB8fCBbXTtcbiAgICAgIHZhciBtaW5EYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJtb2RpZnlXaXRoVGltZVN0cmluZ1wiXSkodmFsLm1pbkRhdGUsIGRlZmF1bHRUaW1lWzBdKTtcbiAgICAgIHZhciBtYXhEYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJtb2RpZnlXaXRoVGltZVN0cmluZ1wiXSkodmFsLm1heERhdGUsIGRlZmF1bHRUaW1lWzFdKTtcbiAgICAgIGlmICh0aGlzLm1heERhdGUgPT09IG1heERhdGUgJiYgdGhpcy5taW5EYXRlID09PSBtaW5EYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25QaWNrICYmIHRoaXMub25QaWNrKHZhbCk7XG4gICAgICB0aGlzLm1heERhdGUgPSBtYXhEYXRlO1xuICAgICAgdGhpcy5taW5EYXRlID0gbWluRGF0ZTtcblxuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0VsZW1lRkUvZWxlbWVudC9pc3N1ZXMvNzUzOSwgc2hvdWxkIHJlbW92ZSB0aGlzIGJsb2NrIHdoZW4gd2UgZG9uJ3QgaGF2ZSB0byBjYXJlIGFib3V0IENocm9taXVtIDU1IC0gNTdcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5tYXhEYXRlID0gbWF4RGF0ZTtcbiAgICAgICAgX3RoaXMubWluRGF0ZSA9IG1pbkRhdGU7XG4gICAgICB9LCAxMCk7XG4gICAgICBpZiAoIWNsb3NlKSByZXR1cm47XG4gICAgICB0aGlzLmhhbmRsZUNvbmZpcm0oKTtcbiAgICB9LFxuICAgIGhhbmRsZVNob3J0Y3V0Q2xpY2s6IGZ1bmN0aW9uIGhhbmRsZVNob3J0Y3V0Q2xpY2soc2hvcnRjdXQpIHtcbiAgICAgIGlmIChzaG9ydGN1dC5vbkNsaWNrKSB7XG4gICAgICAgIHNob3J0Y3V0Lm9uQ2xpY2sodGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgLy8gbGVmdFByZXYqLCByaWdodE5leHQqIG5lZWQgdG8gdGFrZSBjYXJlIG9mIGB1bmxpbmtQYW5lbHNgXG4gICAgbGVmdFByZXZZZWFyOiBmdW5jdGlvbiBsZWZ0UHJldlllYXIoKSB7XG4gICAgICB0aGlzLmxlZnREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwcmV2WWVhclwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgICBpZiAoIXRoaXMudW5saW5rUGFuZWxzKSB7XG4gICAgICAgIHRoaXMucmlnaHREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJwcmV2WWVhclwiXSkodGhpcy5yaWdodERhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmlnaHROZXh0WWVhcjogZnVuY3Rpb24gcmlnaHROZXh0WWVhcigpIHtcbiAgICAgIGlmICghdGhpcy51bmxpbmtQYW5lbHMpIHtcbiAgICAgICAgdGhpcy5sZWZ0RGF0ZSA9IE9iamVjdChkYXRlX3V0aWxfW1wibmV4dFllYXJcIl0pKHRoaXMubGVmdERhdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5yaWdodERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcIm5leHRZZWFyXCJdKSh0aGlzLnJpZ2h0RGF0ZSk7XG4gICAgfSxcblxuXG4gICAgLy8gbGVmdE5leHQqLCByaWdodFByZXYqIGFyZSBjYWxsZWQgd2hlbiBgdW5saW5rUGFuZWxzYCBpcyB0cnVlXG4gICAgbGVmdE5leHRZZWFyOiBmdW5jdGlvbiBsZWZ0TmV4dFllYXIoKSB7XG4gICAgICB0aGlzLmxlZnREYXRlID0gT2JqZWN0KGRhdGVfdXRpbF9bXCJuZXh0WWVhclwiXSkodGhpcy5sZWZ0RGF0ZSk7XG4gICAgfSxcbiAgICByaWdodFByZXZZZWFyOiBmdW5jdGlvbiByaWdodFByZXZZZWFyKCkge1xuICAgICAgdGhpcy5yaWdodERhdGUgPSBPYmplY3QoZGF0ZV91dGlsX1tcInByZXZZZWFyXCJdKSh0aGlzLnJpZ2h0RGF0ZSk7XG4gICAgfSxcbiAgICBoYW5kbGVDb25maXJtOiBmdW5jdGlvbiBoYW5kbGVDb25maXJtKCkge1xuICAgICAgdmFyIHZpc2libGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5pc1ZhbGlkVmFsdWUoW3RoaXMubWluRGF0ZSwgdGhpcy5tYXhEYXRlXSkpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgncGljaycsIFt0aGlzLm1pbkRhdGUsIHRoaXMubWF4RGF0ZV0sIHZpc2libGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNWYWxpZFZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkVmFsdWUodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZSAmJiB2YWx1ZVswXSAmJiB2YWx1ZVsxXSAmJiBPYmplY3QoZGF0ZV91dGlsX1tcImlzRGF0ZVwiXSkodmFsdWVbMF0pICYmIE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlXCJdKSh2YWx1ZVsxXSkgJiYgdmFsdWVbMF0uZ2V0VGltZSgpIDw9IHZhbHVlWzFdLmdldFRpbWUoKSAmJiAodHlwZW9mIHRoaXMuZGlzYWJsZWREYXRlID09PSAnZnVuY3Rpb24nID8gIXRoaXMuZGlzYWJsZWREYXRlKHZhbHVlWzBdKSAmJiAhdGhpcy5kaXNhYmxlZERhdGUodmFsdWVbMV0pIDogdHJ1ZSk7XG4gICAgfSxcbiAgICByZXNldFZpZXc6IGZ1bmN0aW9uIHJlc2V0VmlldygpIHtcbiAgICAgIC8vIE5PVEU6IHRoaXMgaXMgYSBoYWNrIHRvIHJlc2V0IHttaW4sIG1heH1EYXRlIG9uIHBpY2tlciBvcGVuLlxuICAgICAgLy8gVE9ETzogY29ycmVjdCB3YXkgb2YgZG9pbmcgc28gaXMgdG8gcmVmYWN0b3Ige21pbiwgbWF4fURhdGUgdG8gYmUgZGVwZW5kZW50IG9uIHZhbHVlIGFuZCBpbnRlcm5hbCBzZWxlY3Rpb24gc3RhdGVcbiAgICAgIC8vICAgICAgIGFuIGFsdGVybmF0aXZlIHdvdWxkIGJlIHJlc2V0VmlldyB3aGVuZXZlciBwaWNrZXIgYmVjb21lcyB2aXNpYmxlLCBzaG91bGQgYWxzbyBpbnZlc3RpZ2F0ZSBkYXRlLXBhbmVsJ3MgcmVzZXRWaWV3XG4gICAgICB0aGlzLm1pbkRhdGUgPSB0aGlzLnZhbHVlICYmIE9iamVjdChkYXRlX3V0aWxfW1wiaXNEYXRlXCJdKSh0aGlzLnZhbHVlWzBdKSA/IG5ldyBEYXRlKHRoaXMudmFsdWVbMF0pIDogbnVsbDtcbiAgICAgIHRoaXMubWF4RGF0ZSA9IHRoaXMudmFsdWUgJiYgT2JqZWN0KGRhdGVfdXRpbF9bXCJpc0RhdGVcIl0pKHRoaXMudmFsdWVbMF0pID8gbmV3IERhdGUodGhpcy52YWx1ZVsxXSkgOiBudWxsO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRzOiB7IE1vbnRoVGFibGU6IG1vbnRoX3RhYmxlLCBFbElucHV0OiBpbnB1dF9kZWZhdWx0LmEsIEVsQnV0dG9uOiBidXR0b25fZGVmYXVsdC5hIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvbW9udGgtcmFuZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBhbmVsX21vbnRoX3JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKG1vbnRoX3JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2RhdGUtcGlja2VyL3NyYy9wYW5lbC9tb250aC1yYW5nZS52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBtb250aF9yYW5nZV9jb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIHBhbmVsX21vbnRoX3JhbmdldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBtb250aF9yYW5nZXZ1ZV90eXBlX3RlbXBsYXRlX2lkX2YyNjQ1ZmI4X3JlbmRlcixcbiAgbW9udGhfcmFuZ2V2dWVfdHlwZV90ZW1wbGF0ZV9pZF9mMjY0NWZiOF9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIG1vbnRoX3JhbmdlX2FwaTsgfVxubW9udGhfcmFuZ2VfY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWNrYWdlcy9kYXRlLXBpY2tlci9zcmMvcGFuZWwvbW9udGgtcmFuZ2UudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1vbnRoX3JhbmdlID0gKG1vbnRoX3JhbmdlX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvc3JjL3BpY2tlci9kYXRlLXBpY2tlci5qc1xuXG5cblxuXG5cbnZhciBkYXRlX3BpY2tlcl9nZXRQYW5lbCA9IGZ1bmN0aW9uIGdldFBhbmVsKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdkYXRlcmFuZ2UnIHx8IHR5cGUgPT09ICdkYXRldGltZXJhbmdlJykge1xuICAgIHJldHVybiBkYXRlX3JhbmdlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtb250aHJhbmdlJykge1xuICAgIHJldHVybiBtb250aF9yYW5nZTtcbiAgfVxuICByZXR1cm4gcGFuZWxfZGF0ZTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRhdGVfcGlja2VyID0gKHtcbiAgbWl4aW5zOiBbcGlja2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dXSxcblxuICBuYW1lOiAnRWxEYXRlUGlja2VyJyxcblxuICBwcm9wczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkYXRlJ1xuICAgIH0sXG4gICAgdGltZUFycm93Q29udHJvbDogQm9vbGVhblxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgdHlwZTogZnVuY3Rpb24gdHlwZShfdHlwZSkge1xuICAgICAgaWYgKHRoaXMucGlja2VyKSB7XG4gICAgICAgIHRoaXMudW5tb3VudFBpY2tlcigpO1xuICAgICAgICB0aGlzLnBhbmVsID0gZGF0ZV9waWNrZXJfZ2V0UGFuZWwoX3R5cGUpO1xuICAgICAgICB0aGlzLm1vdW50UGlja2VyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhbmVsID0gZGF0ZV9waWNrZXJfZ2V0UGFuZWwoX3R5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMucGFuZWwgPSBkYXRlX3BpY2tlcl9nZXRQYW5lbCh0aGlzLnR5cGUpO1xuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZGF0ZS1waWNrZXIvaW5kZXguanNcblxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZGF0ZV9waWNrZXIuaW5zdGFsbCA9IGZ1bmN0aW9uIGluc3RhbGwoVnVlKSB7XG4gIFZ1ZS5jb21wb25lbnQoZGF0ZV9waWNrZXIubmFtZSwgZGF0ZV9waWNrZXIpO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFja2FnZXNfZGF0ZV9waWNrZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChkYXRlX3BpY2tlcik7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///168\n')}}]);